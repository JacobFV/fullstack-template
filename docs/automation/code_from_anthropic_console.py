import anthropic

client = anthropic.Anthropic() # defaults to os.environ.get("ANTHROPIC_API_KEY")

message = client.messages.create(
    model="claude-3-opus-20240229",
    max_tokens=4000,
    temperature=0,
    system="Convert this frontend template into a client for our backend.",
    messages=[
        {
            "role": "user",
            "content": [
                {
                    "type": "text",
                    "text": "Start by reading and understanding our frontend template we cloned from the github (this will obviously need to be modified some):\n\n$ tree . -I node_modules\n.\n├── biome.json\n├── Dockerfile\n├── dump.txt\n├── index.html\n├── modify-openapi-operationids.js\n├── nginx-backend-not-found.conf\n├── nginx.conf\n├── package.json\n├── package-lock.json\n├── public\n│   └── assets\n│       └── images\n│           ├── fastapi-logo.svg\n│           └── favicon.png\n├── README.md\n├── src\n│   ├── client\n│   │   ├── core\n│   │   │   ├── ApiError.ts\n│   │   │   ├── ApiRequestOptions.ts\n│   │   │   ├── ApiResult.ts\n│   │   │   ├── CancelablePromise.ts\n│   │   │   ├── OpenAPI.ts\n│   │   │   ├── request.ts\n│   │   │   └── types.ts\n│   │   ├── index.ts\n│   │   ├── models.ts\n│   │   ├── schemas.ts\n│   │   └── services.ts\n│   ├── components\n│   │   ├── Admin\n│   │   │   ├── AddUser.tsx\n│   │   │   └── EditUser.tsx\n│   │   ├── Common\n│   │   │   ├── ActionsMenu.tsx\n│   │   │   ├── DeleteAlert.tsx\n│   │   │   ├── Navbar.tsx\n│   │   │   ├── NotFound.tsx\n│   │   │   ├── SidebarItems.tsx\n│   │   │   ├── Sidebar.tsx\n│   │   │   └── UserMenu.tsx\n│   │   ├── Gotcha\n│   │   │   └── VerifyCameraStream.tsx\n│   │   ├── Items\n│   │   │   ├── AddItem.tsx\n│   │   │   └── EditItem.tsx\n│   │   └── UserSettings\n│   │       ├── Appearance.tsx\n│   │       ├── ChangePassword.tsx\n│   │       ├── DeleteAccount.tsx\n│   │       ├── DeleteConfirmation.tsx\n│   │       └── UserInformation.tsx\n│   ├── hooks\n│   │   ├── useAuth.ts\n│   │   └── useCustomToast.ts\n│   ├── main.tsx\n│   ├── routes\n│   │   ├── _layout\n│   │   │   ├── admin.tsx\n│   │   │   ├── gotcha.tsx\n│   │   │   ├── index.tsx\n│   │   │   ├── items.tsx\n│   │   │   └── settings.tsx\n│   │   ├── _layout.tsx\n│   │   ├── login.tsx\n│   │   ├── recover-password.tsx\n│   │   ├── reset-password.tsx\n│   │   └── __root.tsx\n│   ├── routeTree.gen.ts\n│   ├── theme.tsx\n│   ├── utils.ts\n│   └── vite-env.d.ts\n├── tsconfig.json\n├── tsconfig.node.json\n└── vite.config.ts\n\n15 directories, 60 files\n\n$ find src -type f -exec sh -c 'echo \"<{}>\"; cat {}; echo \"</{}>\\n\"' \\; > dump.txt\n\n<src/hooks/useAuth.ts>\nimport { useMutation, useQuery } from \"@tanstack/react-query\"\nimport { useNavigate } from \"@tanstack/react-router\"\nimport { useState } from \"react\"\n\nimport { AxiosError } from \"axios\"\nimport {\n  type Body_login_login_access_token as AccessToken,\n  type ApiError,\n  LoginService,\n  type UserPublic,\n  UsersService,\n} from \"../client\"\n\nconst isLoggedIn = () => {\n  return localStorage.getItem(\"access_token\") !== null\n}\n\nconst useAuth = () => {\n  const [error, setError] = useState<string | null>(null)\n  const navigate = useNavigate()\n  const { data: user, isLoading } = useQuery<UserPublic | null, Error>({\n    queryKey: [\"currentUser\"],\n    queryFn: UsersService.readUserMe,\n    enabled: isLoggedIn(),\n  })\n\n  const login = async (data: AccessToken) => {\n    const response = await LoginService.loginAccessToken({\n      formData: data,\n    })\n    localStorage.setItem(\"access_token\", response.access_token)\n  }\n\n  const loginMutation = useMutation({\n    mutationFn: login,\n    onSuccess: () => {\n      navigate({ to: \"/\" })\n    },\n    onError: (err: ApiError) => {\n      let errDetail = (err.body as any)?.detail\n\n      if (err instanceof AxiosError) {\n        errDetail = err.message\n      }\n\n      if (Array.isArray(errDetail)) {\n        errDetail = \"Something went wrong\"\n      }\n\n      setError(errDetail)\n    },\n  })\n\n  const logout = () => {\n    localStorage.removeItem(\"access_token\")\n    navigate({ to: \"/login\" })\n  }\n\n  return {\n    loginMutation,\n    logout,\n    user,\n    isLoading,\n    error,\n    resetError: () => setError(null),\n  }\n}\n\nexport { isLoggedIn }\nexport default useAuth\n</src/hooks/useAuth.ts>\n\n<src/hooks/useCustomToast.ts>\nimport { useToast } from \"@chakra-ui/react\"\nimport { useCallback } from \"react\"\n\nconst useCustomToast = () => {\n  const toast = useToast()\n\n  const showToast = useCallback(\n    (title: string, description: string, status: \"success\" | \"error\") => {\n      toast({\n        title,\n        description,\n        status,\n        isClosable: true,\n        position: \"bottom-right\",\n      })\n    },\n    [toast],\n  )\n\n  return showToast\n}\n\nexport default useCustomToast\n</src/hooks/useCustomToast.ts>\n\n<src/utils.ts>\nexport const emailPattern = {\n  value: /^[A-Z0-9._%+-]+@[A-Z0-9.-]+\\.[A-Z]{2,}$/i,\n  message: \"Invalid email address\",\n}\n\nexport const namePattern = {\n  value: /^[A-Za-z\\s\\u00C0-\\u017F]{1,30}$/,\n  message: \"Invalid name\",\n}\n\nexport const passwordRules = (isRequired = true) => {\n  const rules: any = {\n    minLength: {\n      value: 8,\n      message: \"Password must be at least 8 characters\",\n    },\n  }\n\n  if (isRequired) {\n    rules.required = \"Password is required\"\n  }\n\n  return rules\n}\n\nexport const confirmPasswordRules = (\n  getValues: () => any,\n  isRequired = true,\n) => {\n  const rules: any = {\n    validate: (value: string) => {\n      const password = getValues().password || getValues().new_password\n      return value === password ? true : \"The passwords do not match\"\n    },\n  }\n\n  if (isRequired) {\n    rules.required = \"Password confirmation is required\"\n  }\n\n  return rules\n}\n</src/utils.ts>\n\n<src/routes/recover-password.tsx>\nimport {\n  Button,\n  Container,\n  FormControl,\n  FormErrorMessage,\n  Heading,\n  Input,\n  Text,\n} from \"@chakra-ui/react\"\nimport { createFileRoute, redirect } from \"@tanstack/react-router\"\nimport { type SubmitHandler, useForm } from \"react-hook-form\"\n\nimport { LoginService } from \"../client\"\nimport { isLoggedIn } from \"../hooks/useAuth\"\nimport useCustomToast from \"../hooks/useCustomToast\"\nimport { emailPattern } from \"../utils\"\n\ninterface FormData {\n  email: string\n}\n\nexport const Route = createFileRoute(\"/recover-password\")({\n  component: RecoverPassword,\n  beforeLoad: async () => {\n    if (isLoggedIn()) {\n      throw redirect({\n        to: \"/\",\n      })\n    }\n  },\n})\n\nfunction RecoverPassword() {\n  const {\n    register,\n    handleSubmit,\n    formState: { errors, isSubmitting },\n  } = useForm<FormData>()\n  const showToast = useCustomToast()\n\n  const onSubmit: SubmitHandler<FormData> = async (data) => {\n    await LoginService.recoverPassword({\n      email: data.email,\n    })\n    showToast(\n      \"Email sent.\",\n      \"We sent an email with a link to get back into your account.\",\n      \"success\",\n    )\n  }\n\n  return (\n    <Container\n      as=\"form\"\n      onSubmit={handleSubmit(onSubmit)}\n      h=\"100vh\"\n      maxW=\"sm\"\n      alignItems=\"stretch\"\n      justifyContent=\"center\"\n      gap={4}\n      centerContent\n    >\n      <Heading size=\"xl\" color=\"ui.main\" textAlign=\"center\" mb={2}>\n        Password Recovery\n      </Heading>\n      <Text align=\"center\">\n        A password recovery email will be sent to the registered account.\n      </Text>\n      <FormControl isInvalid={!!errors.email}>\n        <Input\n          id=\"email\"\n          {...register(\"email\", {\n            required: \"Email is required\",\n            pattern: emailPattern,\n          })}\n          placeholder=\"Email\"\n          type=\"email\"\n        />\n        {errors.email && (\n          <FormErrorMessage>{errors.email.message}</FormErrorMessage>\n        )}\n      </FormControl>\n      <Button variant=\"primary\" type=\"submit\" isLoading={isSubmitting}>\n        Continue\n      </Button>\n    </Container>\n  )\n}\n</src/routes/recover-password.tsx>\n\n<src/routes/_layout/index.tsx>\nimport { Box, Container, Text } from \"@chakra-ui/react\"\nimport { useQueryClient } from \"@tanstack/react-query\"\nimport { createFileRoute } from \"@tanstack/react-router\"\n\nimport type { UserPublic } from \"../../client\"\n\nexport const Route = createFileRoute(\"/_layout/\")({\n  component: Dashboard,\n})\n\nfunction Dashboard() {\n  const queryClient = useQueryClient()\n\n  const currentUser = queryClient.getQueryData<UserPublic>([\"currentUser\"])\n\n  return (\n    <>\n      <Container maxW=\"full\">\n        <Box pt={12} m={4}>\n          <Text fontSize=\"2xl\">\n            Hi, {currentUser?.full_name || currentUser?.email} 👋🏼\n          </Text>\n          <Text>Welcome back, nice to see you again!</Text>\n        </Box>\n      </Container>\n    </>\n  )\n}\n</src/routes/_layout/index.tsx>\n\n<src/routes/_layout/admin.tsx>\nimport {\n  Badge,\n  Box,\n  Container,\n  Flex,\n  Heading,\n  SkeletonText,\n  Table,\n  TableContainer,\n  Tbody,\n  Td,\n  Th,\n  Thead,\n  Tr,\n} from \"@chakra-ui/react\"\nimport { useQueryClient, useSuspenseQuery } from \"@tanstack/react-query\"\nimport { createFileRoute } from \"@tanstack/react-router\"\n\nimport { Suspense } from \"react\"\nimport { type UserPublic, UsersService } from \"../../client\"\nimport ActionsMenu from \"../../components/Common/ActionsMenu\"\nimport Navbar from \"../../components/Common/Navbar\"\n\nexport const Route = createFileRoute(\"/_layout/admin\")({\n  component: Admin,\n})\n\nconst MembersTableBody = () => {\n  const queryClient = useQueryClient()\n  const currentUser = queryClient.getQueryData<UserPublic>([\"currentUser\"])\n\n  const { data: users } = useSuspenseQuery({\n    queryKey: [\"users\"],\n    queryFn: () => UsersService.readUsers({}),\n  })\n\n  return (\n    <Tbody>\n      {users.data.map((user) => (\n        <Tr key={user.id}>\n          <Td color={!user.full_name ? \"ui.dim\" : \"inherit\"}>\n            {user.full_name || \"N/A\"}\n            {currentUser?.id === user.id && (\n              <Badge ml=\"1\" colorScheme=\"teal\">\n                You\n              </Badge>\n            )}\n          </Td>\n          <Td>{user.email}</Td>\n          <Td>{user.is_superuser ? \"Superuser\" : \"User\"}</Td>\n          <Td>\n            <Flex gap={2}>\n              <Box\n                w=\"2\"\n                h=\"2\"\n                borderRadius=\"50%\"\n                bg={user.is_active ? \"ui.success\" : \"ui.danger\"}\n                alignSelf=\"center\"\n              />\n              {user.is_active ? \"Active\" : \"Inactive\"}\n            </Flex>\n          </Td>\n          <Td>\n            <ActionsMenu\n              type=\"User\"\n              value={user}\n              disabled={currentUser?.id === user.id ? true : false}\n            />\n          </Td>\n        </Tr>\n      ))}\n    </Tbody>\n  )\n}\n\nconst MembersBodySkeleton = () => {\n  return (\n    <Tbody>\n      <Tr>\n        {new Array(5).fill(null).map((_, index) => (\n          <Td key={index}>\n            <SkeletonText noOfLines={1} paddingBlock=\"16px\" />\n          </Td>\n        ))}\n      </Tr>\n    </Tbody>\n  )\n}\n\nfunction Admin() {\n  return (\n    <Container maxW=\"full\">\n      <Heading size=\"lg\" textAlign={{ base: \"center\", md: \"left\" }} pt={12}>\n        User Management\n      </Heading>\n      <Navbar type={\"User\"} />\n      <TableContainer>\n        <Table fontSize=\"md\" size={{ base: \"sm\", md: \"md\" }}>\n          <Thead>\n            <Tr>\n              <Th width=\"20%\">Full name</Th>\n              <Th width=\"50%\">Email</Th>\n              <Th width=\"10%\">Role</Th>\n              <Th width=\"10%\">Status</Th>\n              <Th width=\"10%\">Actions</Th>\n            </Tr>\n          </Thead>\n          <Suspense fallback={<MembersBodySkeleton />}>\n            <MembersTableBody />\n          </Suspense>\n        </Table>\n      </TableContainer>\n    </Container>\n  )\n}\n</src/routes/_layout/admin.tsx>\n\n<src/routes/_layout/settings.tsx>\nimport {\n  Container,\n  Heading,\n  Tab,\n  TabList,\n  TabPanel,\n  TabPanels,\n  Tabs,\n} from \"@chakra-ui/react\"\nimport { useQueryClient } from \"@tanstack/react-query\"\nimport { createFileRoute } from \"@tanstack/react-router\"\n\nimport type { UserPublic } from \"../../client\"\nimport Appearance from \"../../components/UserSettings/Appearance\"\nimport ChangePassword from \"../../components/UserSettings/ChangePassword\"\nimport DeleteAccount from \"../../components/UserSettings/DeleteAccount\"\nimport UserInformation from \"../../components/UserSettings/UserInformation\"\n\nconst tabsConfig = [\n  { title: \"My profile\", component: UserInformation },\n  { title: \"Password\", component: ChangePassword },\n  { title: \"Appearance\", component: Appearance },\n  { title: \"Danger zone\", component: DeleteAccount },\n]\n\nexport const Route = createFileRoute(\"/_layout/settings\")({\n  component: UserSettings,\n})\n\nfunction UserSettings() {\n  const queryClient = useQueryClient()\n  const currentUser = queryClient.getQueryData<UserPublic>([\"currentUser\"])\n  const finalTabs = currentUser?.is_superuser\n    ? tabsConfig.slice(0, 3)\n    : tabsConfig\n\n  return (\n    <Container maxW=\"full\">\n      <Heading size=\"lg\" textAlign={{ base: \"center\", md: \"left\" }} py={12}>\n        User Settings\n      </Heading>\n      <Tabs variant=\"enclosed\">\n        <TabList>\n          {finalTabs.map((tab, index) => (\n            <Tab key={index}>{tab.title}</Tab>\n          ))}\n        </TabList>\n        <TabPanels>\n          {finalTabs.map((tab, index) => (\n            <TabPanel key={index}>\n              <tab.component />\n            </TabPanel>\n          ))}\n        </TabPanels>\n      </Tabs>\n    </Container>\n  )\n}\n</src/routes/_layout/settings.tsx>\n\n<src/routes/_layout/gotcha.tsx>\nimport React from 'react';\nimport VideoStreamer from '../../components/Gotcha/VerifyCameraStream';\nimport { createFileRoute } from '@tanstack/react-router';\n\nexport const Route = createFileRoute(\"/_layout/gotcha\")({\n    component: Gotcha,\n  })\n\nfunction Gotcha() {\n    return (\n        <div>\n            <h1>Video Verification</h1>\n            <VideoStreamer />\n        </div>\n    );\n};\n</src/routes/_layout/gotcha.tsx>\n\n<src/routes/_layout/items.tsx>\nimport {\n  Container,\n  Flex,\n  Heading,\n  Skeleton,\n  Table,\n  TableContainer,\n  Tbody,\n  Td,\n  Th,\n  Thead,\n  Tr,\n} from \"@chakra-ui/react\"\nimport { useSuspenseQuery } from \"@tanstack/react-query\"\nimport { createFileRoute } from \"@tanstack/react-router\"\n\nimport { Suspense } from \"react\"\nimport { ErrorBoundary } from \"react-error-boundary\"\nimport { ItemsService } from \"../../client\"\nimport ActionsMenu from \"../../components/Common/ActionsMenu\"\nimport Navbar from \"../../components/Common/Navbar\"\n\nexport const Route = createFileRoute(\"/_layout/items\")({\n  component: Items,\n})\n\nfunction ItemsTableBody() {\n  const { data: items } = useSuspenseQuery({\n    queryKey: [\"items\"],\n    queryFn: () => ItemsService.readItems({}),\n  })\n\n  return (\n    <Tbody>\n      {items.data.map((item) => (\n        <Tr key={item.id}>\n          <Td>{item.id}</Td>\n          <Td>{item.title}</Td>\n          <Td color={!item.description ? \"ui.dim\" : \"inherit\"}>\n            {item.description || \"N/A\"}\n          </Td>\n          <Td>\n            <ActionsMenu type={\"Item\"} value={item} />\n          </Td>\n        </Tr>\n      ))}\n    </Tbody>\n  )\n}\nfunction ItemsTable() {\n  return (\n    <TableContainer>\n      <Table size={{ base: \"sm\", md: \"md\" }}>\n        <Thead>\n          <Tr>\n            <Th>ID</Th>\n            <Th>Title</Th>\n            <Th>Description</Th>\n            <Th>Actions</Th>\n          </Tr>\n        </Thead>\n        <ErrorBoundary\n          fallbackRender={({ error }) => (\n            <Tbody>\n              <Tr>\n                <Td colSpan={4}>Something went wrong: {error.message}</Td>\n              </Tr>\n            </Tbody>\n          )}\n        >\n          <Suspense\n            fallback={\n              <Tbody>\n                {new Array(5).fill(null).map((_, index) => (\n                  <Tr key={index}>\n                    {new Array(4).fill(null).map((_, index) => (\n                      <Td key={index}>\n                        <Flex>\n                          <Skeleton height=\"20px\" width=\"20px\" />\n                        </Flex>\n                      </Td>\n                    ))}\n                  </Tr>\n                ))}\n              </Tbody>\n            }\n          >\n            <ItemsTableBody />\n          </Suspense>\n        </ErrorBoundary>\n      </Table>\n    </TableContainer>\n  )\n}\n\nfunction Items() {\n  return (\n    <Container maxW=\"full\">\n      <Heading size=\"lg\" textAlign={{ base: \"center\", md: \"left\" }} pt={12}>\n        Items Management\n      </Heading>\n\n      <Navbar type={\"Item\"} />\n      <ItemsTable />\n    </Container>\n  )\n}\n</src/routes/_layout/items.tsx>\n\n<src/routes/__root.tsx>\nimport { Outlet, createRootRoute } from \"@tanstack/react-router\"\nimport React, { Suspense } from \"react\"\n\nimport NotFound from \"../components/Common/NotFound\"\n\nconst TanStackRouterDevtools =\n  process.env.NODE_ENV === \"production\"\n    ? () => null\n    : React.lazy(() =>\n        import(\"@tanstack/router-devtools\").then((res) => ({\n          default: res.TanStackRouterDevtools,\n        })),\n      )\n\nexport const Route = createRootRoute({\n  component: () => (\n    <>\n      <Outlet />\n      <Suspense>\n        <TanStackRouterDevtools />\n      </Suspense>\n    </>\n  ),\n  notFoundComponent: () => <NotFound />,\n})\n</src/routes/__root.tsx>\n\n<src/routes/reset-password.tsx>\nimport {\n  Button,\n  Container,\n  FormControl,\n  FormErrorMessage,\n  FormLabel,\n  Heading,\n  Input,\n  Text,\n} from \"@chakra-ui/react\"\nimport { useMutation } from \"@tanstack/react-query\"\nimport { createFileRoute, redirect, useNavigate } from \"@tanstack/react-router\"\nimport { type SubmitHandler, useForm } from \"react-hook-form\"\n\nimport { type ApiError, LoginService, type NewPassword } from \"../client\"\nimport { isLoggedIn } from \"../hooks/useAuth\"\nimport useCustomToast from \"../hooks/useCustomToast\"\nimport { confirmPasswordRules, passwordRules } from \"../utils\"\n\ninterface NewPasswordForm extends NewPassword {\n  confirm_password: string\n}\n\nexport const Route = createFileRoute(\"/reset-password\")({\n  component: ResetPassword,\n  beforeLoad: async () => {\n    if (isLoggedIn()) {\n      throw redirect({\n        to: \"/\",\n      })\n    }\n  },\n})\n\nfunction ResetPassword() {\n  const {\n    register,\n    handleSubmit,\n    getValues,\n    reset,\n    formState: { errors },\n  } = useForm<NewPasswordForm>({\n    mode: \"onBlur\",\n    criteriaMode: \"all\",\n    defaultValues: {\n      new_password: \"\",\n    },\n  })\n  const showToast = useCustomToast()\n  const navigate = useNavigate()\n\n  const resetPassword = async (data: NewPassword) => {\n    const token = new URLSearchParams(window.location.search).get(\"token\")\n    if (!token) return\n    await LoginService.resetPassword({\n      requestBody: { new_password: data.new_password, token: token },\n    })\n  }\n\n  const mutation = useMutation({\n    mutationFn: resetPassword,\n    onSuccess: () => {\n      showToast(\"Success!\", \"Password updated.\", \"success\")\n      reset()\n      navigate({ to: \"/login\" })\n    },\n    onError: (err: ApiError) => {\n      const errDetail = (err.body as any)?.detail\n      showToast(\"Something went wrong.\", `${errDetail}`, \"error\")\n    },\n  })\n\n  const onSubmit: SubmitHandler<NewPasswordForm> = async (data) => {\n    mutation.mutate(data)\n  }\n\n  return (\n    <Container\n      as=\"form\"\n      onSubmit={handleSubmit(onSubmit)}\n      h=\"100vh\"\n      maxW=\"sm\"\n      alignItems=\"stretch\"\n      justifyContent=\"center\"\n      gap={4}\n      centerContent\n    >\n      <Heading size=\"xl\" color=\"ui.main\" textAlign=\"center\" mb={2}>\n        Reset Password\n      </Heading>\n      <Text textAlign=\"center\">\n        Please enter your new password and confirm it to reset your password.\n      </Text>\n      <FormControl mt={4} isInvalid={!!errors.new_password}>\n        <FormLabel htmlFor=\"password\">Set Password</FormLabel>\n        <Input\n          id=\"password\"\n          {...register(\"new_password\", passwordRules())}\n          placeholder=\"Password\"\n          type=\"password\"\n        />\n        {errors.new_password && (\n          <FormErrorMessage>{errors.new_password.message}</FormErrorMessage>\n        )}\n      </FormControl>\n      <FormControl mt={4} isInvalid={!!errors.confirm_password}>\n        <FormLabel htmlFor=\"confirm_password\">Confirm Password</FormLabel>\n        <Input\n          id=\"confirm_password\"\n          {...register(\"confirm_password\", confirmPasswordRules(getValues))}\n          placeholder=\"Password\"\n          type=\"password\"\n        />\n        {errors.confirm_password && (\n          <FormErrorMessage>{errors.confirm_password.message}</FormErrorMessage>\n        )}\n      </FormControl>\n      <Button variant=\"primary\" type=\"submit\">\n        Reset Password\n      </Button>\n    </Container>\n  )\n}\n</src/routes/reset-password.tsx>\n\n<src/routes/_layout.tsx>\nimport { Flex, Spinner } from \"@chakra-ui/react\"\nimport { Outlet, createFileRoute, redirect } from \"@tanstack/react-router\"\n\nimport Sidebar from \"../components/Common/Sidebar\"\nimport UserMenu from \"../components/Common/UserMenu\"\nimport useAuth, { isLoggedIn } from \"../hooks/useAuth\"\n\nexport const Route = createFileRoute(\"/_layout\")({\n  component: Layout,\n  beforeLoad: async () => {\n    if (!isLoggedIn()) {\n      throw redirect({\n        to: \"/login\",\n      })\n    }\n  },\n})\n\nfunction Layout() {\n  const { isLoading } = useAuth()\n\n  return (\n    <Flex maxW=\"large\" h=\"auto\" position=\"relative\">\n      <Sidebar />\n      {isLoading ? (\n        <Flex justify=\"center\" align=\"center\" height=\"100vh\" width=\"full\">\n          <Spinner size=\"xl\" color=\"ui.main\" />\n        </Flex>\n      ) : (\n        <Outlet />\n      )}\n      <UserMenu />\n    </Flex>\n  )\n}\n</src/routes/_layout.tsx>\n\n<src/routes/login.tsx>\nimport { ViewIcon, ViewOffIcon } from \"@chakra-ui/icons\"\nimport {\n  Button,\n  Center,\n  Container,\n  FormControl,\n  FormErrorMessage,\n  Icon,\n  Image,\n  Input,\n  InputGroup,\n  InputRightElement,\n  Link,\n  useBoolean,\n} from \"@chakra-ui/react\"\nimport {\n  Link as RouterLink,\n  createFileRoute,\n  redirect,\n} from \"@tanstack/react-router\"\nimport { type SubmitHandler, useForm } from \"react-hook-form\"\n\nimport Logo from \"/assets/images/fastapi-logo.svg\"\nimport type { Body_login_login_access_token as AccessToken } from \"../client\"\nimport useAuth, { isLoggedIn } from \"../hooks/useAuth\"\nimport { emailPattern } from \"../utils\"\n\nexport const Route = createFileRoute(\"/login\")({\n  component: Login,\n  beforeLoad: async () => {\n    if (isLoggedIn()) {\n      throw redirect({\n        to: \"/\",\n      })\n    }\n  },\n})\n\nfunction Login() {\n  const [show, setShow] = useBoolean()\n  const { loginMutation, error, resetError } = useAuth()\n  const {\n    register,\n    handleSubmit,\n    formState: { errors, isSubmitting },\n  } = useForm<AccessToken>({\n    mode: \"onBlur\",\n    criteriaMode: \"all\",\n    defaultValues: {\n      username: \"\",\n      password: \"\",\n    },\n  })\n\n  const onSubmit: SubmitHandler<AccessToken> = async (data) => {\n    if (isSubmitting) return\n\n    resetError()\n\n    try {\n      await loginMutation.mutateAsync(data)\n    } catch {\n      // error is handled by useAuth hook\n    }\n  }\n\n  return (\n    <>\n      <Container\n        as=\"form\"\n        onSubmit={handleSubmit(onSubmit)}\n        h=\"100vh\"\n        maxW=\"sm\"\n        alignItems=\"stretch\"\n        justifyContent=\"center\"\n        gap={4}\n        centerContent\n      >\n        <Image\n          src={Logo}\n          alt=\"FastAPI logo\"\n          height=\"auto\"\n          maxW=\"2xs\"\n          alignSelf=\"center\"\n          mb={4}\n        />\n        <FormControl id=\"username\" isInvalid={!!errors.username || !!error}>\n          <Input\n            id=\"username\"\n            {...register(\"username\", {\n              pattern: emailPattern,\n            })}\n            placeholder=\"Email\"\n            type=\"email\"\n            required\n          />\n          {errors.username && (\n            <FormErrorMessage>{errors.username.message}</FormErrorMessage>\n          )}\n        </FormControl>\n        <FormControl id=\"password\" isInvalid={!!error}>\n          <InputGroup>\n            <Input\n              {...register(\"password\")}\n              type={show ? \"text\" : \"password\"}\n              placeholder=\"Password\"\n              required\n            />\n            <InputRightElement\n              color=\"ui.dim\"\n              _hover={{\n                cursor: \"pointer\",\n              }}\n            >\n              <Icon\n                onClick={setShow.toggle}\n                aria-label={show ? \"Hide password\" : \"Show password\"}\n              >\n                {show ? <ViewOffIcon /> : <ViewIcon />}\n              </Icon>\n            </InputRightElement>\n          </InputGroup>\n          {error && <FormErrorMessage>{error}</FormErrorMessage>}\n        </FormControl>\n        <Center>\n          <Link as={RouterLink} to=\"/recover-password\" color=\"blue.500\">\n            Forgot password?\n          </Link>\n        </Center>\n        <Button variant=\"primary\" type=\"submit\" isLoading={isSubmitting}>\n          Log In\n        </Button>\n      </Container>\n    </>\n  )\n}\n</src/routes/login.tsx>\n\n<src/routeTree.gen.ts>\n/* prettier-ignore-start */\n\n/* eslint-disable */\n\n// @ts-nocheck\n\n// noinspection JSUnusedGlobalSymbols\n\n// This file is auto-generated by TanStack Router\n\n// Import Routes\n\nimport { Route as rootRoute } from './routes/__root'\nimport { Route as ResetPasswordImport } from './routes/reset-password'\nimport { Route as RecoverPasswordImport } from './routes/recover-password'\nimport { Route as LoginImport } from './routes/login'\nimport { Route as LayoutImport } from './routes/_layout'\nimport { Route as LayoutIndexImport } from './routes/_layout/index'\nimport { Route as LayoutSettingsImport } from './routes/_layout/settings'\nimport { Route as LayoutItemsImport } from './routes/_layout/items'\nimport { Route as LayoutGotchaImport } from './routes/_layout/gotcha'\nimport { Route as LayoutAdminImport } from './routes/_layout/admin'\n\n// Create/Update Routes\n\nconst ResetPasswordRoute = ResetPasswordImport.update({\n  path: '/reset-password',\n  getParentRoute: () => rootRoute,\n} as any)\n\nconst RecoverPasswordRoute = RecoverPasswordImport.update({\n  path: '/recover-password',\n  getParentRoute: () => rootRoute,\n} as any)\n\nconst LoginRoute = LoginImport.update({\n  path: '/login',\n  getParentRoute: () => rootRoute,\n} as any)\n\nconst LayoutRoute = LayoutImport.update({\n  id: '/_layout',\n  getParentRoute: () => rootRoute,\n} as any)\n\nconst LayoutIndexRoute = LayoutIndexImport.update({\n  path: '/',\n  getParentRoute: () => LayoutRoute,\n} as any)\n\nconst LayoutSettingsRoute = LayoutSettingsImport.update({\n  path: '/settings',\n  getParentRoute: () => LayoutRoute,\n} as any)\n\nconst LayoutItemsRoute = LayoutItemsImport.update({\n  path: '/items',\n  getParentRoute: () => LayoutRoute,\n} as any)\n\nconst LayoutGotchaRoute = LayoutGotchaImport.update({\n  path: '/gotcha',\n  getParentRoute: () => LayoutRoute,\n} as any)\n\nconst LayoutAdminRoute = LayoutAdminImport.update({\n  path: '/admin',\n  getParentRoute: () => LayoutRoute,\n} as any)\n\n// Populate the FileRoutesByPath interface\n\ndeclare module '@tanstack/react-router' {\n  interface FileRoutesByPath {\n    '/_layout': {\n      preLoaderRoute: typeof LayoutImport\n      parentRoute: typeof rootRoute\n    }\n    '/login': {\n      preLoaderRoute: typeof LoginImport\n      parentRoute: typeof rootRoute\n    }\n    '/recover-password': {\n      preLoaderRoute: typeof RecoverPasswordImport\n      parentRoute: typeof rootRoute\n    }\n    '/reset-password': {\n      preLoaderRoute: typeof ResetPasswordImport\n      parentRoute: typeof rootRoute\n    }\n    '/_layout/admin': {\n      preLoaderRoute: typeof LayoutAdminImport\n      parentRoute: typeof LayoutImport\n    }\n    '/_layout/gotcha': {\n      preLoaderRoute: typeof LayoutGotchaImport\n      parentRoute: typeof LayoutImport\n    }\n    '/_layout/items': {\n      preLoaderRoute: typeof LayoutItemsImport\n      parentRoute: typeof LayoutImport\n    }\n    '/_layout/settings': {\n      preLoaderRoute: typeof LayoutSettingsImport\n      parentRoute: typeof LayoutImport\n    }\n    '/_layout/': {\n      preLoaderRoute: typeof LayoutIndexImport\n      parentRoute: typeof LayoutImport\n    }\n  }\n}\n\n// Create and export the route tree\n\nexport const routeTree = rootRoute.addChildren([\n  LayoutRoute.addChildren([\n    LayoutAdminRoute,\n    LayoutGotchaRoute,\n    LayoutItemsRoute,\n    LayoutSettingsRoute,\n    LayoutIndexRoute,\n  ]),\n  LoginRoute,\n  RecoverPasswordRoute,\n  ResetPasswordRoute,\n])\n\n/* prettier-ignore-end */\n</src/routeTree.gen.ts>\n\n<src/components/Items/AddItem.tsx>\nimport {\n  Button,\n  FormControl,\n  FormErrorMessage,\n  FormLabel,\n  Input,\n  Modal,\n  ModalBody,\n  ModalCloseButton,\n  ModalContent,\n  ModalFooter,\n  ModalHeader,\n  ModalOverlay,\n} from \"@chakra-ui/react\"\nimport { useMutation, useQueryClient } from \"@tanstack/react-query\"\nimport { type SubmitHandler, useForm } from \"react-hook-form\"\n\nimport { type ApiError, type ItemCreate, ItemsService } from \"../../client\"\nimport useCustomToast from \"../../hooks/useCustomToast\"\n\ninterface AddItemProps {\n  isOpen: boolean\n  onClose: () => void\n}\n\nconst AddItem = ({ isOpen, onClose }: AddItemProps) => {\n  const queryClient = useQueryClient()\n  const showToast = useCustomToast()\n  const {\n    register,\n    handleSubmit,\n    reset,\n    formState: { errors, isSubmitting },\n  } = useForm<ItemCreate>({\n    mode: \"onBlur\",\n    criteriaMode: \"all\",\n    defaultValues: {\n      title: \"\",\n      description: \"\",\n    },\n  })\n\n  const mutation = useMutation({\n    mutationFn: (data: ItemCreate) =>\n      ItemsService.createItem({ requestBody: data }),\n    onSuccess: () => {\n      showToast(\"Success!\", \"Item created successfully.\", \"success\")\n      reset()\n      onClose()\n    },\n    onError: (err: ApiError) => {\n      const errDetail = (err.body as any)?.detail\n      showToast(\"Something went wrong.\", `${errDetail}`, \"error\")\n    },\n    onSettled: () => {\n      queryClient.invalidateQueries({ queryKey: [\"items\"] })\n    },\n  })\n\n  const onSubmit: SubmitHandler<ItemCreate> = (data) => {\n    mutation.mutate(data)\n  }\n\n  return (\n    <>\n      <Modal\n        isOpen={isOpen}\n        onClose={onClose}\n        size={{ base: \"sm\", md: \"md\" }}\n        isCentered\n      >\n        <ModalOverlay />\n        <ModalContent as=\"form\" onSubmit={handleSubmit(onSubmit)}>\n          <ModalHeader>Add Item</ModalHeader>\n          <ModalCloseButton />\n          <ModalBody pb={6}>\n            <FormControl isRequired isInvalid={!!errors.title}>\n              <FormLabel htmlFor=\"title\">Title</FormLabel>\n              <Input\n                id=\"title\"\n                {...register(\"title\", {\n                  required: \"Title is required.\",\n                })}\n                placeholder=\"Title\"\n                type=\"text\"\n              />\n              {errors.title && (\n                <FormErrorMessage>{errors.title.message}</FormErrorMessage>\n              )}\n            </FormControl>\n            <FormControl mt={4}>\n              <FormLabel htmlFor=\"description\">Description</FormLabel>\n              <Input\n                id=\"description\"\n                {...register(\"description\")}\n                placeholder=\"Description\"\n                type=\"text\"\n              />\n            </FormControl>\n          </ModalBody>\n\n          <ModalFooter gap={3}>\n            <Button variant=\"primary\" type=\"submit\" isLoading={isSubmitting}>\n              Save\n            </Button>\n            <Button onClick={onClose}>Cancel</Button>\n          </ModalFooter>\n        </ModalContent>\n      </Modal>\n    </>\n  )\n}\n\nexport default AddItem\n</src/components/Items/AddItem.tsx>\n\n<src/components/Items/EditItem.tsx>\nimport {\n  Button,\n  FormControl,\n  FormErrorMessage,\n  FormLabel,\n  Input,\n  Modal,\n  ModalBody,\n  ModalCloseButton,\n  ModalContent,\n  ModalFooter,\n  ModalHeader,\n  ModalOverlay,\n} from \"@chakra-ui/react\"\nimport { useMutation, useQueryClient } from \"@tanstack/react-query\"\nimport { type SubmitHandler, useForm } from \"react-hook-form\"\n\nimport {\n  type ApiError,\n  type ItemPublic,\n  type ItemUpdate,\n  ItemsService,\n} from \"../../client\"\nimport useCustomToast from \"../../hooks/useCustomToast\"\n\ninterface EditItemProps {\n  item: ItemPublic\n  isOpen: boolean\n  onClose: () => void\n}\n\nconst EditItem = ({ item, isOpen, onClose }: EditItemProps) => {\n  const queryClient = useQueryClient()\n  const showToast = useCustomToast()\n  const {\n    register,\n    handleSubmit,\n    reset,\n    formState: { isSubmitting, errors, isDirty },\n  } = useForm<ItemUpdate>({\n    mode: \"onBlur\",\n    criteriaMode: \"all\",\n    defaultValues: item,\n  })\n\n  const mutation = useMutation({\n    mutationFn: (data: ItemUpdate) =>\n      ItemsService.updateItem({ id: item.id, requestBody: data }),\n    onSuccess: () => {\n      showToast(\"Success!\", \"Item updated successfully.\", \"success\")\n      onClose()\n    },\n    onError: (err: ApiError) => {\n      const errDetail = (err.body as any)?.detail\n      showToast(\"Something went wrong.\", `${errDetail}`, \"error\")\n    },\n    onSettled: () => {\n      queryClient.invalidateQueries({ queryKey: [\"items\"] })\n    },\n  })\n\n  const onSubmit: SubmitHandler<ItemUpdate> = async (data) => {\n    mutation.mutate(data)\n  }\n\n  const onCancel = () => {\n    reset()\n    onClose()\n  }\n\n  return (\n    <>\n      <Modal\n        isOpen={isOpen}\n        onClose={onClose}\n        size={{ base: \"sm\", md: \"md\" }}\n        isCentered\n      >\n        <ModalOverlay />\n        <ModalContent as=\"form\" onSubmit={handleSubmit(onSubmit)}>\n          <ModalHeader>Edit Item</ModalHeader>\n          <ModalCloseButton />\n          <ModalBody pb={6}>\n            <FormControl isInvalid={!!errors.title}>\n              <FormLabel htmlFor=\"title\">Title</FormLabel>\n              <Input\n                id=\"title\"\n                {...register(\"title\", {\n                  required: \"Title is required\",\n                })}\n                type=\"text\"\n              />\n              {errors.title && (\n                <FormErrorMessage>{errors.title.message}</FormErrorMessage>\n              )}\n            </FormControl>\n            <FormControl mt={4}>\n              <FormLabel htmlFor=\"description\">Description</FormLabel>\n              <Input\n                id=\"description\"\n                {...register(\"description\")}\n                placeholder=\"Description\"\n                type=\"text\"\n              />\n            </FormControl>\n          </ModalBody>\n          <ModalFooter gap={3}>\n            <Button\n              variant=\"primary\"\n              type=\"submit\"\n              isLoading={isSubmitting}\n              isDisabled={!isDirty}\n            >\n              Save\n            </Button>\n            <Button onClick={onCancel}>Cancel</Button>\n          </ModalFooter>\n        </ModalContent>\n      </Modal>\n    </>\n  )\n}\n\nexport default EditItem\n</src/components/Items/EditItem.tsx>\n\n<src/components/Common/SidebarItems.tsx>\nimport { Box, Flex, Icon, Text, useColorModeValue } from \"@chakra-ui/react\"\nimport { useQueryClient } from \"@tanstack/react-query\"\nimport { Link } from \"@tanstack/react-router\"\nimport { FiBriefcase, FiHome, FiSettings, FiUsers } from \"react-icons/fi\"\n\nimport type { UserPublic } from \"../../client\"\n\nconst items = [\n  { icon: FiHome, title: \"Dashboard\", path: \"/\" },\n  { icon: FiBriefcase, title: \"Items\", path: \"/items\" },\n  { icon: FiSettings, title: \"User Settings\", path: \"/settings\" },\n]\n\ninterface SidebarItemsProps {\n  onClose?: () => void\n}\n\nconst SidebarItems = ({ onClose }: SidebarItemsProps) => {\n  const queryClient = useQueryClient()\n  const textColor = useColorModeValue(\"ui.main\", \"ui.light\")\n  const bgActive = useColorModeValue(\"#E2E8F0\", \"#4A5568\")\n  const currentUser = queryClient.getQueryData<UserPublic>([\"currentUser\"])\n\n  const finalItems = currentUser?.is_superuser\n    ? [...items, { icon: FiUsers, title: \"Admin\", path: \"/admin\" }]\n    : items\n\n  const listItems = finalItems.map(({ icon, title, path }) => (\n    <Flex\n      as={Link}\n      to={path}\n      w=\"100%\"\n      p={2}\n      key={title}\n      activeProps={{\n        style: {\n          background: bgActive,\n          borderRadius: \"12px\",\n        },\n      }}\n      color={textColor}\n      onClick={onClose}\n    >\n      <Icon as={icon} alignSelf=\"center\" />\n      <Text ml={2}>{title}</Text>\n    </Flex>\n  ))\n\n  return (\n    <>\n      <Box>{listItems}</Box>\n    </>\n  )\n}\n\nexport default SidebarItems\n</src/components/Common/SidebarItems.tsx>\n\n<src/components/Common/NotFound.tsx>\nimport { Button, Container, Text } from \"@chakra-ui/react\"\nimport { Link } from \"@tanstack/react-router\"\n\nconst NotFound = () => {\n  return (\n    <>\n      <Container\n        h=\"100vh\"\n        alignItems=\"stretch\"\n        justifyContent=\"center\"\n        textAlign=\"center\"\n        maxW=\"sm\"\n        centerContent\n      >\n        <Text\n          fontSize=\"8xl\"\n          color=\"ui.main\"\n          fontWeight=\"bold\"\n          lineHeight=\"1\"\n          mb={4}\n        >\n          404\n        </Text>\n        <Text fontSize=\"md\">Oops!</Text>\n        <Text fontSize=\"md\">Page not found.</Text>\n        <Button\n          as={Link}\n          to=\"/\"\n          color=\"ui.main\"\n          borderColor=\"ui.main\"\n          variant=\"outline\"\n          mt={4}\n        >\n          Go back\n        </Button>\n      </Container>\n    </>\n  )\n}\n\nexport default NotFound\n</src/components/Common/NotFound.tsx>\n\n<src/components/Common/DeleteAlert.tsx>\nimport {\n  AlertDialog,\n  AlertDialogBody,\n  AlertDialogContent,\n  AlertDialogFooter,\n  AlertDialogHeader,\n  AlertDialogOverlay,\n  Button,\n} from \"@chakra-ui/react\"\nimport { useMutation, useQueryClient } from \"@tanstack/react-query\"\nimport React from \"react\"\nimport { useForm } from \"react-hook-form\"\n\nimport { ItemsService, UsersService } from \"../../client\"\nimport useCustomToast from \"../../hooks/useCustomToast\"\n\ninterface DeleteProps {\n  type: string\n  id: number\n  isOpen: boolean\n  onClose: () => void\n}\n\nconst Delete = ({ type, id, isOpen, onClose }: DeleteProps) => {\n  const queryClient = useQueryClient()\n  const showToast = useCustomToast()\n  const cancelRef = React.useRef<HTMLButtonElement | null>(null)\n  const {\n    handleSubmit,\n    formState: { isSubmitting },\n  } = useForm()\n\n  const deleteEntity = async (id: number) => {\n    if (type === \"Item\") {\n      await ItemsService.deleteItem({ id: id })\n    } else if (type === \"User\") {\n      await UsersService.deleteUser({ userId: id })\n    } else {\n      throw new Error(`Unexpected type: ${type}`)\n    }\n  }\n\n  const mutation = useMutation({\n    mutationFn: deleteEntity,\n    onSuccess: () => {\n      showToast(\n        \"Success\",\n        `The ${type.toLowerCase()} was deleted successfully.`,\n        \"success\",\n      )\n      onClose()\n    },\n    onError: () => {\n      showToast(\n        \"An error occurred.\",\n        `An error occurred while deleting the ${type.toLowerCase()}.`,\n        \"error\",\n      )\n    },\n    onSettled: () => {\n      queryClient.invalidateQueries({\n        queryKey: [type === \"Item\" ? \"items\" : \"users\"],\n      })\n    },\n  })\n\n  const onSubmit = async () => {\n    mutation.mutate(id)\n  }\n\n  return (\n    <>\n      <AlertDialog\n        isOpen={isOpen}\n        onClose={onClose}\n        leastDestructiveRef={cancelRef}\n        size={{ base: \"sm\", md: \"md\" }}\n        isCentered\n      >\n        <AlertDialogOverlay>\n          <AlertDialogContent as=\"form\" onSubmit={handleSubmit(onSubmit)}>\n            <AlertDialogHeader>Delete {type}</AlertDialogHeader>\n\n            <AlertDialogBody>\n              {type === \"User\" && (\n                <span>\n                  All items associated with this user will also be{\" \"}\n                  <strong>permantly deleted. </strong>\n                </span>\n              )}\n              Are you sure? You will not be able to undo this action.\n            </AlertDialogBody>\n\n            <AlertDialogFooter gap={3}>\n              <Button variant=\"danger\" type=\"submit\" isLoading={isSubmitting}>\n                Delete\n              </Button>\n              <Button\n                ref={cancelRef}\n                onClick={onClose}\n                isDisabled={isSubmitting}\n              >\n                Cancel\n              </Button>\n            </AlertDialogFooter>\n          </AlertDialogContent>\n        </AlertDialogOverlay>\n      </AlertDialog>\n    </>\n  )\n}\n\nexport default Delete\n</src/components/Common/DeleteAlert.tsx>\n\n<src/components/Common/Sidebar.tsx>\nimport {\n  Box,\n  Drawer,\n  DrawerBody,\n  DrawerCloseButton,\n  DrawerContent,\n  DrawerOverlay,\n  Flex,\n  IconButton,\n  Image,\n  Text,\n  useColorModeValue,\n  useDisclosure,\n} from \"@chakra-ui/react\"\nimport { useQueryClient } from \"@tanstack/react-query\"\nimport { FiLogOut, FiMenu } from \"react-icons/fi\"\n\nimport Logo from \"/assets/images/fastapi-logo.svg\"\nimport type { UserPublic } from \"../../client\"\nimport useAuth from \"../../hooks/useAuth\"\nimport SidebarItems from \"./SidebarItems\"\n\nconst Sidebar = () => {\n  const queryClient = useQueryClient()\n  const bgColor = useColorModeValue(\"ui.light\", \"ui.dark\")\n  const textColor = useColorModeValue(\"ui.dark\", \"ui.light\")\n  const secBgColor = useColorModeValue(\"ui.secondary\", \"ui.darkSlate\")\n  const currentUser = queryClient.getQueryData<UserPublic>([\"currentUser\"])\n  const { isOpen, onOpen, onClose } = useDisclosure()\n  const { logout } = useAuth()\n\n  const handleLogout = async () => {\n    logout()\n  }\n\n  return (\n    <>\n      {/* Mobile */}\n      <IconButton\n        onClick={onOpen}\n        display={{ base: \"flex\", md: \"none\" }}\n        aria-label=\"Open Menu\"\n        position=\"absolute\"\n        fontSize=\"20px\"\n        m={4}\n        icon={<FiMenu />}\n      />\n      <Drawer isOpen={isOpen} placement=\"left\" onClose={onClose}>\n        <DrawerOverlay />\n        <DrawerContent maxW=\"250px\">\n          <DrawerCloseButton />\n          <DrawerBody py={8}>\n            <Flex flexDir=\"column\" justify=\"space-between\">\n              <Box>\n                <Image src={Logo} alt=\"logo\" p={6} />\n                <SidebarItems onClose={onClose} />\n                <Flex\n                  as=\"button\"\n                  onClick={handleLogout}\n                  p={2}\n                  color=\"ui.danger\"\n                  fontWeight=\"bold\"\n                  alignItems=\"center\"\n                >\n                  <FiLogOut />\n                  <Text ml={2}>Log out</Text>\n                </Flex>\n              </Box>\n              {currentUser?.email && (\n                <Text color={textColor} noOfLines={2} fontSize=\"sm\" p={2}>\n                  Logged in as: {currentUser.email}\n                </Text>\n              )}\n            </Flex>\n          </DrawerBody>\n        </DrawerContent>\n      </Drawer>\n\n      {/* Desktop */}\n      <Box\n        bg={bgColor}\n        p={3}\n        h=\"100vh\"\n        position=\"sticky\"\n        top=\"0\"\n        display={{ base: \"none\", md: \"flex\" }}\n      >\n        <Flex\n          flexDir=\"column\"\n          justify=\"space-between\"\n          bg={secBgColor}\n          p={4}\n          borderRadius={12}\n        >\n          <Box>\n            <Image src={Logo} alt=\"Logo\" w=\"180px\" maxW=\"2xs\" p={6} />\n            <SidebarItems />\n          </Box>\n          {currentUser?.email && (\n            <Text\n              color={textColor}\n              noOfLines={2}\n              fontSize=\"sm\"\n              p={2}\n              maxW=\"180px\"\n            >\n              Logged in as: {currentUser.email}\n            </Text>\n          )}\n        </Flex>\n      </Box>\n    </>\n  )\n}\n\nexport default Sidebar\n</src/components/Common/Sidebar.tsx>\n\n<src/components/Common/UserMenu.tsx>\nimport {\n  Box,\n  IconButton,\n  Menu,\n  MenuButton,\n  MenuItem,\n  MenuList,\n} from \"@chakra-ui/react\"\nimport { Link } from \"@tanstack/react-router\"\nimport { FaUserAstronaut } from \"react-icons/fa\"\nimport { FiLogOut, FiUser } from \"react-icons/fi\"\n\nimport useAuth from \"../../hooks/useAuth\"\n\nconst UserMenu = () => {\n  const { logout } = useAuth()\n\n  const handleLogout = async () => {\n    logout()\n  }\n\n  return (\n    <>\n      {/* Desktop */}\n      <Box\n        display={{ base: \"none\", md: \"block\" }}\n        position=\"fixed\"\n        top={4}\n        right={4}\n      >\n        <Menu>\n          <MenuButton\n            as={IconButton}\n            aria-label=\"Options\"\n            icon={<FaUserAstronaut color=\"white\" fontSize=\"18px\" />}\n            bg=\"ui.main\"\n            isRound\n          />\n          <MenuList>\n            <MenuItem icon={<FiUser fontSize=\"18px\" />} as={Link} to=\"settings\">\n              My profile\n            </MenuItem>\n            <MenuItem\n              icon={<FiLogOut fontSize=\"18px\" />}\n              onClick={handleLogout}\n              color=\"ui.danger\"\n              fontWeight=\"bold\"\n            >\n              Log out\n            </MenuItem>\n          </MenuList>\n        </Menu>\n      </Box>\n    </>\n  )\n}\n\nexport default UserMenu\n</src/components/Common/UserMenu.tsx>\n\n<src/components/Common/ActionsMenu.tsx>\nimport {\n  Button,\n  Menu,\n  MenuButton,\n  MenuItem,\n  MenuList,\n  useDisclosure,\n} from \"@chakra-ui/react\"\nimport { BsThreeDotsVertical } from \"react-icons/bs\"\nimport { FiEdit, FiTrash } from \"react-icons/fi\"\n\nimport type { ItemPublic, UserPublic } from \"../../client\"\nimport EditUser from \"../Admin/EditUser\"\nimport EditItem from \"../Items/EditItem\"\nimport Delete from \"./DeleteAlert\"\n\ninterface ActionsMenuProps {\n  type: string\n  value: ItemPublic | UserPublic\n  disabled?: boolean\n}\n\nconst ActionsMenu = ({ type, value, disabled }: ActionsMenuProps) => {\n  const editUserModal = useDisclosure()\n  const deleteModal = useDisclosure()\n\n  return (\n    <>\n      <Menu>\n        <MenuButton\n          isDisabled={disabled}\n          as={Button}\n          rightIcon={<BsThreeDotsVertical />}\n          variant=\"unstyled\"\n        />\n        <MenuList>\n          <MenuItem\n            onClick={editUserModal.onOpen}\n            icon={<FiEdit fontSize=\"16px\" />}\n          >\n            Edit {type}\n          </MenuItem>\n          <MenuItem\n            onClick={deleteModal.onOpen}\n            icon={<FiTrash fontSize=\"16px\" />}\n            color=\"ui.danger\"\n          >\n            Delete {type}\n          </MenuItem>\n        </MenuList>\n        {type === \"User\" ? (\n          <EditUser\n            user={value as UserPublic}\n            isOpen={editUserModal.isOpen}\n            onClose={editUserModal.onClose}\n          />\n        ) : (\n          <EditItem\n            item={value as ItemPublic}\n            isOpen={editUserModal.isOpen}\n            onClose={editUserModal.onClose}\n          />\n        )}\n        <Delete\n          type={type}\n          id={value.id}\n          isOpen={deleteModal.isOpen}\n          onClose={deleteModal.onClose}\n        />\n      </Menu>\n    </>\n  )\n}\n\nexport default ActionsMenu\n</src/components/Common/ActionsMenu.tsx>\n\n<src/components/Common/Navbar.tsx>\nimport { Button, Flex, Icon, useDisclosure } from \"@chakra-ui/react\"\nimport { FaPlus } from \"react-icons/fa\"\n\nimport AddUser from \"../Admin/AddUser\"\nimport AddItem from \"../Items/AddItem\"\n\ninterface NavbarProps {\n  type: string\n}\n\nconst Navbar = ({ type }: NavbarProps) => {\n  const addUserModal = useDisclosure()\n  const addItemModal = useDisclosure()\n\n  return (\n    <>\n      <Flex py={8} gap={4}>\n        {/* TODO: Complete search functionality */}\n        {/* <InputGroup w={{ base: '100%', md: 'auto' }}>\n                    <InputLeftElement pointerEvents='none'>\n                        <Icon as={FaSearch} color='ui.dim' />\n                    </InputLeftElement>\n                    <Input type='text' placeholder='Search' fontSize={{ base: 'sm', md: 'inherit' }} borderRadius='8px' />\n                </InputGroup> */}\n        <Button\n          variant=\"primary\"\n          gap={1}\n          fontSize={{ base: \"sm\", md: \"inherit\" }}\n          onClick={type === \"User\" ? addUserModal.onOpen : addItemModal.onOpen}\n        >\n          <Icon as={FaPlus} /> Add {type}\n        </Button>\n        <AddUser isOpen={addUserModal.isOpen} onClose={addUserModal.onClose} />\n        <AddItem isOpen={addItemModal.isOpen} onClose={addItemModal.onClose} />\n      </Flex>\n    </>\n  )\n}\n\nexport default Navbar\n</src/components/Common/Navbar.tsx>\n\n<src/components/Admin/EditUser.tsx>\nimport {\n  Button,\n  Checkbox,\n  Flex,\n  FormControl,\n  FormErrorMessage,\n  FormLabel,\n  Input,\n  Modal,\n  ModalBody,\n  ModalCloseButton,\n  ModalContent,\n  ModalFooter,\n  ModalHeader,\n  ModalOverlay,\n} from \"@chakra-ui/react\"\nimport { useMutation, useQueryClient } from \"@tanstack/react-query\"\nimport { type SubmitHandler, useForm } from \"react-hook-form\"\n\nimport {\n  type ApiError,\n  type UserPublic,\n  type UserUpdate,\n  UsersService,\n} from \"../../client\"\nimport useCustomToast from \"../../hooks/useCustomToast\"\nimport { emailPattern } from \"../../utils\"\n\ninterface EditUserProps {\n  user: UserPublic\n  isOpen: boolean\n  onClose: () => void\n}\n\ninterface UserUpdateForm extends UserUpdate {\n  confirm_password: string\n}\n\nconst EditUser = ({ user, isOpen, onClose }: EditUserProps) => {\n  const queryClient = useQueryClient()\n  const showToast = useCustomToast()\n\n  const {\n    register,\n    handleSubmit,\n    reset,\n    getValues,\n    formState: { errors, isSubmitting, isDirty },\n  } = useForm<UserUpdateForm>({\n    mode: \"onBlur\",\n    criteriaMode: \"all\",\n    defaultValues: user,\n  })\n\n  const mutation = useMutation({\n    mutationFn: (data: UserUpdateForm) =>\n      UsersService.updateUser({ userId: user.id, requestBody: data }),\n    onSuccess: () => {\n      showToast(\"Success!\", \"User updated successfully.\", \"success\")\n      onClose()\n    },\n    onError: (err: ApiError) => {\n      const errDetail = (err.body as any)?.detail\n      showToast(\"Something went wrong.\", `${errDetail}`, \"error\")\n    },\n    onSettled: () => {\n      queryClient.invalidateQueries({ queryKey: [\"users\"] })\n    },\n  })\n\n  const onSubmit: SubmitHandler<UserUpdateForm> = async (data) => {\n    if (data.password === \"\") {\n      data.password = undefined\n    }\n    mutation.mutate(data)\n  }\n\n  const onCancel = () => {\n    reset()\n    onClose()\n  }\n\n  return (\n    <>\n      <Modal\n        isOpen={isOpen}\n        onClose={onClose}\n        size={{ base: \"sm\", md: \"md\" }}\n        isCentered\n      >\n        <ModalOverlay />\n        <ModalContent as=\"form\" onSubmit={handleSubmit(onSubmit)}>\n          <ModalHeader>Edit User</ModalHeader>\n          <ModalCloseButton />\n          <ModalBody pb={6}>\n            <FormControl isInvalid={!!errors.email}>\n              <FormLabel htmlFor=\"email\">Email</FormLabel>\n              <Input\n                id=\"email\"\n                {...register(\"email\", {\n                  required: \"Email is required\",\n                  pattern: emailPattern,\n                })}\n                placeholder=\"Email\"\n                type=\"email\"\n              />\n              {errors.email && (\n                <FormErrorMessage>{errors.email.message}</FormErrorMessage>\n              )}\n            </FormControl>\n            <FormControl mt={4}>\n              <FormLabel htmlFor=\"name\">Full name</FormLabel>\n              <Input id=\"name\" {...register(\"full_name\")} type=\"text\" />\n            </FormControl>\n            <FormControl mt={4} isInvalid={!!errors.password}>\n              <FormLabel htmlFor=\"password\">Set Password</FormLabel>\n              <Input\n                id=\"password\"\n                {...register(\"password\", {\n                  minLength: {\n                    value: 8,\n                    message: \"Password must be at least 8 characters\",\n                  },\n                })}\n                placeholder=\"Password\"\n                type=\"password\"\n              />\n              {errors.password && (\n                <FormErrorMessage>{errors.password.message}</FormErrorMessage>\n              )}\n            </FormControl>\n            <FormControl mt={4} isInvalid={!!errors.confirm_password}>\n              <FormLabel htmlFor=\"confirm_password\">Confirm Password</FormLabel>\n              <Input\n                id=\"confirm_password\"\n                {...register(\"confirm_password\", {\n                  validate: (value) =>\n                    value === getValues().password ||\n                    \"The passwords do not match\",\n                })}\n                placeholder=\"Password\"\n                type=\"password\"\n              />\n              {errors.confirm_password && (\n                <FormErrorMessage>\n                  {errors.confirm_password.message}\n                </FormErrorMessage>\n              )}\n            </FormControl>\n            <Flex>\n              <FormControl mt={4}>\n                <Checkbox {...register(\"is_superuser\")} colorScheme=\"teal\">\n                  Is superuser?\n                </Checkbox>\n              </FormControl>\n              <FormControl mt={4}>\n                <Checkbox {...register(\"is_active\")} colorScheme=\"teal\">\n                  Is active?\n                </Checkbox>\n              </FormControl>\n            </Flex>\n          </ModalBody>\n\n          <ModalFooter gap={3}>\n            <Button\n              variant=\"primary\"\n              type=\"submit\"\n              isLoading={isSubmitting}\n              isDisabled={!isDirty}\n            >\n              Save\n            </Button>\n            <Button onClick={onCancel}>Cancel</Button>\n          </ModalFooter>\n        </ModalContent>\n      </Modal>\n    </>\n  )\n}\n\nexport default EditUser\n</src/components/Admin/EditUser.tsx>\n\n<src/components/Admin/AddUser.tsx>\nimport {\n  Button,\n  Checkbox,\n  Flex,\n  FormControl,\n  FormErrorMessage,\n  FormLabel,\n  Input,\n  Modal,\n  ModalBody,\n  ModalCloseButton,\n  ModalContent,\n  ModalFooter,\n  ModalHeader,\n  ModalOverlay,\n} from \"@chakra-ui/react\"\nimport { useMutation, useQueryClient } from \"@tanstack/react-query\"\nimport { type SubmitHandler, useForm } from \"react-hook-form\"\n\nimport { type UserCreate, UsersService } from \"../../client\"\nimport type { ApiError } from \"../../client/core/ApiError\"\nimport useCustomToast from \"../../hooks/useCustomToast\"\nimport { emailPattern } from \"../../utils\"\n\ninterface AddUserProps {\n  isOpen: boolean\n  onClose: () => void\n}\n\ninterface UserCreateForm extends UserCreate {\n  confirm_password: string\n}\n\nconst AddUser = ({ isOpen, onClose }: AddUserProps) => {\n  const queryClient = useQueryClient()\n  const showToast = useCustomToast()\n  const {\n    register,\n    handleSubmit,\n    reset,\n    getValues,\n    formState: { errors, isSubmitting },\n  } = useForm<UserCreateForm>({\n    mode: \"onBlur\",\n    criteriaMode: \"all\",\n    defaultValues: {\n      email: \"\",\n      full_name: \"\",\n      password: \"\",\n      confirm_password: \"\",\n      is_superuser: false,\n      is_active: false,\n    },\n  })\n\n  const mutation = useMutation({\n    mutationFn: (data: UserCreate) =>\n      UsersService.createUser({ requestBody: data }),\n    onSuccess: () => {\n      showToast(\"Success!\", \"User created successfully.\", \"success\")\n      reset()\n      onClose()\n    },\n    onError: (err: ApiError) => {\n      const errDetail = (err.body as any)?.detail\n      showToast(\"Something went wrong.\", `${errDetail}`, \"error\")\n    },\n    onSettled: () => {\n      queryClient.invalidateQueries({ queryKey: [\"users\"] })\n    },\n  })\n\n  const onSubmit: SubmitHandler<UserCreateForm> = (data) => {\n    mutation.mutate(data)\n  }\n\n  return (\n    <>\n      <Modal\n        isOpen={isOpen}\n        onClose={onClose}\n        size={{ base: \"sm\", md: \"md\" }}\n        isCentered\n      >\n        <ModalOverlay />\n        <ModalContent as=\"form\" onSubmit={handleSubmit(onSubmit)}>\n          <ModalHeader>Add User</ModalHeader>\n          <ModalCloseButton />\n          <ModalBody pb={6}>\n            <FormControl isRequired isInvalid={!!errors.email}>\n              <FormLabel htmlFor=\"email\">Email</FormLabel>\n              <Input\n                id=\"email\"\n                {...register(\"email\", {\n                  required: \"Email is required\",\n                  pattern: emailPattern,\n                })}\n                placeholder=\"Email\"\n                type=\"email\"\n              />\n              {errors.email && (\n                <FormErrorMessage>{errors.email.message}</FormErrorMessage>\n              )}\n            </FormControl>\n            <FormControl mt={4} isInvalid={!!errors.full_name}>\n              <FormLabel htmlFor=\"name\">Full name</FormLabel>\n              <Input\n                id=\"name\"\n                {...register(\"full_name\")}\n                placeholder=\"Full name\"\n                type=\"text\"\n              />\n              {errors.full_name && (\n                <FormErrorMessage>{errors.full_name.message}</FormErrorMessage>\n              )}\n            </FormControl>\n            <FormControl mt={4} isRequired isInvalid={!!errors.password}>\n              <FormLabel htmlFor=\"password\">Set Password</FormLabel>\n              <Input\n                id=\"password\"\n                {...register(\"password\", {\n                  required: \"Password is required\",\n                  minLength: {\n                    value: 8,\n                    message: \"Password must be at least 8 characters\",\n                  },\n                })}\n                placeholder=\"Password\"\n                type=\"password\"\n              />\n              {errors.password && (\n                <FormErrorMessage>{errors.password.message}</FormErrorMessage>\n              )}\n            </FormControl>\n            <FormControl\n              mt={4}\n              isRequired\n              isInvalid={!!errors.confirm_password}\n            >\n              <FormLabel htmlFor=\"confirm_password\">Confirm Password</FormLabel>\n              <Input\n                id=\"confirm_password\"\n                {...register(\"confirm_password\", {\n                  required: \"Please confirm your password\",\n                  validate: (value) =>\n                    value === getValues().password ||\n                    \"The passwords do not match\",\n                })}\n                placeholder=\"Password\"\n                type=\"password\"\n              />\n              {errors.confirm_password && (\n                <FormErrorMessage>\n                  {errors.confirm_password.message}\n                </FormErrorMessage>\n              )}\n            </FormControl>\n            <Flex mt={4}>\n              <FormControl>\n                <Checkbox {...register(\"is_superuser\")} colorScheme=\"teal\">\n                  Is superuser?\n                </Checkbox>\n              </FormControl>\n              <FormControl>\n                <Checkbox {...register(\"is_active\")} colorScheme=\"teal\">\n                  Is active?\n                </Checkbox>\n              </FormControl>\n            </Flex>\n          </ModalBody>\n          <ModalFooter gap={3}>\n            <Button variant=\"primary\" type=\"submit\" isLoading={isSubmitting}>\n              Save\n            </Button>\n            <Button onClick={onClose}>Cancel</Button>\n          </ModalFooter>\n        </ModalContent>\n      </Modal>\n    </>\n  )\n}\n\nexport default AddUser\n</src/components/Admin/AddUser.tsx>\n\n<src/components/UserSettings/ChangePassword.tsx>\nimport {\n  Box,\n  Button,\n  Container,\n  FormControl,\n  FormErrorMessage,\n  FormLabel,\n  Heading,\n  Input,\n  useColorModeValue,\n} from \"@chakra-ui/react\"\nimport { useMutation } from \"@tanstack/react-query\"\nimport { type SubmitHandler, useForm } from \"react-hook-form\"\n\nimport { type ApiError, type UpdatePassword, UsersService } from \"../../client\"\nimport useCustomToast from \"../../hooks/useCustomToast\"\nimport { confirmPasswordRules, passwordRules } from \"../../utils\"\n\ninterface UpdatePasswordForm extends UpdatePassword {\n  confirm_password: string\n}\n\nconst ChangePassword = () => {\n  const color = useColorModeValue(\"inherit\", \"ui.light\")\n  const showToast = useCustomToast()\n  const {\n    register,\n    handleSubmit,\n    reset,\n    getValues,\n    formState: { errors, isSubmitting },\n  } = useForm<UpdatePasswordForm>({\n    mode: \"onBlur\",\n    criteriaMode: \"all\",\n  })\n\n  const mutation = useMutation({\n    mutationFn: (data: UpdatePassword) =>\n      UsersService.updatePasswordMe({ requestBody: data }),\n    onSuccess: () => {\n      showToast(\"Success!\", \"Password updated.\", \"success\")\n      reset()\n    },\n    onError: (err: ApiError) => {\n      const errDetail = (err.body as any)?.detail\n      showToast(\"Something went wrong.\", `${errDetail}`, \"error\")\n    },\n  })\n\n  const onSubmit: SubmitHandler<UpdatePasswordForm> = async (data) => {\n    mutation.mutate(data)\n  }\n\n  return (\n    <>\n      <Container maxW=\"full\">\n        <Heading size=\"sm\" py={4}>\n          Change Password\n        </Heading>\n        <Box\n          w={{ sm: \"full\", md: \"50%\" }}\n          as=\"form\"\n          onSubmit={handleSubmit(onSubmit)}\n        >\n          <FormControl isRequired isInvalid={!!errors.current_password}>\n            <FormLabel color={color} htmlFor=\"current_password\">\n              Current Password\n            </FormLabel>\n            <Input\n              id=\"current_password\"\n              {...register(\"current_password\")}\n              placeholder=\"Password\"\n              type=\"password\"\n            />\n            {errors.current_password && (\n              <FormErrorMessage>\n                {errors.current_password.message}\n              </FormErrorMessage>\n            )}\n          </FormControl>\n          <FormControl mt={4} isRequired isInvalid={!!errors.new_password}>\n            <FormLabel htmlFor=\"password\">Set Password</FormLabel>\n            <Input\n              id=\"password\"\n              {...register(\"new_password\", passwordRules())}\n              placeholder=\"Password\"\n              type=\"password\"\n            />\n            {errors.new_password && (\n              <FormErrorMessage>{errors.new_password.message}</FormErrorMessage>\n            )}\n          </FormControl>\n          <FormControl mt={4} isRequired isInvalid={!!errors.confirm_password}>\n            <FormLabel htmlFor=\"confirm_password\">Confirm Password</FormLabel>\n            <Input\n              id=\"confirm_password\"\n              {...register(\"confirm_password\", confirmPasswordRules(getValues))}\n              placeholder=\"Password\"\n              type=\"password\"\n            />\n            {errors.confirm_password && (\n              <FormErrorMessage>\n                {errors.confirm_password.message}\n              </FormErrorMessage>\n            )}\n          </FormControl>\n          <Button\n            variant=\"primary\"\n            mt={4}\n            type=\"submit\"\n            isLoading={isSubmitting}\n          >\n            Save\n          </Button>\n        </Box>\n      </Container>\n    </>\n  )\n}\nexport default ChangePassword\n</src/components/UserSettings/ChangePassword.tsx>\n\n<src/components/UserSettings/DeleteAccount.tsx>\nimport {\n  Button,\n  Container,\n  Heading,\n  Text,\n  useDisclosure,\n} from \"@chakra-ui/react\"\n\nimport DeleteConfirmation from \"./DeleteConfirmation\"\n\nconst DeleteAccount = () => {\n  const confirmationModal = useDisclosure()\n\n  return (\n    <>\n      <Container maxW=\"full\">\n        <Heading size=\"sm\" py={4}>\n          Delete Account\n        </Heading>\n        <Text>\n          Permanently delete your data and everything associated with your\n          account.\n        </Text>\n        <Button variant=\"danger\" mt={4} onClick={confirmationModal.onOpen}>\n          Delete\n        </Button>\n        <DeleteConfirmation\n          isOpen={confirmationModal.isOpen}\n          onClose={confirmationModal.onClose}\n        />\n      </Container>\n    </>\n  )\n}\nexport default DeleteAccount\n</src/components/UserSettings/DeleteAccount.tsx>\n\n<src/components/UserSettings/Appearance.tsx>\nimport {\n  Badge,\n  Container,\n  Heading,\n  Radio,\n  RadioGroup,\n  Stack,\n  useColorMode,\n} from \"@chakra-ui/react\"\n\nconst Appearance = () => {\n  const { colorMode, toggleColorMode } = useColorMode()\n\n  return (\n    <>\n      <Container maxW=\"full\">\n        <Heading size=\"sm\" py={4}>\n          Appearance\n        </Heading>\n        <RadioGroup onChange={toggleColorMode} value={colorMode}>\n          <Stack>\n            {/* TODO: Add system default option */}\n            <Radio value=\"light\" colorScheme=\"teal\">\n              Light Mode\n              <Badge ml=\"1\" colorScheme=\"teal\">\n                Default\n              </Badge>\n            </Radio>\n            <Radio value=\"dark\" colorScheme=\"teal\">\n              Dark Mode\n            </Radio>\n          </Stack>\n        </RadioGroup>\n      </Container>\n    </>\n  )\n}\nexport default Appearance\n</src/components/UserSettings/Appearance.tsx>\n\n<src/components/UserSettings/DeleteConfirmation.tsx>\nimport {\n  AlertDialog,\n  AlertDialogBody,\n  AlertDialogContent,\n  AlertDialogFooter,\n  AlertDialogHeader,\n  AlertDialogOverlay,\n  Button,\n} from \"@chakra-ui/react\"\nimport { useMutation, useQueryClient } from \"@tanstack/react-query\"\nimport React from \"react\"\nimport { useForm } from \"react-hook-form\"\n\nimport { type ApiError, type UserPublic, UsersService } from \"../../client\"\nimport useAuth from \"../../hooks/useAuth\"\nimport useCustomToast from \"../../hooks/useCustomToast\"\n\ninterface DeleteProps {\n  isOpen: boolean\n  onClose: () => void\n}\n\nconst DeleteConfirmation = ({ isOpen, onClose }: DeleteProps) => {\n  const queryClient = useQueryClient()\n  const showToast = useCustomToast()\n  const cancelRef = React.useRef<HTMLButtonElement | null>(null)\n  const {\n    handleSubmit,\n    formState: { isSubmitting },\n  } = useForm()\n  const currentUser = queryClient.getQueryData<UserPublic>([\"currentUser\"])\n  const { logout } = useAuth()\n\n  const mutation = useMutation({\n    mutationFn: (id: number) => UsersService.deleteUser({ userId: id }),\n    onSuccess: () => {\n      showToast(\n        \"Success\",\n        \"Your account has been successfully deleted.\",\n        \"success\",\n      )\n      logout()\n      onClose()\n    },\n    onError: (err: ApiError) => {\n      const errDetail = (err.body as any)?.detail\n      showToast(\"Something went wrong.\", `${errDetail}`, \"error\")\n    },\n    onSettled: () => {\n      queryClient.invalidateQueries({ queryKey: [\"currentUser\"] })\n    },\n  })\n\n  const onSubmit = async () => {\n    mutation.mutate(currentUser!.id)\n  }\n\n  return (\n    <>\n      <AlertDialog\n        isOpen={isOpen}\n        onClose={onClose}\n        leastDestructiveRef={cancelRef}\n        size={{ base: \"sm\", md: \"md\" }}\n        isCentered\n      >\n        <AlertDialogOverlay>\n          <AlertDialogContent as=\"form\" onSubmit={handleSubmit(onSubmit)}>\n            <AlertDialogHeader>Confirmation Required</AlertDialogHeader>\n\n            <AlertDialogBody>\n              All your account data will be{\" \"}\n              <strong>permanently deleted.</strong> If you are sure, please\n              click <strong>\"Confirm\"</strong> to proceed. This action cannot be\n              undone.\n            </AlertDialogBody>\n\n            <AlertDialogFooter gap={3}>\n              <Button variant=\"danger\" type=\"submit\" isLoading={isSubmitting}>\n                Confirm\n              </Button>\n              <Button\n                ref={cancelRef}\n                onClick={onClose}\n                isDisabled={isSubmitting}\n              >\n                Cancel\n              </Button>\n            </AlertDialogFooter>\n          </AlertDialogContent>\n        </AlertDialogOverlay>\n      </AlertDialog>\n    </>\n  )\n}\n\nexport default DeleteConfirmation\n</src/components/UserSettings/DeleteConfirmation.tsx>\n\n<src/components/UserSettings/UserInformation.tsx>\nimport {\n  Box,\n  Button,\n  Container,\n  Flex,\n  FormControl,\n  FormErrorMessage,\n  FormLabel,\n  Heading,\n  Input,\n  Text,\n  useColorModeValue,\n} from \"@chakra-ui/react\"\nimport { useMutation, useQueryClient } from \"@tanstack/react-query\"\nimport { useState } from \"react\"\nimport { type SubmitHandler, useForm } from \"react-hook-form\"\n\nimport {\n  type ApiError,\n  type UserPublic,\n  type UserUpdateMe,\n  UsersService,\n} from \"../../client\"\nimport useAuth from \"../../hooks/useAuth\"\nimport useCustomToast from \"../../hooks/useCustomToast\"\nimport { emailPattern } from \"../../utils\"\n\nconst UserInformation = () => {\n  const queryClient = useQueryClient()\n  const color = useColorModeValue(\"inherit\", \"ui.light\")\n  const showToast = useCustomToast()\n  const [editMode, setEditMode] = useState(false)\n  const { user: currentUser } = useAuth()\n  const {\n    register,\n    handleSubmit,\n    reset,\n    getValues,\n    formState: { isSubmitting, errors, isDirty },\n  } = useForm<UserPublic>({\n    mode: \"onBlur\",\n    criteriaMode: \"all\",\n    defaultValues: {\n      full_name: currentUser?.full_name,\n      email: currentUser?.email,\n    },\n  })\n\n  const toggleEditMode = () => {\n    setEditMode(!editMode)\n  }\n\n  const mutation = useMutation({\n    mutationFn: (data: UserUpdateMe) =>\n      UsersService.updateUserMe({ requestBody: data }),\n    onSuccess: () => {\n      showToast(\"Success!\", \"User updated successfully.\", \"success\")\n    },\n    onError: (err: ApiError) => {\n      const errDetail = (err.body as any)?.detail\n      showToast(\"Something went wrong.\", `${errDetail}`, \"error\")\n    },\n    onSettled: () => {\n      // TODO: can we do just one call now?\n      queryClient.invalidateQueries({ queryKey: [\"users\"] })\n      queryClient.invalidateQueries({ queryKey: [\"currentUser\"] })\n    },\n  })\n\n  const onSubmit: SubmitHandler<UserUpdateMe> = async (data) => {\n    mutation.mutate(data)\n  }\n\n  const onCancel = () => {\n    reset()\n    toggleEditMode()\n  }\n\n  return (\n    <>\n      <Container maxW=\"full\">\n        <Heading size=\"sm\" py={4}>\n          User Information\n        </Heading>\n        <Box\n          w={{ sm: \"full\", md: \"50%\" }}\n          as=\"form\"\n          onSubmit={handleSubmit(onSubmit)}\n        >\n          <FormControl>\n            <FormLabel color={color} htmlFor=\"name\">\n              Full name\n            </FormLabel>\n            {editMode ? (\n              <Input\n                id=\"name\"\n                {...register(\"full_name\", { maxLength: 30 })}\n                type=\"text\"\n                size=\"md\"\n              />\n            ) : (\n              <Text\n                size=\"md\"\n                py={2}\n                color={!currentUser?.full_name ? \"ui.dim\" : \"inherit\"}\n              >\n                {currentUser?.full_name || \"N/A\"}\n              </Text>\n            )}\n          </FormControl>\n          <FormControl mt={4} isInvalid={!!errors.email}>\n            <FormLabel color={color} htmlFor=\"email\">\n              Email\n            </FormLabel>\n            {editMode ? (\n              <Input\n                id=\"email\"\n                {...register(\"email\", {\n                  required: \"Email is required\",\n                  pattern: emailPattern,\n                })}\n                type=\"email\"\n                size=\"md\"\n              />\n            ) : (\n              <Text size=\"md\" py={2}>\n                {currentUser?.email}\n              </Text>\n            )}\n            {errors.email && (\n              <FormErrorMessage>{errors.email.message}</FormErrorMessage>\n            )}\n          </FormControl>\n          <Flex mt={4} gap={3}>\n            <Button\n              variant=\"primary\"\n              onClick={toggleEditMode}\n              type={editMode ? \"button\" : \"submit\"}\n              isLoading={editMode ? isSubmitting : false}\n              isDisabled={editMode ? !isDirty || !getValues(\"email\") : false}\n            >\n              {editMode ? \"Save\" : \"Edit\"}\n            </Button>\n            {editMode && (\n              <Button onClick={onCancel} isDisabled={isSubmitting}>\n                Cancel\n              </Button>\n            )}\n          </Flex>\n        </Box>\n      </Container>\n    </>\n  )\n}\n\nexport default UserInformation\n</src/components/UserSettings/UserInformation.tsx>\n\n<src/components/Gotcha/VerifyCameraStream.tsx>\nimport React, { useState, useRef, useEffect } from 'react';\nimport Webcam from 'react-webcam';\nimport axios from 'axios';\n\nconst VideoStreamer: React.FC = () => {\n    const webcamRef = useRef<Webcam>(null);\n    const [messages, setMessages] = useState<string[]>([]);\n    const [verificationRequestId, setVerificationRequestId] = useState<number | null>(null);\n    const ws = useRef<WebSocket | null>(null);\n\n    useEffect(() => {\n        if (verificationRequestId && !ws.current) {\n            ws.current = new WebSocket(`ws://localhost:8000/api/ws/${verificationRequestId}`);\n            ws.current.onmessage = (event) => {\n                setMessages(prev => [...prev, event.data]);\n            };\n            ws.current.onclose = () => console.log('WebSocket closed');\n            ws.current.onerror = (error) => console.log('WebSocket error:', error);\n        }\n\n        return () => {\n            ws.current?.close();\n        };\n    }, [verificationRequestId]);\n\n    const handleStart = async () => {\n        const videoBlob = webcamRef.current?.getScreenshot();\n        if (videoBlob) {\n            try {\n                const response = await axios.post('http://localhost:8000/api/video/{verification_request_id}', videoBlob, {\n                    headers: {\n                        'Content-Type': 'application/octet-stream',\n                    },\n                });\n                setVerificationRequestId(response.data.id);\n            } catch (error) {\n                console.error('Error sending video:', error);\n            }\n        }\n    };\n\n    return (\n        <div>\n            <Webcam\n                audio={false}\n                ref={webcamRef}\n                screenshotFormat=\"image/jpeg\"\n            />\n            <button onClick={handleStart}>Start Verification</button>\n            <div>\n                {messages.map((msg, index) => (\n                    <div key={index}>{msg}</div>\n                ))}\n            </div>\n        </div>\n    );\n};\n\nexport default VideoStreamer;</src/components/Gotcha/VerifyCameraStream.tsx>\n\n<src/main.tsx>\nimport { ChakraProvider } from \"@chakra-ui/react\"\nimport { QueryClient, QueryClientProvider } from \"@tanstack/react-query\"\nimport { RouterProvider, createRouter } from \"@tanstack/react-router\"\nimport ReactDOM from \"react-dom/client\"\nimport { routeTree } from \"./routeTree.gen\"\n\nimport { StrictMode } from \"react\"\nimport { OpenAPI } from \"./client\"\nimport theme from \"./theme\"\n\nOpenAPI.BASE = import.meta.env.VITE_API_URL\nOpenAPI.TOKEN = async () => {\n  return localStorage.getItem(\"access_token\") || \"\"\n}\n\nconst queryClient = new QueryClient()\n\nconst router = createRouter({ routeTree })\ndeclare module \"@tanstack/react-router\" {\n  interface Register {\n    router: typeof router\n  }\n}\n\nReactDOM.createRoot(document.getElementById(\"root\")!).render(\n  <StrictMode>\n    <ChakraProvider theme={theme}>\n      <QueryClientProvider client={queryClient}>\n        <RouterProvider router={router} />\n      </QueryClientProvider>\n    </ChakraProvider>\n  </StrictMode>,\n)\n</src/main.tsx>\n\n<src/theme.tsx>\nimport { extendTheme } from \"@chakra-ui/react\"\n\nconst disabledStyles = {\n  _disabled: {\n    backgroundColor: \"ui.main\",\n  },\n}\n\nconst theme = extendTheme({\n  colors: {\n    ui: {\n      main: \"#009688\",\n      secondary: \"#EDF2F7\",\n      success: \"#48BB78\",\n      danger: \"#E53E3E\",\n      light: \"#FAFAFA\",\n      dark: \"#1A202C\",\n      darkSlate: \"#252D3D\",\n      dim: \"#A0AEC0\",\n    },\n  },\n  components: {\n    Button: {\n      variants: {\n        primary: {\n          backgroundColor: \"ui.main\",\n          color: \"ui.light\",\n          _hover: {\n            backgroundColor: \"#00766C\",\n          },\n          _disabled: {\n            ...disabledStyles,\n            _hover: {\n              ...disabledStyles,\n            },\n          },\n        },\n        danger: {\n          backgroundColor: \"ui.danger\",\n          color: \"ui.light\",\n          _hover: {\n            backgroundColor: \"#E32727\",\n          },\n        },\n      },\n    },\n    Tabs: {\n      variants: {\n        enclosed: {\n          tab: {\n            _selected: {\n              color: \"ui.main\",\n            },\n          },\n        },\n      },\n    },\n  },\n})\n\nexport default theme\n</src/theme.tsx>\n\n<src/client/core/ApiRequestOptions.ts>\nexport type ApiRequestOptions = {\n\treadonly method: 'GET' | 'PUT' | 'POST' | 'DELETE' | 'OPTIONS' | 'HEAD' | 'PATCH';\n\treadonly url: string;\n\treadonly path?: Record<string, unknown>;\n\treadonly cookies?: Record<string, unknown>;\n\treadonly headers?: Record<string, unknown>;\n\treadonly query?: Record<string, unknown>;\n\treadonly formData?: Record<string, unknown>;\n\treadonly body?: any;\n\treadonly mediaType?: string;\n\treadonly responseHeader?: string;\n\treadonly errors?: Record<number, string>;\n};</src/client/core/ApiRequestOptions.ts>\n\n<src/client/core/ApiError.ts>\nimport type { ApiRequestOptions } from './ApiRequestOptions';\nimport type { ApiResult } from './ApiResult';\n\nexport class ApiError extends Error {\n\tpublic readonly url: string;\n\tpublic readonly status: number;\n\tpublic readonly statusText: string;\n\tpublic readonly body: unknown;\n\tpublic readonly request: ApiRequestOptions;\n\n\tconstructor(request: ApiRequestOptions, response: ApiResult, message: string) {\n\t\tsuper(message);\n\n\t\tthis.name = 'ApiError';\n\t\tthis.url = response.url;\n\t\tthis.status = response.status;\n\t\tthis.statusText = response.statusText;\n\t\tthis.body = response.body;\n\t\tthis.request = request;\n\t}\n}</src/client/core/ApiError.ts>\n\n<src/client/core/CancelablePromise.ts>\nexport class CancelError extends Error {\n\tconstructor(message: string) {\n\t\tsuper(message);\n\t\tthis.name = 'CancelError';\n\t}\n\n\tpublic get isCancelled(): boolean {\n\t\treturn true;\n\t}\n}\n\nexport interface OnCancel {\n\treadonly isResolved: boolean;\n\treadonly isRejected: boolean;\n\treadonly isCancelled: boolean;\n\n\t(cancelHandler: () => void): void;\n}\n\nexport class CancelablePromise<T> implements Promise<T> {\n\tprivate _isResolved: boolean;\n\tprivate _isRejected: boolean;\n\tprivate _isCancelled: boolean;\n\treadonly cancelHandlers: (() => void)[];\n\treadonly promise: Promise<T>;\n\tprivate _resolve?: (value: T | PromiseLike<T>) => void;\n\tprivate _reject?: (reason?: unknown) => void;\n\n\tconstructor(\n\t\texecutor: (\n\t\t\tresolve: (value: T | PromiseLike<T>) => void,\n\t\t\treject: (reason?: unknown) => void,\n\t\t\tonCancel: OnCancel\n\t\t) => void\n\t) {\n\t\tthis._isResolved = false;\n\t\tthis._isRejected = false;\n\t\tthis._isCancelled = false;\n\t\tthis.cancelHandlers = [];\n\t\tthis.promise = new Promise<T>((resolve, reject) => {\n\t\t\tthis._resolve = resolve;\n\t\t\tthis._reject = reject;\n\n\t\t\tconst onResolve = (value: T | PromiseLike<T>): void => {\n\t\t\t\tif (this._isResolved || this._isRejected || this._isCancelled) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tthis._isResolved = true;\n\t\t\t\tif (this._resolve) this._resolve(value);\n\t\t\t};\n\n\t\t\tconst onReject = (reason?: unknown): void => {\n\t\t\t\tif (this._isResolved || this._isRejected || this._isCancelled) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tthis._isRejected = true;\n\t\t\t\tif (this._reject) this._reject(reason);\n\t\t\t};\n\n\t\t\tconst onCancel = (cancelHandler: () => void): void => {\n\t\t\t\tif (this._isResolved || this._isRejected || this._isCancelled) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tthis.cancelHandlers.push(cancelHandler);\n\t\t\t};\n\n\t\t\tObject.defineProperty(onCancel, 'isResolved', {\n\t\t\t\tget: (): boolean => this._isResolved,\n\t\t\t});\n\n\t\t\tObject.defineProperty(onCancel, 'isRejected', {\n\t\t\t\tget: (): boolean => this._isRejected,\n\t\t\t});\n\n\t\t\tObject.defineProperty(onCancel, 'isCancelled', {\n\t\t\t\tget: (): boolean => this._isCancelled,\n\t\t\t});\n\n\t\t\treturn executor(onResolve, onReject, onCancel as OnCancel);\n\t\t});\n\t}\n\n\tget [Symbol.toStringTag]() {\n\t\treturn \"Cancellable Promise\";\n\t}\n\n\tpublic then<TResult1 = T, TResult2 = never>(\n\t\tonFulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | null,\n\t\tonRejected?: ((reason: unknown) => TResult2 | PromiseLike<TResult2>) | null\n\t): Promise<TResult1 | TResult2> {\n\t\treturn this.promise.then(onFulfilled, onRejected);\n\t}\n\n\tpublic catch<TResult = never>(\n\t\tonRejected?: ((reason: unknown) => TResult | PromiseLike<TResult>) | null\n\t): Promise<T | TResult> {\n\t\treturn this.promise.catch(onRejected);\n\t}\n\n\tpublic finally(onFinally?: (() => void) | null): Promise<T> {\n\t\treturn this.promise.finally(onFinally);\n\t}\n\n\tpublic cancel(): void {\n\t\tif (this._isResolved || this._isRejected || this._isCancelled) {\n\t\t\treturn;\n\t\t}\n\t\tthis._isCancelled = true;\n\t\tif (this.cancelHandlers.length) {\n\t\t\ttry {\n\t\t\t\tfor (const cancelHandler of this.cancelHandlers) {\n\t\t\t\t\tcancelHandler();\n\t\t\t\t}\n\t\t\t} catch (error) {\n\t\t\t\tconsole.warn('Cancellation threw an error', error);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tthis.cancelHandlers.length = 0;\n\t\tif (this._reject) this._reject(new CancelError('Request aborted'));\n\t}\n\n\tpublic get isCancelled(): boolean {\n\t\treturn this._isCancelled;\n\t}\n}</src/client/core/CancelablePromise.ts>\n\n<src/client/core/types.ts>\nimport type { ApiResult } from './ApiResult';\n\nexport type TResult = 'body' | 'raw';\n\nexport type TApiResponse<T extends TResult, TData> =\n  Exclude<T, 'raw'> extends never\n    ? ApiResult<TData>\n    : ApiResult<TData>['body'];\n\nexport type TConfig<T extends TResult> = {\n  _result?: T;\n};</src/client/core/types.ts>\n\n<src/client/core/ApiResult.ts>\nexport type ApiResult<TData = any> = {\n\treadonly body: TData;\n\treadonly ok: boolean;\n\treadonly status: number;\n\treadonly statusText: string;\n\treadonly url: string;\n};</src/client/core/ApiResult.ts>\n\n<src/client/core/OpenAPI.ts>\nimport type { AxiosRequestConfig, AxiosResponse } from 'axios';import type { ApiRequestOptions } from './ApiRequestOptions';\nimport type { TResult } from './types';\n\ntype Headers = Record<string, string>;\ntype Middleware<T> = (value: T) => T | Promise<T>;\ntype Resolver<T> = (options: ApiRequestOptions) => Promise<T>;\n\nexport class Interceptors<T> {\n  _fns: Middleware<T>[];\n\n  constructor() {\n    this._fns = [];\n  }\n\n  eject(fn: Middleware<T>) {\n    const index = this._fns.indexOf(fn);\n    if (index !== -1) {\n      this._fns = [\n        ...this._fns.slice(0, index),\n        ...this._fns.slice(index + 1),\n      ];\n    }\n  }\n\n  use(fn: Middleware<T>) {\n    this._fns = [...this._fns, fn];\n  }\n}\n\nexport type OpenAPIConfig = {\n\tBASE: string;\n\tCREDENTIALS: 'include' | 'omit' | 'same-origin';\n\tENCODE_PATH?: ((path: string) => string) | undefined;\n\tHEADERS?: Headers | Resolver<Headers> | undefined;\n\tPASSWORD?: string | Resolver<string> | undefined;\n\tRESULT?: TResult;\n\tTOKEN?: string | Resolver<string> | undefined;\n\tUSERNAME?: string | Resolver<string> | undefined;\n\tVERSION: string;\n\tWITH_CREDENTIALS: boolean;\n\tinterceptors: {request: Interceptors<AxiosRequestConfig>;\n\t\tresponse: Interceptors<AxiosResponse>;};\n};\n\nexport const OpenAPI: OpenAPIConfig = {\n\tBASE: '',\n\tCREDENTIALS: 'include',\n\tENCODE_PATH: undefined,\n\tHEADERS: undefined,\n\tPASSWORD: undefined,\n\tRESULT: 'body',\n\tTOKEN: undefined,\n\tUSERNAME: undefined,\n\tVERSION: '0.1.0',\n\tWITH_CREDENTIALS: false,\n\tinterceptors: {request: new Interceptors(),response: new Interceptors(),\n\t},\n};</src/client/core/OpenAPI.ts>\n\n<src/client/core/request.ts>\nimport axios from 'axios';\nimport type { AxiosError, AxiosRequestConfig, AxiosResponse, AxiosInstance } from 'axios';\n\nimport { ApiError } from './ApiError';\nimport type { ApiRequestOptions } from './ApiRequestOptions';\nimport type { ApiResult } from './ApiResult';\nimport { CancelablePromise } from './CancelablePromise';\nimport type { OnCancel } from './CancelablePromise';\nimport type { OpenAPIConfig } from './OpenAPI';\n\nexport const isString = (value: unknown): value is string => {\n\treturn typeof value === 'string';\n};\n\nexport const isStringWithValue = (value: unknown): value is string => {\n\treturn isString(value) && value !== '';\n};\n\nexport const isBlob = (value: any): value is Blob => {\n\treturn value instanceof Blob;\n};\n\nexport const isFormData = (value: unknown): value is FormData => {\n\treturn value instanceof FormData;\n};\n\nexport const isSuccess = (status: number): boolean => {\n\treturn status >= 200 && status < 300;\n};\n\nexport const base64 = (str: string): string => {\n\ttry {\n\t\treturn btoa(str);\n\t} catch (err) {\n\t\t// @ts-ignore\n\t\treturn Buffer.from(str).toString('base64');\n\t}\n};\n\nexport const getQueryString = (params: Record<string, unknown>): string => {\n\tconst qs: string[] = [];\n\n\tconst append = (key: string, value: unknown) => {\n\t\tqs.push(`${encodeURIComponent(key)}=${encodeURIComponent(String(value))}`);\n\t};\n\n\tconst encodePair = (key: string, value: unknown) => {\n\t\tif (value === undefined || value === null) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (Array.isArray(value)) {\n\t\t\tvalue.forEach(v => encodePair(key, v));\n\t\t} else if (typeof value === 'object') {\n\t\t\tObject.entries(value).forEach(([k, v]) => encodePair(`${key}[${k}]`, v));\n\t\t} else {\n\t\t\tappend(key, value);\n\t\t}\n\t};\n\n\tObject.entries(params).forEach(([key, value]) => encodePair(key, value));\n\n\treturn qs.length ? `?${qs.join('&')}` : '';\n};\n\nconst getUrl = (config: OpenAPIConfig, options: ApiRequestOptions): string => {\n\tconst encoder = config.ENCODE_PATH || encodeURI;\n\n\tconst path = options.url\n\t\t.replace('{api-version}', config.VERSION)\n\t\t.replace(/{(.*?)}/g, (substring: string, group: string) => {\n\t\t\tif (options.path?.hasOwnProperty(group)) {\n\t\t\t\treturn encoder(String(options.path[group]));\n\t\t\t}\n\t\t\treturn substring;\n\t\t});\n\n\tconst url = config.BASE + path;\n\treturn options.query ? url + getQueryString(options.query) : url;\n};\n\nexport const getFormData = (options: ApiRequestOptions): FormData | undefined => {\n\tif (options.formData) {\n\t\tconst formData = new FormData();\n\n\t\tconst process = (key: string, value: unknown) => {\n\t\t\tif (isString(value) || isBlob(value)) {\n\t\t\t\tformData.append(key, value);\n\t\t\t} else {\n\t\t\t\tformData.append(key, JSON.stringify(value));\n\t\t\t}\n\t\t};\n\n\t\tObject.entries(options.formData)\n\t\t\t.filter(([, value]) => value !== undefined && value !== null)\n\t\t\t.forEach(([key, value]) => {\n\t\t\t\tif (Array.isArray(value)) {\n\t\t\t\t\tvalue.forEach(v => process(key, v));\n\t\t\t\t} else {\n\t\t\t\t\tprocess(key, value);\n\t\t\t\t}\n\t\t\t});\n\n\t\treturn formData;\n\t}\n\treturn undefined;\n};\n\ntype Resolver<T> = (options: ApiRequestOptions) => Promise<T>;\n\nexport const resolve = async <T>(options: ApiRequestOptions, resolver?: T | Resolver<T>): Promise<T | undefined> => {\n\tif (typeof resolver === 'function') {\n\t\treturn (resolver as Resolver<T>)(options);\n\t}\n\treturn resolver;\n};\n\nexport const getHeaders = async (config: OpenAPIConfig, options: ApiRequestOptions): Promise<Record<string, string>> => {\n\tconst [token, username, password, additionalHeaders] = await Promise.all([\n\t\tresolve(options, config.TOKEN),\n\t\tresolve(options, config.USERNAME),\n\t\tresolve(options, config.PASSWORD),\n\t\tresolve(options, config.HEADERS),\n\t]);\n\n\tconst headers = Object.entries({\n\t\tAccept: 'application/json',\n\t\t...additionalHeaders,\n\t\t...options.headers,\n\t})\n\t.filter(([, value]) => value !== undefined && value !== null)\n\t.reduce((headers, [key, value]) => ({\n\t\t...headers,\n\t\t[key]: String(value),\n\t}), {} as Record<string, string>);\n\n\tif (isStringWithValue(token)) {\n\t\theaders['Authorization'] = `Bearer ${token}`;\n\t}\n\n\tif (isStringWithValue(username) && isStringWithValue(password)) {\n\t\tconst credentials = base64(`${username}:${password}`);\n\t\theaders['Authorization'] = `Basic ${credentials}`;\n\t}\n\n\tif (options.body !== undefined) {\n\t\tif (options.mediaType) {\n\t\t\theaders['Content-Type'] = options.mediaType;\n\t\t} else if (isBlob(options.body)) {\n\t\t\theaders['Content-Type'] = options.body.type || 'application/octet-stream';\n\t\t} else if (isString(options.body)) {\n\t\t\theaders['Content-Type'] = 'text/plain';\n\t\t} else if (!isFormData(options.body)) {\n\t\t\theaders['Content-Type'] = 'application/json';\n\t\t}\n\t} else if (options.formData !== undefined) {\n\t\tif (options.mediaType) {\n\t\t\theaders['Content-Type'] = options.mediaType;\n\t\t}\n\t}\n\n\treturn headers;\n};\n\nexport const getRequestBody = (options: ApiRequestOptions): unknown => {\n\tif (options.body) {\n\t\treturn options.body;\n\t}\n\treturn undefined;\n};\n\nexport const sendRequest = async <T>(\n\tconfig: OpenAPIConfig,\n\toptions: ApiRequestOptions,\n\turl: string,\n\tbody: unknown,\n\tformData: FormData | undefined,\n\theaders: Record<string, string>,\n\tonCancel: OnCancel,\n\taxiosClient: AxiosInstance\n): Promise<AxiosResponse<T>> => {\n\tconst controller = new AbortController();\n\n\tlet requestConfig: AxiosRequestConfig = {\n\t\tdata: body ?? formData,\n\t\theaders,\n\t\tmethod: options.method,\n\t\tsignal: controller.signal,\n\t\turl,\n\t\twithCredentials: config.WITH_CREDENTIALS,\n\t};\n\n\tonCancel(() => controller.abort());\n\n\tfor (const fn of config.interceptors.request._fns) {\n\t\trequestConfig = await fn(requestConfig)\n\t}\n\n\ttry {\n\t\treturn await axiosClient.request(requestConfig);\n\t} catch (error) {\n\t\tconst axiosError = error as AxiosError<T>;\n\t\tif (axiosError.response) {\n\t\t\treturn axiosError.response;\n\t\t}\n\t\tthrow error;\n\t}\n};\n\nexport const getResponseHeader = (response: AxiosResponse<unknown>, responseHeader?: string): string | undefined => {\n\tif (responseHeader) {\n\t\tconst content = response.headers[responseHeader];\n\t\tif (isString(content)) {\n\t\t\treturn content;\n\t\t}\n\t}\n\treturn undefined;\n};\n\nexport const getResponseBody = (response: AxiosResponse<unknown>): unknown => {\n\tif (response.status !== 204) {\n\t\treturn response.data;\n\t}\n\treturn undefined;\n};\n\nexport const catchErrorCodes = (options: ApiRequestOptions, result: ApiResult): void => {\n\tconst errors: Record<number, string> = {\n\t\t400: 'Bad Request',\n\t\t401: 'Unauthorized',\n\t\t402: 'Payment Required',\n\t\t403: 'Forbidden',\n\t\t404: 'Not Found',\n\t\t405: 'Method Not Allowed',\n\t\t406: 'Not Acceptable',\n\t\t407: 'Proxy Authentication Required',\n\t\t408: 'Request Timeout',\n\t\t409: 'Conflict',\n\t\t410: 'Gone',\n\t\t411: 'Length Required',\n\t\t412: 'Precondition Failed',\n\t\t413: 'Payload Too Large',\n\t\t414: 'URI Too Long',\n\t\t415: 'Unsupported Media Type',\n\t\t416: 'Range Not Satisfiable',\n\t\t417: 'Expectation Failed',\n\t\t418: 'Im a teapot',\n\t\t421: 'Misdirected Request',\n\t\t422: 'Unprocessable Content',\n\t\t423: 'Locked',\n\t\t424: 'Failed Dependency',\n\t\t425: 'Too Early',\n\t\t426: 'Upgrade Required',\n\t\t428: 'Precondition Required',\n\t\t429: 'Too Many Requests',\n\t\t431: 'Request Header Fields Too Large',\n\t\t451: 'Unavailable For Legal Reasons',\n\t\t500: 'Internal Server Error',\n\t\t501: 'Not Implemented',\n\t\t502: 'Bad Gateway',\n\t\t503: 'Service Unavailable',\n\t\t504: 'Gateway Timeout',\n\t\t505: 'HTTP Version Not Supported',\n\t\t506: 'Variant Also Negotiates',\n\t\t507: 'Insufficient Storage',\n\t\t508: 'Loop Detected',\n\t\t510: 'Not Extended',\n\t\t511: 'Network Authentication Required',\n\t\t...options.errors,\n\t}\n\n\tconst error = errors[result.status];\n\tif (error) {\n\t\tthrow new ApiError(options, result, error);\n\t}\n\n\tif (!result.ok) {\n\t\tconst errorStatus = result.status ?? 'unknown';\n\t\tconst errorStatusText = result.statusText ?? 'unknown';\n\t\tconst errorBody = (() => {\n\t\t\ttry {\n\t\t\t\treturn JSON.stringify(result.body, null, 2);\n\t\t\t} catch (e) {\n\t\t\t\treturn undefined;\n\t\t\t}\n\t\t})();\n\n\t\tthrow new ApiError(options, result,\n\t\t\t`Generic Error: status: ${errorStatus}; status text: ${errorStatusText}; body: ${errorBody}`\n\t\t);\n\t}\n};\n\n/**\n * Request method\n * @param config The OpenAPI configuration object\n * @param options The request options from the service\n * @param axiosClient The axios client instance to use\n * @returns CancelablePromise<T>\n * @throws ApiError\n */\nexport const request = <T>(config: OpenAPIConfig, options: ApiRequestOptions, axiosClient: AxiosInstance = axios): CancelablePromise<T> => {\n\treturn new CancelablePromise(async (resolve, reject, onCancel) => {\n\t\ttry {\n\t\t\tconst url = getUrl(config, options);\n\t\t\tconst formData = getFormData(options);\n\t\t\tconst body = getRequestBody(options);\n\t\t\tconst headers = await getHeaders(config, options);\n\n\t\t\tif (!onCancel.isCancelled) {\n\t\t\t\tlet response = await sendRequest<T>(config, options, url, body, formData, headers, onCancel, axiosClient);\n\n\t\t\t\tfor (const fn of config.interceptors.response._fns) {\n\t\t\t\t\tresponse = await fn(response)\n\t\t\t\t}\n\n\t\t\t\tconst responseBody = getResponseBody(response);\n\t\t\t\tconst responseHeader = getResponseHeader(response, options.responseHeader);\n\n\t\t\t\tconst result: ApiResult = {\n\t\t\t\t\turl,\n\t\t\t\t\tok: isSuccess(response.status),\n\t\t\t\t\tstatus: response.status,\n\t\t\t\t\tstatusText: response.statusText,\n\t\t\t\t\tbody: responseHeader ?? responseBody,\n\t\t\t\t};\n\n\t\t\t\tcatchErrorCodes(options, result);\n\n\t\t\t\tresolve(result.body);\n\t\t\t}\n\t\t} catch (error) {\n\t\t\treject(error);\n\t\t}\n\t});\n};</src/client/core/request.ts>\n\n<src/client/models.ts>\nexport type Body_login_login_access_token = {\n\tgrant_type?: string | null;\n\tusername: string;\n\tpassword: string;\n\tscope?: string;\n\tclient_id?: string | null;\n\tclient_secret?: string | null;\n};\n\n\n\nexport type HTTPValidationError = {\n\tdetail?: Array<ValidationError>;\n};\n\n\n\nexport type ItemCreate = {\n\ttitle: string;\n\tdescription?: string | null;\n};\n\n\n\nexport type ItemPublic = {\n\ttitle: string;\n\tdescription?: string | null;\n\tid: number;\n\towner_id: number;\n};\n\n\n\nexport type ItemUpdate = {\n\ttitle?: string | null;\n\tdescription?: string | null;\n};\n\n\n\nexport type ItemsPublic = {\n\tdata: Array<ItemPublic>;\n\tcount: number;\n};\n\n\n\nexport type Message = {\n\tmessage: string;\n};\n\n\n\nexport type NewPassword = {\n\ttoken: string;\n\tnew_password: string;\n};\n\n\n\nexport type Token = {\n\taccess_token: string;\n\ttoken_type?: string;\n};\n\n\n\nexport type UpdatePassword = {\n\tcurrent_password: string;\n\tnew_password: string;\n};\n\n\n\nexport type UserCreate = {\n\temail: string;\n\tis_active?: boolean;\n\tis_superuser?: boolean;\n\tfull_name?: string | null;\n\tpassword: string;\n};\n\n\n\nexport type UserPublic = {\n\temail: string;\n\tis_active?: boolean;\n\tis_superuser?: boolean;\n\tfull_name?: string | null;\n\tid: number;\n};\n\n\n\nexport type UserRegister = {\n\temail: string;\n\tpassword: string;\n\tfull_name?: string | null;\n};\n\n\n\nexport type UserUpdate = {\n\temail?: string | null;\n\tis_active?: boolean;\n\tis_superuser?: boolean;\n\tfull_name?: string | null;\n\tpassword?: string | null;\n};\n\n\n\nexport type UserUpdateMe = {\n\tfull_name?: string | null;\n\temail?: string | null;\n};\n\n\n\nexport type UsersPublic = {\n\tdata: Array<UserPublic>;\n\tcount: number;\n};\n\n\n\nexport type ValidationError = {\n\tloc: Array<string | number>;\n\tmsg: string;\n\ttype: string;\n};\n\n</src/client/models.ts>\n\n<src/client/index.ts>\n\nexport { ApiError } from './core/ApiError';\nexport { CancelablePromise, CancelError } from './core/CancelablePromise';\nexport { OpenAPI } from './core/OpenAPI';\nexport type { OpenAPIConfig } from './core/OpenAPI';\n\nexport * from './models'\nexport * from './schemas'\nexport * from './services'\n</src/client/index.ts>\n\n<src/client/services.ts>\nimport type { CancelablePromise } from './core/CancelablePromise';\nimport { OpenAPI } from './core/OpenAPI';\nimport { request as __request } from './core/request';\n\nimport type { Body_login_login_access_token,Message,NewPassword,Token,UserPublic,UpdatePassword,UserCreate,UserRegister,UsersPublic,UserUpdate,UserUpdateMe,ItemCreate,ItemPublic,ItemsPublic,ItemUpdate } from './models';\n\nexport type TDataLoginAccessToken = {\n                formData: Body_login_login_access_token\n                \n            }\nexport type TDataRecoverPassword = {\n                email: string\n                \n            }\nexport type TDataResetPassword = {\n                requestBody: NewPassword\n                \n            }\nexport type TDataRecoverPasswordHtmlContent = {\n                email: string\n                \n            }\n\nexport class LoginService {\n\n\t/**\n\t * Login Access Token\n\t * OAuth2 compatible token login, get an access token for future requests\n\t * @returns Token Successful Response\n\t * @throws ApiError\n\t */\n\tpublic static loginAccessToken(data: TDataLoginAccessToken): CancelablePromise<Token> {\n\t\tconst {\nformData,\n} = data;\n\t\treturn __request(OpenAPI, {\n\t\t\tmethod: 'POST',\n\t\t\turl: '/api/v1/login/access-token',\n\t\t\tformData: formData,\n\t\t\tmediaType: 'application/x-www-form-urlencoded',\n\t\t\terrors: {\n\t\t\t\t422: `Validation Error`,\n\t\t\t},\n\t\t});\n\t}\n\n\t/**\n\t * Test Token\n\t * Test access token\n\t * @returns UserPublic Successful Response\n\t * @throws ApiError\n\t */\n\tpublic static testToken(): CancelablePromise<UserPublic> {\n\t\t\t\treturn __request(OpenAPI, {\n\t\t\tmethod: 'POST',\n\t\t\turl: '/api/v1/login/test-token',\n\t\t});\n\t}\n\n\t/**\n\t * Recover Password\n\t * Password Recovery\n\t * @returns Message Successful Response\n\t * @throws ApiError\n\t */\n\tpublic static recoverPassword(data: TDataRecoverPassword): CancelablePromise<Message> {\n\t\tconst {\nemail,\n} = data;\n\t\treturn __request(OpenAPI, {\n\t\t\tmethod: 'POST',\n\t\t\turl: '/api/v1/password-recovery/{email}',\n\t\t\tpath: {\n\t\t\t\temail\n\t\t\t},\n\t\t\terrors: {\n\t\t\t\t422: `Validation Error`,\n\t\t\t},\n\t\t});\n\t}\n\n\t/**\n\t * Reset Password\n\t * Reset password\n\t * @returns Message Successful Response\n\t * @throws ApiError\n\t */\n\tpublic static resetPassword(data: TDataResetPassword): CancelablePromise<Message> {\n\t\tconst {\nrequestBody,\n} = data;\n\t\treturn __request(OpenAPI, {\n\t\t\tmethod: 'POST',\n\t\t\turl: '/api/v1/reset-password/',\n\t\t\tbody: requestBody,\n\t\t\tmediaType: 'application/json',\n\t\t\terrors: {\n\t\t\t\t422: `Validation Error`,\n\t\t\t},\n\t\t});\n\t}\n\n\t/**\n\t * Recover Password Html Content\n\t * HTML Content for Password Recovery\n\t * @returns string Successful Response\n\t * @throws ApiError\n\t */\n\tpublic static recoverPasswordHtmlContent(data: TDataRecoverPasswordHtmlContent): CancelablePromise<string> {\n\t\tconst {\nemail,\n} = data;\n\t\treturn __request(OpenAPI, {\n\t\t\tmethod: 'POST',\n\t\t\turl: '/api/v1/password-recovery-html-content/{email}',\n\t\t\tpath: {\n\t\t\t\temail\n\t\t\t},\n\t\t\terrors: {\n\t\t\t\t422: `Validation Error`,\n\t\t\t},\n\t\t});\n\t}\n\n}\n\nexport type TDataReadUsers = {\n                limit?: number\nskip?: number\n                \n            }\nexport type TDataCreateUser = {\n                requestBody: UserCreate\n                \n            }\nexport type TDataUpdateUserMe = {\n                requestBody: UserUpdateMe\n                \n            }\nexport type TDataUpdatePasswordMe = {\n                requestBody: UpdatePassword\n                \n            }\nexport type TDataRegisterUser = {\n                requestBody: UserRegister\n                \n            }\nexport type TDataReadUserById = {\n                userId: number\n                \n            }\nexport type TDataUpdateUser = {\n                requestBody: UserUpdate\nuserId: number\n                \n            }\nexport type TDataDeleteUser = {\n                userId: number\n                \n            }\n\nexport class UsersService {\n\n\t/**\n\t * Read Users\n\t * Retrieve users.\n\t * @returns UsersPublic Successful Response\n\t * @throws ApiError\n\t */\n\tpublic static readUsers(data: TDataReadUsers = {}): CancelablePromise<UsersPublic> {\n\t\tconst {\nlimit = 100,\nskip = 0,\n} = data;\n\t\treturn __request(OpenAPI, {\n\t\t\tmethod: 'GET',\n\t\t\turl: '/api/v1/users/',\n\t\t\tquery: {\n\t\t\t\tskip, limit\n\t\t\t},\n\t\t\terrors: {\n\t\t\t\t422: `Validation Error`,\n\t\t\t},\n\t\t});\n\t}\n\n\t/**\n\t * Create User\n\t * Create new user.\n\t * @returns UserPublic Successful Response\n\t * @throws ApiError\n\t */\n\tpublic static createUser(data: TDataCreateUser): CancelablePromise<UserPublic> {\n\t\tconst {\nrequestBody,\n} = data;\n\t\treturn __request(OpenAPI, {\n\t\t\tmethod: 'POST',\n\t\t\turl: '/api/v1/users/',\n\t\t\tbody: requestBody,\n\t\t\tmediaType: 'application/json',\n\t\t\terrors: {\n\t\t\t\t422: `Validation Error`,\n\t\t\t},\n\t\t});\n\t}\n\n\t/**\n\t * Read User Me\n\t * Get current user.\n\t * @returns UserPublic Successful Response\n\t * @throws ApiError\n\t */\n\tpublic static readUserMe(): CancelablePromise<UserPublic> {\n\t\t\t\treturn __request(OpenAPI, {\n\t\t\tmethod: 'GET',\n\t\t\turl: '/api/v1/users/me',\n\t\t});\n\t}\n\n\t/**\n\t * Update User Me\n\t * Update own user.\n\t * @returns UserPublic Successful Response\n\t * @throws ApiError\n\t */\n\tpublic static updateUserMe(data: TDataUpdateUserMe): CancelablePromise<UserPublic> {\n\t\tconst {\nrequestBody,\n} = data;\n\t\treturn __request(OpenAPI, {\n\t\t\tmethod: 'PATCH',\n\t\t\turl: '/api/v1/users/me',\n\t\t\tbody: requestBody,\n\t\t\tmediaType: 'application/json',\n\t\t\terrors: {\n\t\t\t\t422: `Validation Error`,\n\t\t\t},\n\t\t});\n\t}\n\n\t/**\n\t * Update Password Me\n\t * Update own password.\n\t * @returns Message Successful Response\n\t * @throws ApiError\n\t */\n\tpublic static updatePasswordMe(data: TDataUpdatePasswordMe): CancelablePromise<Message> {\n\t\tconst {\nrequestBody,\n} = data;\n\t\treturn __request(OpenAPI, {\n\t\t\tmethod: 'PATCH',\n\t\t\turl: '/api/v1/users/me/password',\n\t\t\tbody: requestBody,\n\t\t\tmediaType: 'application/json',\n\t\t\terrors: {\n\t\t\t\t422: `Validation Error`,\n\t\t\t},\n\t\t});\n\t}\n\n\t/**\n\t * Register User\n\t * Create new user without the need to be logged in.\n\t * @returns UserPublic Successful Response\n\t * @throws ApiError\n\t */\n\tpublic static registerUser(data: TDataRegisterUser): CancelablePromise<UserPublic> {\n\t\tconst {\nrequestBody,\n} = data;\n\t\treturn __request(OpenAPI, {\n\t\t\tmethod: 'POST',\n\t\t\turl: '/api/v1/users/signup',\n\t\t\tbody: requestBody,\n\t\t\tmediaType: 'application/json',\n\t\t\terrors: {\n\t\t\t\t422: `Validation Error`,\n\t\t\t},\n\t\t});\n\t}\n\n\t/**\n\t * Read User By Id\n\t * Get a specific user by id.\n\t * @returns UserPublic Successful Response\n\t * @throws ApiError\n\t */\n\tpublic static readUserById(data: TDataReadUserById): CancelablePromise<UserPublic> {\n\t\tconst {\nuserId,\n} = data;\n\t\treturn __request(OpenAPI, {\n\t\t\tmethod: 'GET',\n\t\t\turl: '/api/v1/users/{user_id}',\n\t\t\tpath: {\n\t\t\t\tuser_id: userId\n\t\t\t},\n\t\t\terrors: {\n\t\t\t\t422: `Validation Error`,\n\t\t\t},\n\t\t});\n\t}\n\n\t/**\n\t * Update User\n\t * Update a user.\n\t * @returns UserPublic Successful Response\n\t * @throws ApiError\n\t */\n\tpublic static updateUser(data: TDataUpdateUser): CancelablePromise<UserPublic> {\n\t\tconst {\nrequestBody,\nuserId,\n} = data;\n\t\treturn __request(OpenAPI, {\n\t\t\tmethod: 'PATCH',\n\t\t\turl: '/api/v1/users/{user_id}',\n\t\t\tpath: {\n\t\t\t\tuser_id: userId\n\t\t\t},\n\t\t\tbody: requestBody,\n\t\t\tmediaType: 'application/json',\n\t\t\terrors: {\n\t\t\t\t422: `Validation Error`,\n\t\t\t},\n\t\t});\n\t}\n\n\t/**\n\t * Delete User\n\t * Delete a user.\n\t * @returns Message Successful Response\n\t * @throws ApiError\n\t */\n\tpublic static deleteUser(data: TDataDeleteUser): CancelablePromise<Message> {\n\t\tconst {\nuserId,\n} = data;\n\t\treturn __request(OpenAPI, {\n\t\t\tmethod: 'DELETE',\n\t\t\turl: '/api/v1/users/{user_id}',\n\t\t\tpath: {\n\t\t\t\tuser_id: userId\n\t\t\t},\n\t\t\terrors: {\n\t\t\t\t422: `Validation Error`,\n\t\t\t},\n\t\t});\n\t}\n\n}\n\nexport type TDataTestEmail = {\n                emailTo: string\n                \n            }\n\nexport class UtilsService {\n\n\t/**\n\t * Test Email\n\t * Test emails.\n\t * @returns Message Successful Response\n\t * @throws ApiError\n\t */\n\tpublic static testEmail(data: TDataTestEmail): CancelablePromise<Message> {\n\t\tconst {\nemailTo,\n} = data;\n\t\treturn __request(OpenAPI, {\n\t\t\tmethod: 'POST',\n\t\t\turl: '/api/v1/utils/test-email/',\n\t\t\tquery: {\n\t\t\t\temail_to: emailTo\n\t\t\t},\n\t\t\terrors: {\n\t\t\t\t422: `Validation Error`,\n\t\t\t},\n\t\t});\n\t}\n\n}\n\nexport type TDataReadItems = {\n                limit?: number\nskip?: number\n                \n            }\nexport type TDataCreateItem = {\n                requestBody: ItemCreate\n                \n            }\nexport type TDataReadItem = {\n                id: number\n                \n            }\nexport type TDataUpdateItem = {\n                id: number\nrequestBody: ItemUpdate\n                \n            }\nexport type TDataDeleteItem = {\n                id: number\n                \n            }\n\nexport class ItemsService {\n\n\t/**\n\t * Read Items\n\t * Retrieve items.\n\t * @returns ItemsPublic Successful Response\n\t * @throws ApiError\n\t */\n\tpublic static readItems(data: TDataReadItems = {}): CancelablePromise<ItemsPublic> {\n\t\tconst {\nlimit = 100,\nskip = 0,\n} = data;\n\t\treturn __request(OpenAPI, {\n\t\t\tmethod: 'GET',\n\t\t\turl: '/api/v1/items/',\n\t\t\tquery: {\n\t\t\t\tskip, limit\n\t\t\t},\n\t\t\terrors: {\n\t\t\t\t422: `Validation Error`,\n\t\t\t},\n\t\t});\n\t}\n\n\t/**\n\t * Create Item\n\t * Create new item.\n\t * @returns ItemPublic Successful Response\n\t * @throws ApiError\n\t */\n\tpublic static createItem(data: TDataCreateItem): CancelablePromise<ItemPublic> {\n\t\tconst {\nrequestBody,\n} = data;\n\t\treturn __request(OpenAPI, {\n\t\t\tmethod: 'POST',\n\t\t\turl: '/api/v1/items/',\n\t\t\tbody: requestBody,\n\t\t\tmediaType: 'application/json',\n\t\t\terrors: {\n\t\t\t\t422: `Validation Error`,\n\t\t\t},\n\t\t});\n\t}\n\n\t/**\n\t * Read Item\n\t * Get item by ID.\n\t * @returns ItemPublic Successful Response\n\t * @throws ApiError\n\t */\n\tpublic static readItem(data: TDataReadItem): CancelablePromise<ItemPublic> {\n\t\tconst {\nid,\n} = data;\n\t\treturn __request(OpenAPI, {\n\t\t\tmethod: 'GET',\n\t\t\turl: '/api/v1/items/{id}',\n\t\t\tpath: {\n\t\t\t\tid\n\t\t\t},\n\t\t\terrors: {\n\t\t\t\t422: `Validation Error`,\n\t\t\t},\n\t\t});\n\t}\n\n\t/**\n\t * Update Item\n\t * Update an item.\n\t * @returns ItemPublic Successful Response\n\t * @throws ApiError\n\t */\n\tpublic static updateItem(data: TDataUpdateItem): CancelablePromise<ItemPublic> {\n\t\tconst {\nid,\nrequestBody,\n} = data;\n\t\treturn __request(OpenAPI, {\n\t\t\tmethod: 'PUT',\n\t\t\turl: '/api/v1/items/{id}',\n\t\t\tpath: {\n\t\t\t\tid\n\t\t\t},\n\t\t\tbody: requestBody,\n\t\t\tmediaType: 'application/json',\n\t\t\terrors: {\n\t\t\t\t422: `Validation Error`,\n\t\t\t},\n\t\t});\n\t}\n\n\t/**\n\t * Delete Item\n\t * Delete an item.\n\t * @returns Message Successful Response\n\t * @throws ApiError\n\t */\n\tpublic static deleteItem(data: TDataDeleteItem): CancelablePromise<Message> {\n\t\tconst {\nid,\n} = data;\n\t\treturn __request(OpenAPI, {\n\t\t\tmethod: 'DELETE',\n\t\t\turl: '/api/v1/items/{id}',\n\t\t\tpath: {\n\t\t\t\tid\n\t\t\t},\n\t\t\terrors: {\n\t\t\t\t422: `Validation Error`,\n\t\t\t},\n\t\t});\n\t}\n\n}</src/client/services.ts>\n\n<src/client/schemas.ts>\nexport const $Body_login_login_access_token = {\n\tproperties: {\n\t\tgrant_type: {\n\ttype: 'any-of',\n\tcontains: [{\n\ttype: 'string',\n\tpattern: 'password',\n}, {\n\ttype: 'null',\n}],\n},\n\t\tusername: {\n\ttype: 'string',\n\tisRequired: true,\n},\n\t\tpassword: {\n\ttype: 'string',\n\tisRequired: true,\n},\n\t\tscope: {\n\ttype: 'string',\n\tdefault: '',\n},\n\t\tclient_id: {\n\ttype: 'any-of',\n\tcontains: [{\n\ttype: 'string',\n}, {\n\ttype: 'null',\n}],\n},\n\t\tclient_secret: {\n\ttype: 'any-of',\n\tcontains: [{\n\ttype: 'string',\n}, {\n\ttype: 'null',\n}],\n},\n\t},\n} as const;\n\nexport const $HTTPValidationError = {\n\tproperties: {\n\t\tdetail: {\n\ttype: 'array',\n\tcontains: {\n\t\ttype: 'ValidationError',\n\t},\n},\n\t},\n} as const;\n\nexport const $ItemCreate = {\n\tproperties: {\n\t\ttitle: {\n\ttype: 'string',\n\tisRequired: true,\n},\n\t\tdescription: {\n\ttype: 'any-of',\n\tcontains: [{\n\ttype: 'string',\n}, {\n\ttype: 'null',\n}],\n},\n\t},\n} as const;\n\nexport const $ItemPublic = {\n\tproperties: {\n\t\ttitle: {\n\ttype: 'string',\n\tisRequired: true,\n},\n\t\tdescription: {\n\ttype: 'any-of',\n\tcontains: [{\n\ttype: 'string',\n}, {\n\ttype: 'null',\n}],\n},\n\t\tid: {\n\ttype: 'number',\n\tisRequired: true,\n},\n\t\towner_id: {\n\ttype: 'number',\n\tisRequired: true,\n},\n\t},\n} as const;\n\nexport const $ItemUpdate = {\n\tproperties: {\n\t\ttitle: {\n\ttype: 'any-of',\n\tcontains: [{\n\ttype: 'string',\n}, {\n\ttype: 'null',\n}],\n},\n\t\tdescription: {\n\ttype: 'any-of',\n\tcontains: [{\n\ttype: 'string',\n}, {\n\ttype: 'null',\n}],\n},\n\t},\n} as const;\n\nexport const $ItemsPublic = {\n\tproperties: {\n\t\tdata: {\n\ttype: 'array',\n\tcontains: {\n\t\ttype: 'ItemPublic',\n\t},\n\tisRequired: true,\n},\n\t\tcount: {\n\ttype: 'number',\n\tisRequired: true,\n},\n\t},\n} as const;\n\nexport const $Message = {\n\tproperties: {\n\t\tmessage: {\n\ttype: 'string',\n\tisRequired: true,\n},\n\t},\n} as const;\n\nexport const $NewPassword = {\n\tproperties: {\n\t\ttoken: {\n\ttype: 'string',\n\tisRequired: true,\n},\n\t\tnew_password: {\n\ttype: 'string',\n\tisRequired: true,\n},\n\t},\n} as const;\n\nexport const $Token = {\n\tproperties: {\n\t\taccess_token: {\n\ttype: 'string',\n\tisRequired: true,\n},\n\t\ttoken_type: {\n\ttype: 'string',\n\tdefault: 'bearer',\n},\n\t},\n} as const;\n\nexport const $UpdatePassword = {\n\tproperties: {\n\t\tcurrent_password: {\n\ttype: 'string',\n\tisRequired: true,\n},\n\t\tnew_password: {\n\ttype: 'string',\n\tisRequired: true,\n},\n\t},\n} as const;\n\nexport const $UserCreate = {\n\tproperties: {\n\t\temail: {\n\ttype: 'string',\n\tisRequired: true,\n},\n\t\tis_active: {\n\ttype: 'boolean',\n\tdefault: true,\n},\n\t\tis_superuser: {\n\ttype: 'boolean',\n\tdefault: false,\n},\n\t\tfull_name: {\n\ttype: 'any-of',\n\tcontains: [{\n\ttype: 'string',\n}, {\n\ttype: 'null',\n}],\n},\n\t\tpassword: {\n\ttype: 'string',\n\tisRequired: true,\n},\n\t},\n} as const;\n\nexport const $UserPublic = {\n\tproperties: {\n\t\temail: {\n\ttype: 'string',\n\tisRequired: true,\n},\n\t\tis_active: {\n\ttype: 'boolean',\n\tdefault: true,\n},\n\t\tis_superuser: {\n\ttype: 'boolean',\n\tdefault: false,\n},\n\t\tfull_name: {\n\ttype: 'any-of',\n\tcontains: [{\n\ttype: 'string',\n}, {\n\ttype: 'null',\n}],\n},\n\t\tid: {\n\ttype: 'number',\n\tisRequired: true,\n},\n\t},\n} as const;\n\nexport const $UserRegister = {\n\tproperties: {\n\t\temail: {\n\ttype: 'string',\n\tisRequired: true,\n},\n\t\tpassword: {\n\ttype: 'string',\n\tisRequired: true,\n},\n\t\tfull_name: {\n\ttype: 'any-of',\n\tcontains: [{\n\ttype: 'string',\n}, {\n\ttype: 'null',\n}],\n},\n\t},\n} as const;\n\nexport const $UserUpdate = {\n\tproperties: {\n\t\temail: {\n\ttype: 'any-of',\n\tcontains: [{\n\ttype: 'string',\n}, {\n\ttype: 'null',\n}],\n},\n\t\tis_active: {\n\ttype: 'boolean',\n\tdefault: true,\n},\n\t\tis_superuser: {\n\ttype: 'boolean',\n\tdefault: false,\n},\n\t\tfull_name: {\n\ttype: 'any-of',\n\tcontains: [{\n\ttype: 'string',\n}, {\n\ttype: 'null',\n}],\n},\n\t\tpassword: {\n\ttype: 'any-of',\n\tcontains: [{\n\ttype: 'string',\n}, {\n\ttype: 'null',\n}],\n},\n\t},\n} as const;\n\nexport const $UserUpdateMe = {\n\tproperties: {\n\t\tfull_name: {\n\ttype: 'any-of',\n\tcontains: [{\n\ttype: 'string',\n}, {\n\ttype: 'null',\n}],\n},\n\t\temail: {\n\ttype: 'any-of',\n\tcontains: [{\n\ttype: 'string',\n}, {\n\ttype: 'null',\n}],\n},\n\t},\n} as const;\n\nexport const $UsersPublic = {\n\tproperties: {\n\t\tdata: {\n\ttype: 'array',\n\tcontains: {\n\t\ttype: 'UserPublic',\n\t},\n\tisRequired: true,\n},\n\t\tcount: {\n\ttype: 'number',\n\tisRequired: true,\n},\n\t},\n} as const;\n\nexport const $ValidationError = {\n\tproperties: {\n\t\tloc: {\n\ttype: 'array',\n\tcontains: {\n\ttype: 'any-of',\n\tcontains: [{\n\ttype: 'string',\n}, {\n\ttype: 'number',\n}],\n},\n\tisRequired: true,\n},\n\t\tmsg: {\n\ttype: 'string',\n\tisRequired: true,\n},\n\t\ttype: {\n\ttype: 'string',\n\tisRequired: true,\n},\n\t},\n} as const;</src/client/schemas.ts>\n\n<src/vite-env.d.ts>\n/// <reference types=\"vite/client\" />\n</src/vite-env.d.ts>\n\nNow, please write the tech spec on our frontend template so that you will know how to modify this template for our actuall application\n"
                }
            ]
        },
        {
            "role": "assistant",
            "content": [
                {
                    "type": "text",
                    "text": "Tech Spec: Frontend Template Modification for FastAPI Backend Integration\n\nObjective:\nThe goal is to modify the existing frontend template to integrate with the FastAPI backend and create a fully functional web application. The frontend will utilize the API endpoints provided by the backend to perform CRUD operations on users and items, as well as handle user authentication and authorization.\n\nTechnologies:\n- React: JavaScript library for building user interfaces\n- TypeScript: Typed superset of JavaScript for enhanced development experience\n- Chakra UI: Component library for building accessible and customizable UI components\n- Tanstack Query: Data fetching and caching library for efficient data management\n- Tanstack Router: Routing library for declarative and type-safe routing\n- Axios: HTTP client for making API requests\n- Vite: Fast build tool and development server\n\nFrontend Structure:\nThe frontend template follows a modular structure with the following main components:\n- `src/client`: Contains the generated API client code for interacting with the backend\n- `src/components`: Contains reusable UI components organized by feature or functionality\n- `src/hooks`: Contains custom React hooks for authentication and toast notifications\n- `src/routes`: Contains the route components and route configuration\n- `src/theme`: Contains the custom theme configuration for Chakra UI\n- `src/utils`: Contains utility functions for form validation and other common tasks\n\nIntegration with FastAPI Backend:\n1. Update the API client:\n   - Review the generated API client code in `src/client` to ensure it aligns with the backend API endpoints and data models.\n   - Modify the `OpenAPI` configuration in `src/main.tsx` to set the correct base URL and authentication token handling.\n\n2. Implement user authentication:\n   - Utilize the `useAuth` hook in `src/hooks/useAuth.ts` to handle user login, logout, and token management.\n   - Modify the login and registration forms in `src/routes/login.tsx` and `src/routes/recover-password.tsx` to integrate with the backend authentication endpoints.\n   - Ensure that protected routes are only accessible to authenticated users by checking the authentication state in the route configuration.\n\n3. Implement user management:\n   - Create or update the necessary components in `src/components/Admin` for user management, such as `UserList`, `AddUser`, and `EditUser`.\n   - Utilize the `UsersService` from the API client to perform CRUD operations on users.\n   - Implement the user management functionality in the `src/routes/_layout/admin.tsx` route component.\n\n4. Implement item management:\n   - Create or update the necessary components in `src/components/Items` for item management, such as `ItemList`, `AddItem`, and `EditItem`.\n   - Utilize the `ItemsService` from the API client to perform CRUD operations on items.\n   - Implement the item management functionality in the `src/routes/_layout/items.tsx` route component.\n\n5. Implement user settings:\n   - Create or update the necessary components in `src/components/UserSettings` for user profile and password management.\n   - Utilize the `UsersService` from the API client to update user information and password.\n   - Implement the user settings functionality in the `src/routes/_layout/settings.tsx` route component.\n\n6. Error handling and validation:\n   - Utilize the `useCustomToast` hook in `src/hooks/useCustomToast.ts` to display success and error messages to the user.\n   - Implement proper error handling for API requests and display appropriate error messages to the user.\n   - Utilize the form validation rules defined in `src/utils.ts` to validate user input on the frontend.\n\n7. Testing and deployment:\n   - Write unit tests for critical components and functions to ensure code quality and prevent regressions.\n   - Set up a continuous integration and deployment (CI/CD) pipeline to automatically build, test, and deploy the frontend application.\n   - Configure the necessary environment variables for the production deployment, such as the backend API URL.\n\nBy following this tech spec and modifying the frontend template accordingly, you will be able to create a fully functional web application that seamlessly integrates with the FastAPI backend. The frontend will provide a user-friendly interface for managing users, items, and user settings, while ensuring proper authentication and authorization.\n\nRemember to regularly test the application, handle edge cases, and optimize performance as needed. Additionally, keep the code maintainable and follow best practices for React development, such as using functional components, hooks, and modular design patterns."
                }
            ]
        },
        {
            "role": "user",
            "content": [
                {
                    "type": "text",
                    "text": "Great!\n\nNow, here's the actual backend. Please write the tech spec on it:\n\n$ tree . -I venv\n.\n├── alembic.ini\n├── app\n│   ├── alembic\n│   │   ├── env.py\n│   │   ├── README\n│   │   ├── script.py.mako\n│   │   └── versions\n│   │       └── e2412789c190_initialize_models.py\n│   ├── algorithms\n│   │   └── face_video_image_match_verification\n│   │       ├── processor.py\n│   │       ├── router.py\n│   │       └── schema.py\n│   ├── api\n│   │   ├── deps.py\n│   │   ├── __init__.py\n│   │   ├── main.py\n│   │   └── routes\n│   │       ├── __init__.py\n│   │       ├── items.py\n│   │       ├── login.py\n│   │       ├── users.py\n│   │       └── utils.py\n│   ├── cli\n│   │   ├── db_cli.py\n│   │   ├── dev_cli.py\n│   │   ├── info_cli.py\n│   │   └── __init__.py\n│   ├── core\n│   │   ├── config.py\n│   │   ├── db.py\n│   │   ├── __init__.py\n│   │   ├── redis.py\n│   │   └── security.py\n│   ├── crud.py\n│   ├── email-templates\n│   │   ├── build\n│   │   │   ├── new_account.html\n│   │   │   ├── reset_password.html\n│   │   │   └── test_email.html\n│   │   └── src\n│   │       ├── new_account.mjml\n│   │       ├── reset_password.mjml\n│   │       └── test_email.mjml\n│   ├── __init__.py\n│   ├── main.py\n│   ├── schema\n│   │   ├── base.py\n│   │   ├── has_redis.py\n│   │   ├── system\n│   │   │   ├── api_key.py\n│   │   │   ├── api_key_use.py\n│   │   │   ├── auth.py\n│   │   │   └── billing.py\n│   │   ├── TODO\n│   │   ├── user\n│   │   │   ├── developer.py\n│   │   │   ├── ghost_identity.py\n│   │   │   ├── identity.py\n│   │   │   └── user.py\n│   │   └── verification\n│   │       ├── credit_bureau_verification.py\n│   │       ├── face_video_anomaly_verification.py\n│   │       ├── hand_sign_verification.py\n│   │       ├── human_speech_verification.py\n│   │       ├── living_pupil_verification.py\n│   │       ├── proof_of_id_verification.py\n│   │       └── verification.py\n│   ├── targets.py\n│   ├── tests\n│   │   ├── api\n│   │   │   ├── __init__.py\n│   │   │   └── routes\n│   │   │       ├── __init__.py\n│   │   │       ├── test_items.py\n│   │   │       ├── test_login.py\n│   │   │       └── test_users.py\n│   │   ├── conftest.py\n│   │   ├── crud\n│   │   │   ├── __init__.py\n│   │   │   └── test_user.py\n│   │   ├── __init__.py\n│   │   ├── scripts\n│   │   │   ├── __init__.py\n│   │   │   ├── test_backend_pre_start.py\n│   │   │   └── test_test_pre_start.py\n│   │   └── utils\n│   │       ├── __init__.py\n│   │       ├── item.py\n│   │       ├── user.py\n│   │       └── utils.py\n│   └── utils\n│       ├── consts.py\n│       ├── crud.py\n│       ├── errors.py\n│       └── __init__.py\n├── build\n│   ├── doctrees\n│   │   ├── environment.pickle\n│   │   └── index.doctree\n│   └── html\n│       ├── genindex.html\n│       ├── index.html\n│       ├── objects.inv\n│       ├── search.html\n│       ├── searchindex.js\n│       ├── _sources\n│       │   └── index.rst.txt\n│       └── _static\n│           ├── alabaster.css\n│           ├── basic.css\n│           ├── custom.css\n│           ├── doctools.js\n│           ├── documentation_options.js\n│           ├── file.png\n│           ├── language_data.js\n│           ├── minus.png\n│           ├── plus.png\n│           ├── pygments.css\n│           ├── searchtools.js\n│           └── sphinx_highlight.js\n├── Dockerfile\n├── make.bat\n├── Makefile\n├── poetry.lock\n├── prestart.sh\n├── pyproject.toml\n├── scripts\n│   ├── format.sh\n│   ├── lint.sh\n│   └── test.sh\n├── source\n│   ├── conf.py\n│   ├── index.rst\n│   ├── _static\n│   └── _templates\n└── tests-start.sh\n\n32 directories, 105 files\n\n$ find app -type f -exec sh -c 'echo \"<{}>\"; cat {}; echo \"</{}>\\n\"' \\; > dump.txt\n\n<app/cli/db_cli.py>\nfrom sqlmodel import Session\nimport typer\n\n# DB group commands\nfrom app.core import config\nfrom app.core.db import drop_db, init_db, seed_db, test_connect_db, engine\n\n# Assuming engine is created from a configuration setting\n\ndb_cli = typer.Typer()\n\n\n@db_cli.command()\nasync def drop(\n    confirm: bool = typer.Option(\n        False, \"--confirm\", prompt=\"Are you sure you want to drop the database?\"\n    )\n):\n    if confirm:\n        typer.echo(\"Dropping database...\")\n        with Session(engine) as session:\n            await drop_db(session)\n        typer.echo(\"Database dropped.\")\n    else:\n        typer.echo(\"Database drop cancelled.\")\n\n\n@db_cli.command()\ndef init():\n    typer.echo(\"Initializing database...\")\n    with Session(engine) as session:\n        init_db(session)\n    typer.echo(\"Database initialized.\")\n\n\n@db_cli.command()\ndef seed(test: bool = typer.Option(False, \"--test\")):\n    typer.echo(\"Seeding database...\")\n    with Session(engine) as session:\n        seed_db(session)\n    typer.echo(\"Database seeded.\")\n\n\n@db_cli.command()\ndef alembic(*args):\n    typer.echo(\"Running alembic command...\")\n    import subprocess\n\n    subprocess.run(\n        [\"alembic\", *args],\n        check=True,\n    )\n    typer.echo(\"Alembic command completed.\")\n\n\n@db_cli.command()\ndef test_connect():\n    typer.echo(\"Testing database connection...\")\n    with Session(engine) as session:\n        test_connect_db(session)\n    typer.echo(\"Database connection tested.\")\n\n\n@db_cli.command()\ndef backup():\n    typer.echo(\"Backing up database...\")\n    raise NotImplementedError(\"Not implemented yet\")\n\n    db = get_db()\n    import os\n    import shutil\n    from datetime import datetime\n\n    backup_dir = settings.BACKUP_DIR\n    os.makedirs(backup_dir, exist_ok=True)\n    timestamp = datetime.now().strftime(\"%Y%m%d%H%M%S\")\n    backup_file = os.path.join(backup_dir, f\"db_backup_{timestamp}.sql\")\n\n    command = f\"pg_dump -h {settings.POSTGRES_SERVER} -p {settings.POSTGRES_PORT} -U {settings.POSTGRES_USER} -d {settings.POSTGRES_DB} -f {backup_file}\"\n    os.system(command)\n\n    # Optionally, compress the backup file\n    shutil.make_archive(backup_file, \"zip\", backup_dir, backup_file)\n    typer.echo(\"Database backed up.\")\n\n\n@db_cli.command()\ndef restore():\n    typer.echo(\"Restoring database from backup...\")\n    raise NotImplementedError(\"Not implemented yet\")\n\n    import os\n    from datetime import datetime\n    import shutil\n    from sqlmodel import Session\n\n    backup_dir = settings.BACKUP_DIR\n    latest_backup = max(\n        [\n            os.path.join(backup_dir, f)\n            for f in os.listdir(backup_dir)\n            if f.endswith(\".sql.zip\")\n        ],\n        default=None,\n        key=os.path.getctime,\n    )\n\n    if latest_backup:\n        typer.echo(f\"Restoring from {latest_backup}...\")\n        # Unzip the backup file\n        with zipfile.ZipFile(latest_backup, \"r\") as zip_ref:\n            zip_ref.extractall(backup_dir)\n\n        # Get the SQL file name from the zip file\n        sql_file = latest_backup.replace(\".zip\", \"\")\n\n        # Restore the database from the SQL file\n        command = f\"psql -h {settings.POSTGRES_SERVER} -p {settings.POSTGRES_PORT} -U {settings.POSTGRES_USER} -d {settings.POSTGRES_DB} -f {sql_file}\"\n        os.system(command)\n\n        # Clean up extracted files\n        os.remove(sql_file)\n        typer.echo(\"Database restored from backup.\")\n    else:\n        typer.echo(\"No backup file found.\")\n\n\n@db_cli.command()\ndef migrate():\n    typer.echo(\"Migrating database...\")\n\n    # TODO: use the alembic scripts\n    raise NotImplementedError(\"Not implemented yet\")\n</app/cli/db_cli.py>\n\n<app/cli/dev_cli.py>\nimport os\nimport subprocess\nfrom typing import Annotated\nimport typer\nimport uvicorn\n\nfrom app.core.config import Settings, get_settings\nfrom app.main import fastapi_app\n\ndev_cli = typer.Typer()\n\nSettingsTyperDep = Annotated[Settings, typer.Depends(get_settings)]\n\n\n# Main command: serve\n@dev_cli.command()\nasync def serve(host: str = Settings.HOST, port: int = Settings.PORT):\n    uvicorn.run(fastapi_app, host=host, port=port)\n\n\nfrom app.core.config import get_settings\n\n\n@dev_cli.command()\nasync def status():\n    settings = await get_settings()\n    if settings.ENVIRONMENT == \"production\":\n        typer.echo(\"Running on production. Checking container health...\")\n        # Implement your container health check logic here\n        # This could be a script that checks Docker container statuses, for example:\n        os.system(\"docker ps --filter 'health=healthy'\")\n    else:\n        typer.echo(\"Not running in production environment.\")\n\n\n@dev_cli.command()\nasync def logs(days: int = 1):\n    typer.echo(f\"Fetching logs for the last {days} days.\")\n    typer.echo(\"Streaming logs (press Ctrl+C to stop)...\")\n    settings = await get_settings()\n    try:\n        subprocess.run([\"tail\", \"-f\", settings.LOG_FILE])\n    except KeyboardInterrupt:\n        typer.echo(\"Stopped streaming logs.\")\n\n\n@dev_cli.command()\nasync def build_docs():\n    code_dir = await get_settings().code_dir\n    subprocess.run(\n        [\"poetry\", \"run\", \"make\", \"html\"],\n        cwd=code_dir,\n        capture_output=False,\n    )\n\n\n@dev_cli.command()\nasync def test():\n    settings = await get_settings()\n    code_dir = settings.code_dir\n    subprocess.run(\n        [\"tests_start.sh\"],\n        cwd=code_dir,\n        capture_output=False,\n    )\n\n\n@dev_cli.command()\nasync def deploy(environment: str):\n    import semver\n    import git\n\n    settings = await get_settings()\n    repo_dir = typer.get_app_dir(\n        settings.app_name\n    )  # Use settings.app_name instead of hardcoded string\n    repo = git.Repo(repo_dir)\n\n    # Ensure we are on the prod branch and it's up to date\n    repo.git.checkout(\"prod\")\n    repo.git.pull(\"origin\", \"prod\")\n\n    # Merge current branch into prod\n    current_branch = repo.active_branch.name\n    repo.git.merge(current_branch)\n\n    # Increment the patch version\n    new_version = semver.VersionInfo.parse(settings.version).bump_patch()\n    settings.version = str(new_version)  # Update the settings version\n\n    # Commit the version change\n    repo.index.add([\"settings.py\"])  # Assuming version is stored in settings.py\n    repo.index.commit(f\"Bump version to {new_version}\")\n\n    # Push changes to prod\n    repo.git.push(\"origin\", \"prod\")\n\n    # Create a new GitHub release\n    typer.echo(f\"Creating a new GitHub release for version {new_version}\")\n    subprocess.run(\n        [\n            \"gh\",\n            \"release\",\n            \"create\",\n            str(new_version),\n            \"--notes\",\n            \"Auto-generated release\",\n        ],\n        cwd=repo_dir,\n        capture_output=False,\n    )\n\n    typer.echo(f\"Deploying to {environment}...\")\n    # Assuming a GitHub workflow handles the deployment when changes are pushed to prod    # Assuming a GitHub workflow handles the deployment when changes are pushed to prod    # Assuming a GitHub workflow handles the deployment when changes are pushed to prod\n\n\n@dev_cli.command()\ndef build():\n    typer.echo(\"Building project...\")\n    raise NotImplementedError(\"Not implemented yet\")\n</app/cli/dev_cli.py>\n\n<app/cli/__init__.py>\nimport os\nimport subprocess\nimport webbrowser\nfrom datetime import datetime\nfrom sqlmodel import Session\n\nimport typer\nimport uvicorn\n\nfrom app.core import logger\nfrom app.core.config import settings\nfrom app.core.db import engine\nfrom app.main import fastapi_app\n\ncli = typer.Typer(\n    \"\"\"\\\n    # CLI Commands Documentation\n\n    ## Main Commands\n    - `serve`: Start the server on a specified host and port.\n\n    ## Info Commands\n    - `docs`: Show documentation.\n    - `code`: Show codebase.\n    - `status`: Check the status of the backend systems.\n    - `logs`: Fetch logs for the specified number of days.\n\n    ## Database Commands\n    - `init`: Initialize the database.\n    - `seed`: Seed the database with initial data.\n    - `backup`: Backup the database.\n    - `restore`: Restore the database from a backup.\n    - `migrate`: Migrate the database schema.\n\n    ## Development Commands\n    - `test`: Run tests.\n    - `deploy`: Deploy the application to a specified environment.\n    - `build`: Build the project.\n    \"\"\"\n)\n\n# Sub-command groups\nfrom app.cli.db_cli import db_cli\nfrom app.cli.info_cli import info_cli\nfrom app.cli.dev_cli import dev_cli\nimport app.cli.db_cli as db_cli_endpoints\nimport app.cli.info_cli as info_cli_endpoints\nimport app.cli.dev_cli as dev_cli_endpoints\n\n\n# Adding sub-command groups to the main CLI\ncli.add_typer(info_cli, name=\"info\")\ncli.add_typer(db_cli, name=\"db\")\ncli.add_typer(dev_cli, name=\"dev\")\n\n\n@cli.command()\ndef dev(\n    host: str = typer.Option(\n        default=settings.DEV_HOST,\n        help=\"Host to run the server on.\",\n    ),\n    port: int = typer.Option(\n        default=settings.DEV_PORT,\n        help=\"Port to run the server on.\",\n    ),\n    new_db: bool = typer.Option(\n        default=False,\n        help=\"Create a new database.\",\n    ),\n):\n    with Session(engine) as db_session:\n        with typer.progressbar(\n            length=5, label=\"Processing database and server operations\"\n        ) as progress:\n            dev_cli_endpoints.test()\n            progress.update(1)\n            db_cli_endpoints.test_connect()\n            progress.update(1)\n            if new_db:\n                db_cli_endpoints.drop_db(db_session)\n                progress.update(1)\n                db_cli_endpoints.init_db(db_session)\n                progress.update(1)\n                db_cli_endpoints.seed_db(db_session)\n                progress.update(1)\n            else:\n                progress.update(3)\n            dev_cli_endpoints.serve(host, port)\n\n\nif __name__ == \"__main__\":\n    cli()\n</app/cli/__init__.py>\n\n<app/cli/info_cli.py>\nimport webbrowser\nimport typer\n\ninfo_cli = typer.Typer()\n\n\n# Info group commands\n@info_cli.command()\ndef docs():\n    typer.echo(\"Showing documentation...\")\n    webbrowser.open(\"https://github.com/verifyhumans/gotcha-v2/tree/main/docs\")\n\n\n@info_cli.command()\ndef code():\n    typer.echo(\"Showing code...\")\n    webbrowser.open(\"https://github.com/verifyhumans/gotcha-v2\")\n</app/cli/info_cli.py>\n\n<app/main.py>\nfrom contextlib import contextmanager\nimport sentry_sdk\nfrom fastapi import FastAPI\nfrom fastapi.routing import APIRoute\nfrom starlette.middleware.cors import CORSMiddleware\n\nfrom app.api.main import api_router\nfrom app.core.config import settings\n\n\ndef custom_generate_unique_id(route: APIRoute) -> str:\n    return f\"{route.tags[0]}-{route.name}\"\n\n\nif settings.SENTRY_DSN and settings.ENVIRONMENT != \"local\":\n    sentry_sdk.init(dsn=str(settings.SENTRY_DSN), enable_tracing=True)\n\n\n@contextmanager\ndef lifespan(app: FastAPI):\n    try:\n        yield\n    finally:\n        pass\n\n\nfastapi_app = FastAPI(\n    title=settings.PROJECT_NAME,\n    openapi_url=f\"{settings.api_v1_str}/openapi.json\",\n    generate_unique_id_function=custom_generate_unique_id,\n    lifespan=lifespan,\n)\n\n# Set all CORS enabled origins\nif settings.BACKEND_CORS_ORIGINS:\n    fastapi_app.add_middleware(\n        CORSMiddleware,\n        allow_origins=[\n            str(origin).strip(\"/\") for origin in settings.BACKEND_CORS_ORIGINS\n        ],\n        allow_credentials=True,\n        allow_methods=[\"*\"],\n        allow_headers=[\"*\"],\n    )\n\nfastapi_app.include_router(api_router, prefix=settings.api_v1_str)\n</app/main.py>\n\n<app/email-templates/build/test_email.html>\n<!doctype html><html xmlns=\"http://www.w3.org/1999/xhtml\" xmlns:v=\"urn:schemas-microsoft-com:vml\" xmlns:o=\"urn:schemas-microsoft-com:office:office\"><head><title></title><!--[if !mso]><!-- --><meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"><!--<![endif]--><meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\"><meta name=\"viewport\" content=\"width=device-width,initial-scale=1\"><style type=\"text/css\">#outlook a { padding:0; }\n          .ReadMsgBody { width:100%; }\n          .ExternalClass { width:100%; }\n          .ExternalClass * { line-height:100%; }\n          body { margin:0;padding:0;-webkit-text-size-adjust:100%;-ms-text-size-adjust:100%; }\n          table, td { border-collapse:collapse;mso-table-lspace:0pt;mso-table-rspace:0pt; }\n          img { border:0;height:auto;line-height:100%; outline:none;text-decoration:none;-ms-interpolation-mode:bicubic; }\n          p { display:block;margin:13px 0; }</style><!--[if !mso]><!--><style type=\"text/css\">@media only screen and (max-width:480px) {\n            @-ms-viewport { width:320px; }\n            @viewport { width:320px; }\n          }</style><!--<![endif]--><!--[if mso]>\n        <xml>\n        <o:OfficeDocumentSettings>\n          <o:AllowPNG/>\n          <o:PixelsPerInch>96</o:PixelsPerInch>\n        </o:OfficeDocumentSettings>\n        </xml>\n        <![endif]--><!--[if lte mso 11]>\n        <style type=\"text/css\">\n          .outlook-group-fix { width:100% !important; }\n        </style>\n        <![endif]--><style type=\"text/css\">@media only screen and (min-width:480px) {\n        .mj-column-per-100 { width:100% !important; max-width: 100%; }\n      }</style><style type=\"text/css\"></style></head><body style=\"background-color:#fafbfc;\"><div style=\"background-color:#fafbfc;\"><!--[if mso | IE]><table align=\"center\" border=\"0\" cellpadding=\"0\" cellspacing=\"0\" class=\"\" style=\"width:600px;\" width=\"600\" ><tr><td style=\"line-height:0px;font-size:0px;mso-line-height-rule:exactly;\"><![endif]--><div style=\"background:#ffffff;background-color:#ffffff;Margin:0px auto;max-width:600px;\"><table align=\"center\" border=\"0\" cellpadding=\"0\" cellspacing=\"0\" role=\"presentation\" style=\"background:#ffffff;background-color:#ffffff;width:100%;\"><tbody><tr><td style=\"direction:ltr;font-size:0px;padding:40px 20px;text-align:center;vertical-align:top;\"><!--[if mso | IE]><table role=\"presentation\" border=\"0\" cellpadding=\"0\" cellspacing=\"0\"><tr><td class=\"\" style=\"vertical-align:middle;width:560px;\" ><![endif]--><div class=\"mj-column-per-100 outlook-group-fix\" style=\"font-size:13px;text-align:left;direction:ltr;display:inline-block;vertical-align:middle;width:100%;\"><table border=\"0\" cellpadding=\"0\" cellspacing=\"0\" role=\"presentation\" style=\"vertical-align:middle;\" width=\"100%\"><tr><td align=\"center\" style=\"font-size:0px;padding:35px;word-break:break-word;\"><div style=\"font-family:Arial, Helvetica, sans-serif;font-size:20px;line-height:1;text-align:center;color:#333333;\">{{ project_name }}</div></td></tr><tr><td align=\"center\" style=\"font-size:0px;padding:10px 25px;padding-right:25px;padding-left:25px;word-break:break-word;\"><div style=\"font-family:, sans-serif;font-size:16px;line-height:1;text-align:center;color:#555555;\"><span>Test email for: {{ email }}</span></div></td></tr><tr><td style=\"font-size:0px;padding:10px 25px;word-break:break-word;\"><p style=\"border-top:solid 2px #cccccc;font-size:1;margin:0px auto;width:100%;\"></p><!--[if mso | IE]><table align=\"center\" border=\"0\" cellpadding=\"0\" cellspacing=\"0\" style=\"border-top:solid 2px #cccccc;font-size:1;margin:0px auto;width:510px;\" role=\"presentation\" width=\"510px\" ><tr><td style=\"height:0;line-height:0;\"> &nbsp;\n</td></tr></table><![endif]--></td></tr></table></div><!--[if mso | IE]></td></tr></table><![endif]--></td></tr></tbody></table></div><!--[if mso | IE]></td></tr></table><![endif]--></div></body></html></app/email-templates/build/test_email.html>\n\n<app/email-templates/build/reset_password.html>\n<!doctype html><html xmlns=\"http://www.w3.org/1999/xhtml\" xmlns:v=\"urn:schemas-microsoft-com:vml\" xmlns:o=\"urn:schemas-microsoft-com:office:office\"><head><title></title><!--[if !mso]><!-- --><meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"><!--<![endif]--><meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\"><meta name=\"viewport\" content=\"width=device-width,initial-scale=1\"><style type=\"text/css\">#outlook a { padding:0; }\n          .ReadMsgBody { width:100%; }\n          .ExternalClass { width:100%; }\n          .ExternalClass * { line-height:100%; }\n          body { margin:0;padding:0;-webkit-text-size-adjust:100%;-ms-text-size-adjust:100%; }\n          table, td { border-collapse:collapse;mso-table-lspace:0pt;mso-table-rspace:0pt; }\n          img { border:0;height:auto;line-height:100%; outline:none;text-decoration:none;-ms-interpolation-mode:bicubic; }\n          p { display:block;margin:13px 0; }</style><!--[if !mso]><!--><style type=\"text/css\">@media only screen and (max-width:480px) {\n            @-ms-viewport { width:320px; }\n            @viewport { width:320px; }\n          }</style><!--<![endif]--><!--[if mso]>\n        <xml>\n        <o:OfficeDocumentSettings>\n          <o:AllowPNG/>\n          <o:PixelsPerInch>96</o:PixelsPerInch>\n        </o:OfficeDocumentSettings>\n        </xml>\n        <![endif]--><!--[if lte mso 11]>\n        <style type=\"text/css\">\n          .outlook-group-fix { width:100% !important; }\n        </style>\n        <![endif]--><!--[if !mso]><!--><link href=\"https://fonts.googleapis.com/css?family=Ubuntu:300,400,500,700\" rel=\"stylesheet\" type=\"text/css\"><style type=\"text/css\">@import url(https://fonts.googleapis.com/css?family=Ubuntu:300,400,500,700);</style><!--<![endif]--><style type=\"text/css\">@media only screen and (min-width:480px) {\n        .mj-column-per-100 { width:100% !important; max-width: 100%; }\n      }</style><style type=\"text/css\"></style></head><body style=\"background-color:#fafbfc;\"><div style=\"background-color:#fafbfc;\"><!--[if mso | IE]><table align=\"center\" border=\"0\" cellpadding=\"0\" cellspacing=\"0\" class=\"\" style=\"width:600px;\" width=\"600\" ><tr><td style=\"line-height:0px;font-size:0px;mso-line-height-rule:exactly;\"><![endif]--><div style=\"background:#ffffff;background-color:#ffffff;Margin:0px auto;max-width:600px;\"><table align=\"center\" border=\"0\" cellpadding=\"0\" cellspacing=\"0\" role=\"presentation\" style=\"background:#ffffff;background-color:#ffffff;width:100%;\"><tbody><tr><td style=\"direction:ltr;font-size:0px;padding:40px 20px;text-align:center;vertical-align:top;\"><!--[if mso | IE]><table role=\"presentation\" border=\"0\" cellpadding=\"0\" cellspacing=\"0\"><tr><td class=\"\" style=\"vertical-align:middle;width:560px;\" ><![endif]--><div class=\"mj-column-per-100 outlook-group-fix\" style=\"font-size:13px;text-align:left;direction:ltr;display:inline-block;vertical-align:middle;width:100%;\"><table border=\"0\" cellpadding=\"0\" cellspacing=\"0\" role=\"presentation\" style=\"vertical-align:middle;\" width=\"100%\"><tr><td align=\"center\" style=\"font-size:0px;padding:35px;word-break:break-word;\"><div style=\"font-family:Arial, Helvetica, sans-serif;font-size:20px;line-height:1;text-align:center;color:#333333;\">{{ project_name }} - Password Recovery</div></td></tr><tr><td align=\"center\" style=\"font-size:0px;padding:10px 25px;padding-right:25px;padding-left:25px;word-break:break-word;\"><div style=\"font-family:Arial, Helvetica, sans-serif;font-size:16px;line-height:1;text-align:center;color:#555555;\"><span>Hello {{ username }}</span></div></td></tr><tr><td align=\"center\" style=\"font-size:0px;padding:10px 25px;padding-right:25px;padding-left:25px;word-break:break-word;\"><div style=\"font-family:Arial, Helvetica, sans-serif;font-size:16px;line-height:1;text-align:center;color:#555555;\">We've received a request to reset your password. You can do it by clicking the button below:</div></td></tr><tr><td align=\"center\" vertical-align=\"middle\" style=\"font-size:0px;padding:15px 30px;word-break:break-word;\"><table border=\"0\" cellpadding=\"0\" cellspacing=\"0\" role=\"presentation\" style=\"border-collapse:separate;line-height:100%;\"><tr><td align=\"center\" bgcolor=\"#009688\" role=\"presentation\" style=\"border:none;border-radius:8px;cursor:auto;padding:10px 25px;background:#009688;\" valign=\"middle\"><a href=\"{{ link }}\" style=\"background:#009688;color:#ffffff;font-family:Ubuntu, Helvetica, Arial, sans-serif;font-size:18px;font-weight:normal;line-height:120%;Margin:0;text-decoration:none;text-transform:none;\" target=\"_blank\">Reset password</a></td></tr></table></td></tr><tr><td align=\"center\" style=\"font-size:0px;padding:10px 25px;padding-right:25px;padding-left:25px;word-break:break-word;\"><div style=\"font-family:Arial, Helvetica, sans-serif;font-size:16px;line-height:1;text-align:center;color:#555555;\">Or copy and paste the following link into your browser:</div></td></tr><tr><td align=\"center\" style=\"font-size:0px;padding:10px 25px;padding-right:25px;padding-left:25px;word-break:break-word;\"><div style=\"font-family:Arial, Helvetica, sans-serif;font-size:16px;line-height:1;text-align:center;color:#555555;\"><a href=\"{{ link }}\">{{ link }}</a></div></td></tr><tr><td align=\"center\" style=\"font-size:0px;padding:10px 25px;padding-right:25px;padding-left:25px;word-break:break-word;\"><div style=\"font-family:Arial, Helvetica, sans-serif;font-size:16px;line-height:1;text-align:center;color:#555555;\">This password will expire in {{ valid_hours }} hours.</div></td></tr><tr><td style=\"font-size:0px;padding:10px 25px;word-break:break-word;\"><p style=\"border-top:solid 2px #cccccc;font-size:1;margin:0px auto;width:100%;\"></p><!--[if mso | IE]><table align=\"center\" border=\"0\" cellpadding=\"0\" cellspacing=\"0\" style=\"border-top:solid 2px #cccccc;font-size:1;margin:0px auto;width:510px;\" role=\"presentation\" width=\"510px\" ><tr><td style=\"height:0;line-height:0;\"> &nbsp;\n</td></tr></table><![endif]--></td></tr><tr><td align=\"center\" style=\"font-size:0px;padding:10px 25px;padding-right:25px;padding-left:25px;word-break:break-word;\"><div style=\"font-family:Arial, Helvetica, sans-serif;font-size:14px;line-height:1;text-align:center;color:#555555;\">If you didn't request a password recovery you can disregard this email.</div></td></tr></table></div><!--[if mso | IE]></td></tr></table><![endif]--></td></tr></tbody></table></div><!--[if mso | IE]></td></tr></table><![endif]--></div></body></html></app/email-templates/build/reset_password.html>\n\n<app/email-templates/build/new_account.html>\n<!doctype html><html xmlns=\"http://www.w3.org/1999/xhtml\" xmlns:v=\"urn:schemas-microsoft-com:vml\" xmlns:o=\"urn:schemas-microsoft-com:office:office\"><head><title></title><!--[if !mso]><!-- --><meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"><!--<![endif]--><meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\"><meta name=\"viewport\" content=\"width=device-width,initial-scale=1\"><style type=\"text/css\">#outlook a { padding:0; }\n          .ReadMsgBody { width:100%; }\n          .ExternalClass { width:100%; }\n          .ExternalClass * { line-height:100%; }\n          body { margin:0;padding:0;-webkit-text-size-adjust:100%;-ms-text-size-adjust:100%; }\n          table, td { border-collapse:collapse;mso-table-lspace:0pt;mso-table-rspace:0pt; }\n          img { border:0;height:auto;line-height:100%; outline:none;text-decoration:none;-ms-interpolation-mode:bicubic; }\n          p { display:block;margin:13px 0; }</style><!--[if !mso]><!--><style type=\"text/css\">@media only screen and (max-width:480px) {\n            @-ms-viewport { width:320px; }\n            @viewport { width:320px; }\n          }</style><!--<![endif]--><!--[if mso]>\n        <xml>\n        <o:OfficeDocumentSettings>\n          <o:AllowPNG/>\n          <o:PixelsPerInch>96</o:PixelsPerInch>\n        </o:OfficeDocumentSettings>\n        </xml>\n        <![endif]--><!--[if lte mso 11]>\n        <style type=\"text/css\">\n          .outlook-group-fix { width:100% !important; }\n        </style>\n        <![endif]--><!--[if !mso]><!--><link href=\"https://fonts.googleapis.com/css?family=Ubuntu:300,400,500,700\" rel=\"stylesheet\" type=\"text/css\"><style type=\"text/css\">@import url(https://fonts.googleapis.com/css?family=Ubuntu:300,400,500,700);</style><!--<![endif]--><style type=\"text/css\">@media only screen and (min-width:480px) {\n        .mj-column-per-100 { width:100% !important; max-width: 100%; }\n      }</style><style type=\"text/css\"></style></head><body style=\"background-color:#fafbfc;\"><div style=\"background-color:#fafbfc;\"><!--[if mso | IE]><table align=\"center\" border=\"0\" cellpadding=\"0\" cellspacing=\"0\" class=\"\" style=\"width:600px;\" width=\"600\" ><tr><td style=\"line-height:0px;font-size:0px;mso-line-height-rule:exactly;\"><![endif]--><div style=\"background:#ffffff;background-color:#ffffff;Margin:0px auto;max-width:600px;\"><table align=\"center\" border=\"0\" cellpadding=\"0\" cellspacing=\"0\" role=\"presentation\" style=\"background:#ffffff;background-color:#ffffff;width:100%;\"><tbody><tr><td style=\"direction:ltr;font-size:0px;padding:40px 20px;text-align:center;vertical-align:top;\"><!--[if mso | IE]><table role=\"presentation\" border=\"0\" cellpadding=\"0\" cellspacing=\"0\"><tr><td class=\"\" style=\"vertical-align:middle;width:560px;\" ><![endif]--><div class=\"mj-column-per-100 outlook-group-fix\" style=\"font-size:13px;text-align:left;direction:ltr;display:inline-block;vertical-align:middle;width:100%;\"><table border=\"0\" cellpadding=\"0\" cellspacing=\"0\" role=\"presentation\" style=\"vertical-align:middle;\" width=\"100%\"><tr><td align=\"center\" style=\"font-size:0px;padding:35px;word-break:break-word;\"><div style=\"font-family:Ubuntu, Helvetica, Arial, sans-serif;font-size:20px;line-height:1;text-align:center;color:#333333;\">{{ project_name }} - New Account</div></td></tr><tr><td align=\"center\" style=\"font-size:0px;padding:10px 25px;padding-right:25px;padding-left:25px;word-break:break-word;\"><div style=\"font-family:Arial, Helvetica, sans-serif;font-size:16px;line-height:1;text-align:center;color:#555555;\"><span>Welcome to your new account!</span></div></td></tr><tr><td align=\"center\" style=\"font-size:0px;padding:10px 25px;padding-right:25px;padding-left:25px;word-break:break-word;\"><div style=\"font-family:Arial, Helvetica, sans-serif;font-size:16px;line-height:1;text-align:center;color:#555555;\">Here are your account details:</div></td></tr><tr><td align=\"center\" style=\"font-size:0px;padding:10px 25px;padding-right:25px;padding-left:25px;word-break:break-word;\"><div style=\"font-family:Arial, Helvetica, sans-serif;font-size:16px;line-height:1;text-align:center;color:#555555;\">Username: {{ username }}</div></td></tr><tr><td align=\"center\" style=\"font-size:0px;padding:10px 25px;padding-right:25px;padding-left:25px;word-break:break-word;\"><div style=\"font-family:Arial, Helvetica, sans-serif;font-size:16px;line-height:1;text-align:center;color:#555555;\">Password: {{ password }}</div></td></tr><tr><td align=\"center\" vertical-align=\"middle\" style=\"font-size:0px;padding:15px 30px;word-break:break-word;\"><table border=\"0\" cellpadding=\"0\" cellspacing=\"0\" role=\"presentation\" style=\"border-collapse:separate;line-height:100%;\"><tr><td align=\"center\" bgcolor=\"#009688\" role=\"presentation\" style=\"border:none;border-radius:8px;cursor:auto;padding:10px 25px;background:#009688;\" valign=\"middle\"><a href=\"{{ link }}\" style=\"background:#009688;color:#ffffff;font-family:Ubuntu, Helvetica, Arial, sans-serif;font-size:18px;font-weight:normal;line-height:120%;Margin:0;text-decoration:none;text-transform:none;\" target=\"_blank\">Go to Dashboard</a></td></tr></table></td></tr><tr><td style=\"font-size:0px;padding:10px 25px;word-break:break-word;\"><p style=\"border-top:solid 2px #cccccc;font-size:1;margin:0px auto;width:100%;\"></p><!--[if mso | IE]><table align=\"center\" border=\"0\" cellpadding=\"0\" cellspacing=\"0\" style=\"border-top:solid 2px #cccccc;font-size:1;margin:0px auto;width:510px;\" role=\"presentation\" width=\"510px\" ><tr><td style=\"height:0;line-height:0;\"> &nbsp;\n</td></tr></table><![endif]--></td></tr></table></div><!--[if mso | IE]></td></tr></table><![endif]--></td></tr></tbody></table></div><!--[if mso | IE]></td></tr></table><![endif]--></div></body></html></app/email-templates/build/new_account.html>\n\n<app/email-templates/src/new_account.mjml>\n<mjml>\n  <mj-body background-color=\"#fafbfc\">\n    <mj-section background-color=\"#fff\" padding=\"40px 20px\">\n      <mj-column vertical-align=\"middle\" width=\"100%\">\n        <mj-text align=\"center\" padding=\"35px\" font-size=\"20px\" color=\"#333\">{{ project_name }} - New Account</mj-text>\n        <mj-text align=\"center\" font-size=\"16px\" padding-left=\"25px\" padding-right=\"25px\" font-family=\"Arial, Helvetica, sans-serif\" color=\"#555\"><span>Welcome to your new account!</span></mj-text>\n        <mj-text align=\"center\" font-size=\"16px\" padding-left=\"25px\" padding-right=\"25px\" font-family=\"Arial, Helvetica, sans-serif\" color=\"#555\">Here are your account details:</mj-text>\n        <mj-text align=\"center\" font-size=\"16px\" padding-left=\"25px\" padding-right=\"25px\" font-family=\"Arial, Helvetica, sans-serif\" color=\"#555\">Username: {{ username }}</mj-text>\n        <mj-text align=\"center\" font-size=\"16px\" padding-left=\"25px\" padding-right=\"25px\" font-family=\"Arial, Helvetica, sans-serif\" color=\"#555\">Password: {{ password }}</mj-text>\n        <mj-button align=\"center\" font-size=\"18px\" background-color=\"#009688\" border-radius=\"8px\" color=\"#fff\" href=\"{{ link }}\" padding=\"15px 30px\">Go to Dashboard</mj-button>\n        <mj-divider border-color=\"#ccc\" border-width=\"2px\"></mj-divider>\n      </mj-column>\n    </mj-section>\n  </mj-body>\n</mjml>\n</app/email-templates/src/new_account.mjml>\n\n<app/email-templates/src/reset_password.mjml>\n<mjml>\n  <mj-body background-color=\"#fafbfc\">\n    <mj-section background-color=\"#fff\" padding=\"40px 20px\">\n      <mj-column vertical-align=\"middle\" width=\"100%\">\n        <mj-text align=\"center\" padding=\"35px\" font-size=\"20px\" font-family=\"Arial, Helvetica, sans-serif\" color=\"#333\">{{ project_name }} - Password Recovery</mj-text>\n        <mj-text align=\"center\" font-size=\"16px\" padding-left=\"25px\" padding-right=\"25px\" font-family=\"Arial, Helvetica, sans-serif\" color=\"#555\"><span>Hello {{ username }}</span></mj-text>\n        <mj-text align=\"center\" font-size=\"16px\" padding-left=\"25px\" padding-right=\"25px\" font-family=\"Arial, Helvetica, sans-serif\" color=\"#555\">We've received a request to reset your password. You can do it by clicking the button below:</mj-text>\n        <mj-button align=\"center\" font-size=\"18px\" background-color=\"#009688\" border-radius=\"8px\" color=\"#fff\" href=\"{{ link }}\" padding=\"15px 30px\">Reset password</mj-button>\n        <mj-text align=\"center\" font-size=\"16px\" padding-left=\"25px\" padding-right=\"25px\" font-family=\"Arial, Helvetica, sans-serif\" color=\"#555\">Or copy and paste the following link into your browser:</mj-text>\n        <mj-text align=\"center\" font-size=\"16px\" padding-left=\"25px\" padding-right=\"25px\" font-family=\"Arial, Helvetica, sans-serif\" color=\"#555\"><a href=\"{{ link }}\">{{ link }}</a></mj-text>\n        <mj-text align=\"center\" font-size=\"16px\" padding-left=\"25px\" padding-right=\"25px\" font-family=\"Arial, Helvetica, sans-serif\" color=\"#555\">This password will expire in {{ valid_hours }} hours.</mj-text>\n        <mj-divider border-color=\"#ccc\" border-width=\"2px\"></mj-divider>\n        <mj-text align=\"center\" font-size=\"14px\" padding-left=\"25px\" padding-right=\"25px\" font-family=\"Arial, Helvetica, sans-serif\" color=\"#555\">If you didn't request a password recovery you can disregard this email.</mj-text>\n      </mj-column>\n    </mj-section>\n  </mj-body>\n</mjml>\n</app/email-templates/src/reset_password.mjml>\n\n<app/email-templates/src/test_email.mjml>\n<mjml>\n  <mj-body background-color=\"#fafbfc\">\n    <mj-section background-color=\"#fff\" padding=\"40px 20px\">\n      <mj-column vertical-align=\"middle\" width=\"100%\">\n        <mj-text align=\"center\" padding=\"35px\" font-size=\"20px\" font-family=\"Arial, Helvetica, sans-serif\" color=\"#333\">{{ project_name }}</mj-text>\n        <mj-text align=\"center\" font-size=\"16px\" padding-left=\"25px\" padding-right=\"25px\" font-family=\", sans-serif\" color=\"#555\"><span>Test email for: {{ email }}</span></mj-text>\n        <mj-divider border-color=\"#ccc\" border-width=\"2px\"></mj-divider>\n      </mj-column>\n    </mj-section>\n  </mj-body>\n</mjml>\n</app/email-templates/src/test_email.mjml>\n\n<app/core/security.py>\nfrom datetime import datetime, timedelta\nfrom typing import Any\n\nimport jwt\nfrom passlib.context import CryptContext\n\nfrom app.core.config import settings\n\npwd_context = CryptContext(schemes=[\"bcrypt\"], deprecated=\"auto\")\n\n\nALGORITHM = \"HS256\"\n\n\ndef create_access_token(subject: str | Any, expires_delta: timedelta) -> str:\n    expire = datetime.utcnow() + expires_delta\n    to_encode = {\"exp\": expire, \"sub\": str(subject)}\n    encoded_jwt = jwt.encode(to_encode, settings.SECRET_KEY, algorithm=ALGORITHM)\n    return encoded_jwt\n\n\ndef verify_password(plain_password: str, hashed_password: str) -> bool:\n    return pwd_context.verify(plain_password, hashed_password)\n\n\ndef get_password_hash(password: str) -> str:\n    return pwd_context.hash(password)\n</app/core/security.py>\n\n<app/core/redis.py>\nfrom redis import Redis\nfrom app.core.config import settings\n\n\ndef get_redis_connection() -> Redis:\n    return Redis.from_url(settings.REDIS_URL)\n</app/core/redis.py>\n\n<app/core/__init__.py>\n</app/core/__init__.py>\n\n<app/core/db.py>\nimport logging\n\nfrom sqlmodel import SQLModel, Session, create_engine, select\nfrom sqlalchemy import Engine\nfrom tenacity import after_log, before_log, retry, stop_after_attempt, wait_fixed\n\nfrom app.core.config import get_settings, settings\nfrom app import crud\nfrom app.schema.proof_of_id_verification import User, UserCreate\n\n\nconnect_args = {\"check_same_thread\": False}\nengine = create_engine(\n    str(settings.SQLALCHEMY_DATABASE_URI),\n    echo=True,\n    connect_args=connect_args,\n)\n\n\n# make sure all SQLModel models are imported (app.models) before initializing DB\n# otherwise, SQLModel might fail to initialize relationships properly\n# for more details: https://github.com/tiangolo/full-stack-fastapi-template/issues/28\n\n\nasync def init_db(session: Session, seed_if_new=False) -> None:\n    # Tables should be created with Alembic migrations\n    # But if you don't want to use migrations, create\n    # the tables un-commenting the next lines\n    # from sqlmodel import SQLModel\n    # We are using Alembic to create the tables\n    # # This works because the models are already imported and registered from app.models\n    # SQLModel.metadata.create_all(engine)\n\n    if seed_if_new:\n        settings = await get_settings()\n        if not settings.seeded_on:\n            await seed_db(session)\n\n\nasync def seed_db(session: Session) -> None:\n\n    crud.create_user(\n        session=session,\n        user_create=UserCreate(\n            email=settings.FIRST_SUPERUSER,\n            password=settings.FIRST_SUPERUSER_PASSWORD,\n            is_superuser=True,\n        ),\n    )\n\n\nlogging.basicConfig(level=logging.INFO)\nlogger = logging.getLogger(__name__)\n\nmax_tries = 60 * 5  # 5 minutes\nwait_seconds = 1\n\n\n@retry(\n    stop=stop_after_attempt(max_tries),\n    wait=wait_fixed(wait_seconds),\n    before=before_log(logger, logging.INFO),\n    after=after_log(logger, logging.WARN),\n)\ndef test_connect_db() -> None:\n    try:\n        with Session(db_engine) as session:\n            # Try to create session to check if DB is awake\n            session.exec(select(1))\n    except Exception as e:\n        logger.error(e)\n        raise e\n\n\nasync def drop_db(db_engine: Engine) -> None:\n    settings = await get_settings()\n    db_engine.execute(f\"DROP DATABASE IF EXISTS {settings.POSTGRES_DB}\")\n</app/core/db.py>\n\n<app/core/config.py>\nfrom datetime import datetime\nimport functools\nfrom pathlib import Path\nimport secrets\nimport warnings\nfrom typing import Annotated, Any, Literal\n\nimport semver\nfrom pydantic import (\n    AnyUrl,\n    BeforeValidator,\n    Field,\n    HttpUrl,\n    PostgresDsn,\n    computed_field,\n    model_validator,\n    AliasChoices,\n    AmqpDsn,\n    BaseModel,\n    ImportString,\n    RedisDsn,\n)\nfrom pydantic_core import MultiHostUrl\nfrom pydantic_settings import BaseSettings, SettingsConfigDict\nfrom typing_extensions import Self\n\n\ndef parse_cors(v: Any) -> list[str] | str:\n    if isinstance(v, str) and not v.startswith(\"[\"):\n        return [i.strip() for i in v.split(\",\")]\n    elif isinstance(v, list | str):\n        return v\n    raise ValueError(v)\n\n\nclass Settings(BaseSettings):\n    model_config = SettingsConfigDict(\n        env_file=\".env\", env_ignore_empty=True, extra=\"ignore\"\n    )\n\n    version_major: int\n    version_minor: int\n    version_patch: int\n\n    @property\n    def version(self) -> str:\n        return f\"{self.version_major}.{self.version_minor}.{self.version_patch}\"\n\n    @version.setter\n    def version(self, value: str) -> None:\n        try:\n            version_info = semver.VersionInfo.parse(value)\n            self.version_major = version_info.major\n            self.version_minor = version_info.minor\n            self.version_patch = version_info.patch\n        except ValueError:\n            raise ValueError(\n                f\"Invalid version format: {value}. Must be in the format '<major>.<minor>.<patch>'\"\n            )\n\n    seeded_on: datetime | None = Field(env=False)\n    start_time: datetime = Field(default_factory=datetime.utcnow, env=False)\n    maintenance_mode: bool = Field(default=False)\n\n    @property\n    def duration_since_seed(self):\n        return datetime.utcnow() - self.seeded_on\n\n    @property\n    def uptime(self):\n        return datetime.utcnow() - self.start_time\n\n    API_V1_STR: str = \"/api/v1\"\n    SECRET_KEY: str = secrets.token_urlsafe(32)\n    # 60 minutes * 24 hours * 8 days = 8 days\n    ACCESS_TOKEN_EXPIRE_MINUTES: int = 60 * 24 * 8\n    DOMAIN: str = \"localhost\"\n    ENVIRONMENT: Literal[\"local\", \"staging\", \"production\"] = \"local\"\n\n    REDIS_DSN: RedisDsn = Field(\n        \"redis://user:pass@localhost:6379/1\",\n        validation_alias=AliasChoices(\"SERVICE_REDIS_DSN\", \"REDIS_URL\"),\n    )\n\n    code_dir_override: str | None = Field(\n        default=None, validation_alias=AliasChoices(\"CODE_DIR_OVERRIDE\")\n    )\n\n    @computed_field  # type: ignore[misc]\n    @property\n    def code_dir(self) -> Path:\n        import typer\n\n        return typer.get_app_dir(app_name=self.app_name)\n\n    app_name: str = Field(\"Gotcha\", validation_alias=AliasChoices(\"APP_NAME\"))\n\n    LOG_FILE = \"./logs/debug.log\"\n    LOG_FORMAT = \"{time} {level} {message}\"\n    LOG_LEVEL = \"DEBUG\"\n    LOG_ROTATION = \"10 MB\"\n    LOG_COMPRESSION = \"zip\"\n\n    @computed_field  # type: ignore[misc]\n    @property\n    def server_host(self) -> str:\n        # Use HTTPS for anything other than local development\n        if self.ENVIRONMENT == \"local\":\n            return f\"http://{self.DOMAIN}\"\n        return f\"https://{self.DOMAIN}\"\n\n    BACKEND_CORS_ORIGINS: Annotated[list[AnyUrl] | str, BeforeValidator(parse_cors)] = (\n        []\n    )\n\n    PROJECT_NAME: str = \"targets\"\n    SENTRY_DSN: HttpUrl | None = None\n    POSTGRES_SERVER: str = \"localhost\"\n    POSTGRES_PORT: int = 5432\n    POSTGRES_USER: str = \"postgres\"\n    POSTGRES_PASSWORD: str = \"postgres\"\n    POSTGRES_DB: str = \"postgres\"\n\n    @computed_field  # type: ignore[misc]\n    @property\n    def SQLALCHEMY_DATABASE_URI(self) -> PostgresDsn:\n        return MultiHostUrl.build(\n            scheme=\"postgresql+psycopg\",\n            username=self.POSTGRES_USER,\n            password=self.POSTGRES_PASSWORD,\n            host=self.POSTGRES_SERVER,\n            port=self.POSTGRES_PORT,\n            path=self.POSTGRES_DB,\n        )\n\n    SMTP_TLS: bool = True\n    SMTP_SSL: bool = False\n    SMTP_PORT: int = 587\n    SMTP_HOST: str | None = None\n    SMTP_USER: str | None = None\n    SMTP_PASSWORD: str | None = None\n    # TODO: update type to EmailStr when sqlmodel supports it\n    EMAILS_FROM_EMAIL: str | None = None\n    EMAILS_FROM_NAME: str | None = None\n\n    @model_validator(mode=\"after\")\n    def _set_default_emails_from(self) -> Self:\n        if not self.EMAILS_FROM_NAME:\n            self.EMAILS_FROM_NAME = self.PROJECT_NAME\n        return self\n\n    EMAIL_RESET_TOKEN_EXPIRE_HOURS: int = 48\n\n    @computed_field  # type: ignore[misc]\n    @property\n    def emails_enabled(self) -> bool:\n        return bool(self.SMTP_HOST and self.EMAILS_FROM_EMAIL)\n\n    # TODO: update type to EmailStr when sqlmodel supports it\n    EMAIL_TEST_USER: str = \"test@example.com\"\n    # TODO: update type to EmailStr when sqlmodel supports it\n    FIRST_SUPERUSER: str\n    FIRST_SUPERUSER_PASSWORD: str\n    USERS_OPEN_REGISTRATION: bool = False\n\n    def _check_default_secret(self, var_name: str, value: str | None) -> None:\n        if value == \"changethis\":\n            message = (\n                f'The value of {var_name} is \"changethis\", '\n                \"for security, please change it, at least for deployments.\"\n            )\n            if self.ENVIRONMENT == \"local\":\n                warnings.warn(message, stacklevel=1)\n            else:\n                raise ValueError(message)\n\n    @model_validator(mode=\"after\")\n    def _enforce_non_default_secrets(self) -> Self:\n        self._check_default_secret(\"SECRET_KEY\", self.SECRET_KEY)\n        self._check_default_secret(\"POSTGRES_PASSWORD\", self.POSTGRES_PASSWORD)\n        self._check_default_secret(\n            \"FIRST_SUPERUSER_PASSWORD\", self.FIRST_SUPERUSER_PASSWORD\n        )\n\n        return self\n\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n\n        @functools.wraps(super().__setattr__)\n        def new_setattr_fn(self, name: str, value: Any) -> None:\n            super().__setattr__(name, value)\n            store_settings(self)\n\n        self.__setattr__ = new_setattr_fn\n\n\nfrom app.core.redis import get_redis_connection\n\nsettings: Settings | None = None  # Global settings variable\n\n\nasync def store_settings(settings: Settings):\n    redis = await get_redis_connection()\n    await redis.set(\"app_settings\", settings.to_json())\n    await redis.publish(\"settings_channel\", \"updated\")\n\n\nasync def get_settings() -> Settings:\n    redis = await get_redis_connection()\n    settings_json = await redis.get(\"app_settings\")\n    if settings_json:\n        return Settings.from_json(settings_json)\n    return Settings()  # Return default settings if not found in Redis\n\n\nasync def listen_for_settings_changes():\n    redis = await get_redis_connection()\n    pubsub = redis.pubsub()\n    await pubsub.subscribe(\"settings_channel\")\n    while True:\n        message = await pubsub.get_message(ignore_subscribe_messages=True)\n        if message and message[\"data\"] == \"updated\":\n            global settings  # Reference to the global settings object\n            settings = await get_settings()\n\n\nimport asyncio\n\n\n# Called start of application\nasync def init_settings():\n    global settings\n    settings = await get_settings()\n    asyncio.create_task(listen_for_settings_changes())\n</app/core/config.py>\n\n<app/utils/consts.py>\n</app/utils/consts.py>\n\n<app/utils/crud.py>\nfrom typing import Any, Optional\nfrom app.api.deps import SessionDep, get_db, MaybeCurrentUserDep\nfrom app.schema.proof_of_id_verification import (\n    ModelBase,\n    ModelCreate,\n    ModelInDB,\n    ModelRead,\n    ModelUpdate,\n)\nfrom fastapi import APIRouter, Depends, HTTPException\nfrom sqlmodel import Session\n\n\ndef build_crud_endpoints(\n    t_model_base: type[ModelBase],\n    t_model_create: type[ModelCreate] = None,\n    t_model_read: type[ModelRead] = None,\n    t_model_update: type[ModelUpdate] = None,\n    t_model_in_db: type[ModelInDB] = None,\n    implement_create=True,\n    implement_read=True,\n    implement_update=True,\n    implement_delete=True,\n    router: APIRouter = None,\n):\n    if router is None:\n        router = APIRouter()\n\n    t_model_base.ModelCreate = t_model_create\n    t_model_base.ModelUpdate = t_model_update\n    t_model_base.ModelRead = t_model_read\n    t_model_base.ModelInDB = t_model_in_db\n\n    if implement_create and not t_model_create is not None:\n\n        @router.post(\n            \"/\",\n            response_model=t_model_read,\n            response_description=f\"The created {t_model_base.__name__}\",\n            status_code=201,\n            tags=[t_model_base.__name__],\n            responses={\n                201: {\n                    \"description\": f\"The created {t_model_base.__name__}\",\n                    \"model\": t_model_read,\n                },\n                401: {\n                    \"description\": \"Unauthorized\",\n                    \"model\": HTTPException,\n                },\n                403: {\n                    \"description\": \"Forbidden\",\n                    \"model\": HTTPException,\n                },\n            },\n        )\n        async def create_one(\n            item: t_model_create, session: SessionDep, user: MaybeCurrentUserDep\n        ):\n            item_in_db = t_model_in_db.from_create(item, session=session, user=user)\n            return item_in_db.to_read(user=user)\n\n        @router.post(\n            \"/multiple\",\n            response_model=list[t_model_read],\n            response_description=f\"The created {t_model_base.__name__}s\",\n            status_code=201,\n            tags=[t_model_base.__name__],\n            responses={\n                201: {\n                    \"description\": f\"The created {t_model_base.__name__}s\",\n                    \"model\": list[t_model_read],\n                },\n                401: {\n                    \"description\": \"Unauthorized\",\n                    \"model\": HTTPException,\n                },\n                403: {\n                    \"description\": \"Forbidden\",\n                    \"model\": HTTPException,\n                },\n            },\n        )\n        async def create_multiple(\n            items: list[t_model_create],\n            session: SessionDep,\n            user: MaybeCurrentUserDep,\n        ):\n            return [\n                t_model_in_db.from_create(item, session=session, user=user).to_read(\n                    user=user\n                )\n                for item in items\n            ]\n\n    if implement_read and not t_model_read is not None:\n\n        @router.get(\n            \"/{id}\",\n            response_model=t_model_read,\n            response_description=f\"The {t_model_base.__name__}\",\n            status_code=200,\n            tags=[t_model_base.__name__],\n            responses={\n                200: {\n                    \"description\": f\"The {t_model_base.__name__}\",\n                    \"model\": t_model_read,\n                },\n                401: {\n                    \"description\": \"Unauthorized\",\n                    \"model\": HTTPException,\n                },\n                403: {\n                    \"description\": \"Forbidden\",\n                    \"model\": HTTPException,\n                },\n                404: {\n                    \"description\": \"Not found\",\n                    \"model\": HTTPException,\n                },\n            },\n        )\n        async def read_one(id: int, session: SessionDep, user: MaybeCurrentUserDep):\n            item_in_db = t_model_in_db.find_by_id(id, session=session)\n            if not item_in_db:\n                raise HTTPException(status_code=404, detail=\"Item not found\")\n            return item_in_db.to_read(user=user)\n\n        @router.get(\n            \"/{id}/{field}\",\n            response_model=t_model_read,\n            response_description=f\"The {t_model_base.__name__}\",\n            status_code=200,\n            tags=[t_model_base.__name__],\n            responses={\n                200: {\n                    \"description\": f\"The {t_model_base.__name__}\",\n                    \"model\": t_model_read,\n                },\n                401: {\n                    \"description\": \"Unauthorized\",\n                    \"model\": HTTPException,\n                },\n                403: {\n                    \"description\": \"Forbidden\",\n                    \"model\": HTTPException,\n                },\n                404: {\n                    \"description\": \"Not found\",\n                    \"model\": HTTPException,\n                },\n            },\n        )\n        async def read_one_field(\n            id: int, field: str, session: SessionDep, user: MaybeCurrentUserDep\n        ):\n            read_model = implement_read(id, session=session, user=user)\n            if not hasattr(read_model, field):\n                raise HTTPException(status_code=404, detail=\"Field not found\")\n            return getattr(read_model, field)\n\n        @router.get(\n            \"/multiple\",\n            response_model=list[t_model_read],\n            response_description=f\"The {t_model_base.__name__}s\",\n            status_code=200,\n            tags=[t_model_base.__name__],\n            responses={\n                200: {\n                    \"description\": f\"The {t_model_base.__name__}s\",\n                    \"model\": list[t_model_read],\n                },\n                401: {\n                    \"description\": \"Unauthorized\",\n                    \"model\": HTTPException,\n                },\n                403: {\n                    \"description\": \"Forbidden\",\n                    \"model\": HTTPException,\n                },\n                404: {\n                    \"description\": \"Not found\",\n                    \"model\": HTTPException,\n                },\n            },\n        )\n        async def read_multiple(\n            ids: list[int], session: SessionDep, user: MaybeCurrentUserDep\n        ):\n            items_in_db = t_model_in_db.find_by_ids(ids, session=session)\n            return [item.to_read(user=user) for item in items_in_db]\n\n        @router.get(\n            \"/\",\n            response_model=list[t_model_read],\n            response_description=f\"The {t_model_base.__name__}s\",\n            status_code=200,\n            tags=[t_model_base.__name__],\n            responses={\n                200: {\n                    \"description\": f\"The {t_model_base.__name__}s\",\n                    \"model\": list[t_model_read],\n                },\n                401: {\n                    \"description\": \"Unauthorized\",\n                    \"model\": HTTPException,\n                },\n                403: {\n                    \"description\": \"Forbidden\",\n                    \"model\": HTTPException,\n                },\n                404: {\n                    \"description\": \"Not found\",\n                    \"model\": HTTPException,\n                },\n            },\n        )\n        async def read_all(session: SessionDep, user: MaybeCurrentUserDep):\n            all_items_in_db = t_model_in_db.find_all(session=session)\n            return [item.to_read(user=user) for item in all_items_in_db]\n\n    if implement_update and not t_model_update is not None:\n\n        @router.put(\n            \"/{id}\",\n            response_model=t_model_read,\n            response_description=f\"Updated {t_model_base.__name__}\",\n            status_code=200,\n            tags=[t_model_base.__name__],\n            responses={\n                200: {\n                    \"description\": f\"Updated {t_model_base.__name__}\",\n                    \"model\": t_model_read,\n                },\n                400: {\n                    \"description\": \"Bad Request\",\n                    \"model\": HTTPException,\n                },\n                401: {\n                    \"description\": \"Unauthorized\",\n                    \"model\": HTTPException,\n                },\n                403: {\n                    \"description\": \"Forbidden\",\n                    \"model\": HTTPException,\n                },\n                404: {\n                    \"description\": \"Not found\",\n                    \"model\": HTTPException,\n                },\n            },\n        )\n        async def update_one(\n            id: int,\n            update_data: t_model_update,\n            session: SessionDep,\n            user: MaybeCurrentUserDep,\n        ):\n            item_in_db = t_model_in_db.find_by_id_or_raise(id, session)\n            item_in_db.update_from(update_data, session, user)\n            return item_in_db.to_read(user=user)\n\n        @router.patch(\n            \"/{id}/{field_name}\",\n            response_model=t_model_read,\n            response_description=f\"Partially updated {t_model_base.__name__}\",\n            status_code=200,\n            tags=[t_model_base.__name__],\n            responses={\n                200: {\n                    \"description\": f\"Partially updated {t_model_base.__name__}\",\n                    \"model\": t_model_read,\n                },\n                400: {\n                    \"description\": \"Bad Request\",\n                    \"model\": HTTPException,\n                },\n                401: {\n                    \"description\": \"Unauthorized\",\n                    \"model\": HTTPException,\n                },\n                403: {\n                    \"description\": \"Forbidden\",\n                    \"model\": HTTPException,\n                },\n                404: {\n                    \"description\": \"Not found\",\n                    \"model\": HTTPException,\n                },\n            },\n        )\n        async def update_one_field(\n            id: int,\n            field_name: str,\n            field_value: Any,\n            session: SessionDep,\n            user: MaybeCurrentUserDep,\n        ):\n            update_one(\n                id,\n                update_data={field_name: field_value},\n                session=session,\n                user=user,\n            )\n\n        @router.put(\n            \"/\",\n            response_model=list[t_model_read],\n            response_description=f\"Updated multiple {t_model_base.__name__}s\",\n            status_code=200,\n            tags=[t_model_base.__name__],\n            responses={\n                200: {\n                    \"description\": f\"Updated multiple {t_model_base.__name__}s\",\n                    \"model\": list[t_model_read],\n                },\n                400: {\n                    \"description\": \"Bad Request\",\n                    \"model\": HTTPException,\n                },\n                401: {\n                    \"description\": \"Unauthorized\",\n                    \"model\": HTTPException,\n                },\n                403: {\n                    \"description\": \"Forbidden\",\n                    \"model\": HTTPException,\n                },\n                404: {\n                    \"description\": \"Not found\",\n                    \"model\": HTTPException,\n                },\n            },\n        )\n        async def update_multiple(\n            ids: list[int],\n            update_data: t_model_update,\n            session: SessionDep,\n            user: MaybeCurrentUserDep,\n        ):\n            items_in_db = t_model_in_db.find_by_ids(ids, session)\n            for item in items_in_db:\n                item.update_from(update_data, session, user)\n            return [item.to_read(user=user) for item in items_in_db]\n\n    if implement_delete:\n\n        @router.delete(\n            \"/{id}\",\n            response_model=t_model_read,\n            response_description=f\"Deleted {t_model_base.__name__}\",\n            status_code=200,\n            tags=[t_model_base.__name__],\n            responses={\n                200: {\n                    \"description\": f\"Deleted {t_model_base.__name__}\",\n                    \"model\": t_model_read,\n                },\n                400: {\n                    \"description\": \"Bad Request\",\n                    \"model\": HTTPException,\n                },\n                401: {\n                    \"description\": \"Unauthorized\",\n                    \"model\": HTTPException,\n                },\n                403: {\n                    \"description\": \"Forbidden\",\n                    \"model\": HTTPException,\n                },\n                404: {\n                    \"description\": \"Not found\",\n                    \"model\": HTTPException,\n                },\n            },\n        )\n        async def delete_one(id: int, session: SessionDep, user: MaybeCurrentUserDep):\n            item_in_db = t_model_in_db.find_by_id_or_raise(id, session)\n            item_in_db.delete(session)\n            return item_in_db.to_read(user=user)\n\n        @router.delete(\n            \"/\",\n            response_model=list[t_model_read],\n            response_description=f\"Deleted multiple {t_model_base.__name__}s\",\n            status_code=200,\n            tags=[t_model_base.__name__],\n            responses={\n                200: {\n                    \"description\": f\"Deleted multiple {t_model_base.__name__}s\",\n                    \"model\": list[t_model_read],\n                },\n                400: {\n                    \"description\": \"Bad Request\",\n                    \"model\": HTTPException,\n                },\n                401: {\n                    \"description\": \"Unauthorized\",\n                    \"model\": HTTPException,\n                },\n                403: {\n                    \"description\": \"Forbidden\",\n                    \"model\": HTTPException,\n                },\n                404: {\n                    \"description\": \"Not found\",\n                    \"model\": HTTPException,\n                },\n            },\n        )\n        async def delete_multiple(\n            ids: list[int], session: SessionDep, user: MaybeCurrentUserDep\n        ):\n            items_in_db = t_model_in_db.find_by_ids(ids, session)\n            for item in items_in_db:\n                item.delete(session)\n            return [item.to_read(user=user) for item in items_in_db]\n\n    return router\n</app/utils/crud.py>\n\n<app/utils/errors.py>\nclass UnauthorizedUpdateError(Exception):\n    pass\n</app/utils/errors.py>\n\n<app/utils/__init__.py>\nimport logging\nfrom dataclasses import dataclass\nfrom datetime import datetime, timedelta\nfrom pathlib import Path\nfrom typing import Any\n\nimport emails  # type: ignore\nimport jwt\nfrom jinja2 import Template\nfrom jwt.exceptions import InvalidTokenError\n\nfrom app.core.config import settings\n\n\n@dataclass\nclass EmailData:\n    html_content: str\n    subject: str\n\n\ndef render_email_template(*, template_name: str, context: dict[str, Any]) -> str:\n    template_str = (\n        Path(__file__).parent / \"email-templates\" / \"build\" / template_name\n    ).read_text()\n    html_content = Template(template_str).render(context)\n    return html_content\n\n\ndef send_email(\n    *,\n    email_to: str,\n    subject: str = \"\",\n    html_content: str = \"\",\n) -> None:\n    assert settings.emails_enabled, \"no provided configuration for email variables\"\n    message = emails.Message(\n        subject=subject,\n        html=html_content,\n        mail_from=(settings.EMAILS_FROM_NAME, settings.EMAILS_FROM_EMAIL),\n    )\n    smtp_options = {\"host\": settings.SMTP_HOST, \"port\": settings.SMTP_PORT}\n    if settings.SMTP_TLS:\n        smtp_options[\"tls\"] = True\n    elif settings.SMTP_SSL:\n        smtp_options[\"ssl\"] = True\n    if settings.SMTP_USER:\n        smtp_options[\"user\"] = settings.SMTP_USER\n    if settings.SMTP_PASSWORD:\n        smtp_options[\"password\"] = settings.SMTP_PASSWORD\n    response = message.send(to=email_to, smtp=smtp_options)\n    logging.info(f\"send email result: {response}\")\n\n\ndef generate_test_email(email_to: str) -> EmailData:\n    project_name = settings.PROJECT_NAME\n    subject = f\"{project_name} - Test email\"\n    html_content = render_email_template(\n        template_name=\"test_email.html\",\n        context={\"project_name\": settings.PROJECT_NAME, \"email\": email_to},\n    )\n    return EmailData(html_content=html_content, subject=subject)\n\n\ndef generate_reset_password_email(email_to: str, email: str, token: str) -> EmailData:\n    project_name = settings.PROJECT_NAME\n    subject = f\"{project_name} - Password recovery for user {email}\"\n    link = f\"{settings.server_host}/reset-password?token={token}\"\n    html_content = render_email_template(\n        template_name=\"reset_password.html\",\n        context={\n            \"project_name\": settings.PROJECT_NAME,\n            \"username\": email,\n            \"email\": email_to,\n            \"valid_hours\": settings.EMAIL_RESET_TOKEN_EXPIRE_HOURS,\n            \"link\": link,\n        },\n    )\n    return EmailData(html_content=html_content, subject=subject)\n\n\ndef generate_new_account_email(\n    email_to: str, username: str, password: str\n) -> EmailData:\n    project_name = settings.PROJECT_NAME\n    subject = f\"{project_name} - New account for user {username}\"\n    html_content = render_email_template(\n        template_name=\"new_account.html\",\n        context={\n            \"project_name\": settings.PROJECT_NAME,\n            \"username\": username,\n            \"password\": password,\n            \"email\": email_to,\n            \"link\": settings.server_host,\n        },\n    )\n    return EmailData(html_content=html_content, subject=subject)\n\n\ndef generate_password_reset_token(email: str) -> str:\n    delta = timedelta(hours=settings.EMAIL_RESET_TOKEN_EXPIRE_HOURS)\n    now = datetime.utcnow()\n    expires = now + delta\n    exp = expires.timestamp()\n    encoded_jwt = jwt.encode(\n        {\"exp\": exp, \"nbf\": now, \"sub\": email},\n        settings.SECRET_KEY,\n        algorithm=\"HS256\",\n    )\n    return encoded_jwt\n\n\ndef verify_password_reset_token(token: str) -> str | None:\n    try:\n        decoded_token = jwt.decode(token, settings.SECRET_KEY, algorithms=[\"HS256\"])\n        return str(decoded_token[\"sub\"])\n    except InvalidTokenError:\n        return None\n</app/utils/__init__.py>\n\n<app/api/main.py>\nfrom fastapi import APIRouter\n\nfrom app.api.routes import items, login, users, utils\n\napi_router = APIRouter()\napi_router.include_router(login.router, tags=[\"login\"])\napi_router.include_router(users.router, prefix=\"/users\", tags=[\"users\"])\napi_router.include_router(utils.router, prefix=\"/utils\", tags=[\"utils\"])\napi_router.include_router(items.router, prefix=\"/items\", tags=[\"items\"])\n</app/api/main.py>\n\n<app/api/routes/users.py>\nfrom typing import Any\n\nfrom fastapi import APIRouter, Depends, HTTPException\nfrom sqlmodel import col, delete, func, select\n\nfrom app import crud\nfrom app.api.deps import (\n    CurrentUserDep,\n    SessionDep,\n    get_current_active_superuser,\n)\nfrom app.core.config import settings\nfrom app.core.security import get_password_hash, verify_password\nfrom app.schema.proof_of_id_verification import (\n    Item,\n    Message,\n    UpdatePassword,\n    User,\n    UserCreate,\n    UserPublic,\n    UserRegister,\n    UsersPublic,\n    UserUpdate,\n    UserUpdateMe,\n)\nfrom app.utils import generate_new_account_email, send_email\n\nrouter = APIRouter()\n\n\n@router.get(\n    \"/\",\n    dependencies=[Depends(get_current_active_superuser)],\n    response_model=UsersPublic,\n)\ndef read_users(session: SessionDep, skip: int = 0, limit: int = 100) -> Any:\n    \"\"\"\n    Retrieve users.\n    \"\"\"\n\n    count_statement = select(func.count()).select_from(User)\n    count = session.exec(count_statement).one()\n\n    statement = select(User).offset(skip).limit(limit)\n    users = session.exec(statement).all()\n\n    return UsersPublic(data=users, count=count)\n\n\n@router.post(\n    \"/\", dependencies=[Depends(get_current_active_superuser)], response_model=UserPublic\n)\ndef create_user(*, session: SessionDep, user_in: UserCreate) -> Any:\n    \"\"\"\n    Create new user.\n    \"\"\"\n    user = crud.get_user_by_email(session=session, email=user_in.email)\n    if user:\n        raise HTTPException(\n            status_code=400,\n            detail=\"The user with this email already exists in the system.\",\n        )\n\n    user = crud.create_user(session=session, user_create=user_in)\n    if settings.emails_enabled and user_in.email:\n        email_data = generate_new_account_email(\n            email_to=user_in.email, username=user_in.email, password=user_in.password\n        )\n        send_email(\n            email_to=user_in.email,\n            subject=email_data.subject,\n            html_content=email_data.html_content,\n        )\n    return user\n\n\n@router.patch(\"/me\", response_model=UserPublic)\ndef update_user_me(\n    *, session: SessionDep, user_in: UserUpdateMe, current_user: CurrentUserDep\n) -> Any:\n    \"\"\"\n    Update own user.\n    \"\"\"\n\n    if user_in.email:\n        existing_user = crud.get_user_by_email(session=session, email=user_in.email)\n        if existing_user and existing_user.id != current_user.id:\n            raise HTTPException(\n                status_code=409, detail=\"User with this email already exists\"\n            )\n    user_data = user_in.model_dump(exclude_unset=True)\n    current_user.sqlmodel_update(user_data)\n    session.add(current_user)\n    session.commit()\n    session.refresh(current_user)\n    return current_user\n\n\n@router.patch(\"/me/password\", response_model=Message)\ndef update_password_me(\n    *, session: SessionDep, body: UpdatePassword, current_user: CurrentUserDep\n) -> Any:\n    \"\"\"\n    Update own password.\n    \"\"\"\n    if not verify_password(body.current_password, current_user.hashed_password):\n        raise HTTPException(status_code=400, detail=\"Incorrect password\")\n    if body.current_password == body.new_password:\n        raise HTTPException(\n            status_code=400, detail=\"New password cannot be the same as the current one\"\n        )\n    hashed_password = get_password_hash(body.new_password)\n    current_user.hashed_password = hashed_password\n    session.add(current_user)\n    session.commit()\n    return Message(message=\"Password updated successfully\")\n\n\n@router.get(\"/me\", response_model=UserPublic)\ndef read_user_me(current_user: CurrentUserDep) -> Any:\n    \"\"\"\n    Get current user.\n    \"\"\"\n    return current_user\n\n\n@router.delete(\"/me\", response_model=Message)\ndef delete_user_me(session: SessionDep, current_user: CurrentUserDep) -> Any:\n    \"\"\"\n    Delete own user.\n    \"\"\"\n    if current_user.is_superuser:\n        raise HTTPException(\n            status_code=403, detail=\"Super users are not allowed to delete themselves\"\n        )\n    statement = delete(Item).where(col(Item.owner_id) == current_user.id)\n    session.exec(statement)  # type: ignore\n    session.delete(current_user)\n    session.commit()\n    return Message(message=\"User deleted successfully\")\n\n\n@router.post(\"/signup\", response_model=UserPublic)\ndef register_user(session: SessionDep, user_in: UserRegister) -> Any:\n    \"\"\"\n    Create new user without the need to be logged in.\n    \"\"\"\n    if not settings.USERS_OPEN_REGISTRATION:\n        raise HTTPException(\n            status_code=403,\n            detail=\"Open user registration is forbidden on this server\",\n        )\n    user = crud.get_user_by_email(session=session, email=user_in.email)\n    if user:\n        raise HTTPException(\n            status_code=400,\n            detail=\"The user with this email already exists in the system\",\n        )\n    user_create = UserCreate.model_validate(user_in)\n    user = crud.create_user(session=session, user_create=user_create)\n    return user\n\n\n@router.get(\"/{user_id}\", response_model=UserPublic)\ndef read_user_by_id(\n    user_id: int, session: SessionDep, current_user: CurrentUserDep\n) -> Any:\n    \"\"\"\n    Get a specific user by id.\n    \"\"\"\n    user = session.get(User, user_id)\n    if user == current_user:\n        return user\n    if not current_user.is_superuser:\n        raise HTTPException(\n            status_code=403,\n            detail=\"The user doesn't have enough privileges\",\n        )\n    return user\n\n\n@router.patch(\n    \"/{user_id}\",\n    dependencies=[Depends(get_current_active_superuser)],\n    response_model=UserPublic,\n)\ndef update_user(\n    *,\n    session: SessionDep,\n    user_id: int,\n    user_in: UserUpdate,\n) -> Any:\n    \"\"\"\n    Update a user.\n    \"\"\"\n\n    db_user = session.get(User, user_id)\n    if not db_user:\n        raise HTTPException(\n            status_code=404,\n            detail=\"The user with this id does not exist in the system\",\n        )\n    if user_in.email:\n        existing_user = crud.get_user_by_email(session=session, email=user_in.email)\n        if existing_user and existing_user.id != user_id:\n            raise HTTPException(\n                status_code=409, detail=\"User with this email already exists\"\n            )\n\n    db_user = crud.update_user(session=session, db_user=db_user, user_in=user_in)\n    return db_user\n\n\n@router.delete(\"/{user_id}\", dependencies=[Depends(get_current_active_superuser)])\ndef delete_user(\n    session: SessionDep, current_user: CurrentUserDep, user_id: int\n) -> Message:\n    \"\"\"\n    Delete a user.\n    \"\"\"\n    user = session.get(User, user_id)\n    if not user:\n        raise HTTPException(status_code=404, detail=\"User not found\")\n    if user == current_user:\n        raise HTTPException(\n            status_code=403, detail=\"Super users are not allowed to delete themselves\"\n        )\n    statement = delete(Item).where(col(Item.owner_id) == user_id)\n    session.exec(statement)  # type: ignore\n    session.delete(user)\n    session.commit()\n    return Message(message=\"User deleted successfully\")\n</app/api/routes/users.py>\n\n<app/api/routes/items.py>\nfrom typing import Any\n\nfrom fastapi import APIRouter, HTTPException\nfrom sqlmodel import func, select\n\nfrom app.api.deps import CurrentUserDep, SessionDep\nfrom app.schema.proof_of_id_verification import (\n    Item,\n    ItemCreate,\n    ItemPublic,\n    ItemsPublic,\n    ItemUpdate,\n    Message,\n)\n\nrouter = APIRouter()\n\n\n@router.get(\"/\", response_model=ItemsPublic)\ndef read_items(\n    session: SessionDep, current_user: CurrentUserDep, skip: int = 0, limit: int = 100\n) -> Any:\n    \"\"\"\n    Retrieve items.\n    \"\"\"\n\n    if current_user.is_superuser:\n        count_statement = select(func.count()).select_from(Item)\n        count = session.exec(count_statement).one()\n        statement = select(Item).offset(skip).limit(limit)\n        items = session.exec(statement).all()\n    else:\n        count_statement = (\n            select(func.count())\n            .select_from(Item)\n            .where(Item.owner_id == current_user.id)\n        )\n        count = session.exec(count_statement).one()\n        statement = (\n            select(Item)\n            .where(Item.owner_id == current_user.id)\n            .offset(skip)\n            .limit(limit)\n        )\n        items = session.exec(statement).all()\n\n    return ItemsPublic(data=items, count=count)\n\n\n@router.get(\"/{id}\", response_model=ItemPublic)\ndef read_item(session: SessionDep, current_user: CurrentUserDep, id: int) -> Any:\n    \"\"\"\n    Get item by ID.\n    \"\"\"\n    item = session.get(Item, id)\n    if not item:\n        raise HTTPException(status_code=404, detail=\"Item not found\")\n    if not current_user.is_superuser and (item.owner_id != current_user.id):\n        raise HTTPException(status_code=400, detail=\"Not enough permissions\")\n    return item\n\n\n@router.post(\"/\", response_model=ItemPublic)\ndef create_item(\n    *, session: SessionDep, current_user: CurrentUserDep, item_in: ItemCreate\n) -> Any:\n    \"\"\"\n    Create new item.\n    \"\"\"\n    item = Item.model_validate(item_in, update={\"owner_id\": current_user.id})\n    session.add(item)\n    session.commit()\n    session.refresh(item)\n    return item\n\n\n@router.put(\"/{id}\", response_model=ItemPublic)\ndef update_item(\n    *, session: SessionDep, current_user: CurrentUserDep, id: int, item_in: ItemUpdate\n) -> Any:\n    \"\"\"\n    Update an item.\n    \"\"\"\n    item = session.get(Item, id)\n    if not item:\n        raise HTTPException(status_code=404, detail=\"Item not found\")\n    if not current_user.is_superuser and (item.owner_id != current_user.id):\n        raise HTTPException(status_code=400, detail=\"Not enough permissions\")\n    update_dict = item_in.model_dump(exclude_unset=True)\n    item.sqlmodel_update(update_dict)\n    session.add(item)\n    session.commit()\n    session.refresh(item)\n    return item\n\n\n@router.delete(\"/{id}\")\ndef delete_item(session: SessionDep, current_user: CurrentUserDep, id: int) -> Message:\n    \"\"\"\n    Delete an item.\n    \"\"\"\n    item = session.get(Item, id)\n    if not item:\n        raise HTTPException(status_code=404, detail=\"Item not found\")\n    if not current_user.is_superuser and (item.owner_id != current_user.id):\n        raise HTTPException(status_code=400, detail=\"Not enough permissions\")\n    session.delete(item)\n    session.commit()\n    return Message(message=\"Item deleted successfully\")\n</app/api/routes/items.py>\n\n<app/api/routes/login.py>\nfrom datetime import timedelta\nfrom typing import Annotated, Any\n\nfrom fastapi import APIRouter, Depends, HTTPException\nfrom fastapi.responses import HTMLResponse\nfrom fastapi.security import OAuth2PasswordRequestForm\n\nfrom app import crud\nfrom app.api.deps import CurrentUserDep, SessionDep, get_current_active_superuser\nfrom app.core import security\nfrom app.core.config import settings\nfrom app.core.security import get_password_hash\nfrom app.schema.proof_of_id_verification import Message, NewPassword, Token, UserPublic\nfrom app.utils import (\n    generate_password_reset_token,\n    generate_reset_password_email,\n    send_email,\n    verify_password_reset_token,\n)\n\nrouter = APIRouter()\n\n\n@router.post(\"/login/access-token\")\ndef login_access_token(\n    session: SessionDep, form_data: Annotated[OAuth2PasswordRequestForm, Depends()]\n) -> Token:\n    \"\"\"\n    OAuth2 compatible token login, get an access token for future requests\n    \"\"\"\n    user = crud.authenticate(\n        session=session, email=form_data.username, password=form_data.password\n    )\n    if not user:\n        raise HTTPException(status_code=400, detail=\"Incorrect email or password\")\n    elif not user.is_active:\n        raise HTTPException(status_code=400, detail=\"Inactive user\")\n    access_token_expires = timedelta(minutes=settings.ACCESS_TOKEN_EXPIRE_MINUTES)\n    return Token(\n        access_token=security.create_access_token(\n            user.id, expires_delta=access_token_expires\n        )\n    )\n\n\n@router.post(\"/login/test-token\", response_model=UserPublic)\ndef test_token(current_user: CurrentUserDep) -> Any:\n    \"\"\"\n    Test access token\n    \"\"\"\n    return current_user\n\n\n@router.post(\"/password-recovery/{email}\")\ndef recover_password(email: str, session: SessionDep) -> Message:\n    \"\"\"\n    Password Recovery\n    \"\"\"\n    user = crud.get_user_by_email(session=session, email=email)\n\n    if not user:\n        raise HTTPException(\n            status_code=404,\n            detail=\"The user with this email does not exist in the system.\",\n        )\n    password_reset_token = generate_password_reset_token(email=email)\n    email_data = generate_reset_password_email(\n        email_to=user.email, email=email, token=password_reset_token\n    )\n    send_email(\n        email_to=user.email,\n        subject=email_data.subject,\n        html_content=email_data.html_content,\n    )\n    return Message(message=\"Password recovery email sent\")\n\n\n@router.post(\"/reset-password/\")\ndef reset_password(session: SessionDep, body: NewPassword) -> Message:\n    \"\"\"\n    Reset password\n    \"\"\"\n    email = verify_password_reset_token(token=body.token)\n    if not email:\n        raise HTTPException(status_code=400, detail=\"Invalid token\")\n    user = crud.get_user_by_email(session=session, email=email)\n    if not user:\n        raise HTTPException(\n            status_code=404,\n            detail=\"The user with this email does not exist in the system.\",\n        )\n    elif not user.is_active:\n        raise HTTPException(status_code=400, detail=\"Inactive user\")\n    hashed_password = get_password_hash(password=body.new_password)\n    user.hashed_password = hashed_password\n    session.add(user)\n    session.commit()\n    return Message(message=\"Password updated successfully\")\n\n\n@router.post(\n    \"/password-recovery-html-content/{email}\",\n    dependencies=[Depends(get_current_active_superuser)],\n    response_class=HTMLResponse,\n)\ndef recover_password_html_content(email: str, session: SessionDep) -> Any:\n    \"\"\"\n    HTML Content for Password Recovery\n    \"\"\"\n    user = crud.get_user_by_email(session=session, email=email)\n\n    if not user:\n        raise HTTPException(\n            status_code=404,\n            detail=\"The user with this username does not exist in the system.\",\n        )\n    password_reset_token = generate_password_reset_token(email=email)\n    email_data = generate_reset_password_email(\n        email_to=user.email, email=email, token=password_reset_token\n    )\n\n    return HTMLResponse(\n        content=email_data.html_content, headers={\"subject:\": email_data.subject}\n    )\n</app/api/routes/login.py>\n\n<app/api/routes/utils.py>\nfrom fastapi import APIRouter, Depends\nfrom pydantic.networks import EmailStr\n\nfrom app.api.deps import get_current_active_superuser\nfrom app.schema.proof_of_id_verification import Message\nfrom app.utils import generate_test_email, send_email\n\nrouter = APIRouter()\n\n\n@router.post(\n    \"/test-email/\",\n    dependencies=[Depends(get_current_active_superuser)],\n    status_code=201,\n)\ndef test_email(email_to: EmailStr) -> Message:\n    \"\"\"\n    Test emails.\n    \"\"\"\n    email_data = generate_test_email(email_to=email_to)\n    send_email(\n        email_to=email_to,\n        subject=email_data.subject,\n        html_content=email_data.html_content,\n    )\n    return Message(message=\"Test email sent\")\n</app/api/routes/utils.py>\n\n<app/api/routes/__init__.py>\n</app/api/routes/__init__.py>\n\n<app/api/__init__.py>\n</app/api/__init__.py>\n\n<app/api/deps.py>\nfrom collections.abc import Generator\nfrom typing import Annotated\n\nimport jwt\nfrom fastapi import Depends, HTTPException, Request, status\nfrom fastapi.security import OAuth2PasswordBearer\nfrom jwt.exceptions import InvalidTokenError\nfrom pydantic import ValidationError\nfrom sqlmodel import Session, select\n\nfrom app.core import security\nfrom app.core.config import settings\nfrom app.core.db import engine\nfrom app.schema.proof_of_id_verification import TokenPayload, User, VerifiableIdentity\n\nreusable_oauth2 = OAuth2PasswordBearer(\n    tokenUrl=f\"{settings.API_V1_STR}/login/access-token\"\n)\n\n\ndef get_db() -> Generator[Session, None, None]:\n    with Session(engine) as session:\n        yield session\n\n\nSessionDep = Annotated[Session, Depends(get_db)]\nTokenDep = Annotated[str, Depends(reusable_oauth2)]\n\n\ndef get_current_verifiable_identity(\n    request: Request, session: SessionDep, token: TokenDep\n) -> VerifiableIdentity:\n    identity = _get_current_user(session, token, raise_on_not_found=False)\n    if not identity:\n        ghost_identity = request.headers.get(\"ghost_identity\")\n        identity = session.exec(select(User).where(User.id == ghost_identity)).first()\n    return identity\n\n\ndef get_current_user(session: SessionDep, token: TokenDep) -> User:\n    return _get_current_user(session, token)\n\n\ndef maybe_get_current_user(session: SessionDep, token: TokenDep) -> User | None:\n    return _get_current_user(session, token, raise_on_not_found=False)\n\n\ndef _get_current_user(\n    session: SessionDep, token: TokenDep, raise_on_not_found: bool = True\n) -> User:\n    try:\n        payload = jwt.decode(\n            token, settings.SECRET_KEY, algorithms=[security.ALGORITHM]\n        )\n        token_data = TokenPayload(**payload)\n    except (InvalidTokenError, ValidationError):\n        raise HTTPException(\n            status_code=status.HTTP_403_FORBIDDEN,\n            detail=\"Could not validate credentials\",\n        )\n    user = session.get(User, token_data.sub)\n    if not user:\n        if raise_on_not_found:\n            raise HTTPException(status_code=404, detail=\"User not found\")\n        else:\n            return None\n    if not user.is_active:\n        raise HTTPException(status_code=400, detail=\"Inactive user\")\n    return user\n\n\nCurrentUserDep = Annotated[User, Depends(get_current_user)]\nMaybeCurrentUserDep = Annotated[User | None, Depends(maybe_get_current_user)]\n\n\ndef get_current_active_superuser(current_user: CurrentUserDep) -> User:\n    if not current_user.is_superuser:\n        raise HTTPException(\n            status_code=403, detail=\"The user doesn't have enough privileges\"\n        )\n    return current_user\n</app/api/deps.py>\n\n<app/crud.py>\nfrom typing import Any\n\nfrom sqlmodel import Session, select\n\nfrom app.core.security import get_password_hash, verify_password\nfrom app.schema.proof_of_id_verification import (\n    Item,\n    ItemCreate,\n    User,\n    UserCreate,\n    UserUpdate,\n)\n\n\ndef create_user(*, session: Session, user_create: UserCreate) -> User:\n    db_obj = User.model_validate(\n        user_create, update={\"hashed_password\": get_password_hash(user_create.password)}\n    )\n    session.add(db_obj)\n    session.commit()\n    session.refresh(db_obj)\n    return db_obj\n\n\ndef update_user(*, session: Session, db_user: User, user_in: UserUpdate) -> Any:\n    user_data = user_in.model_dump(exclude_unset=True)\n    extra_data = {}\n    if \"password\" in user_data:\n        password = user_data[\"password\"]\n        hashed_password = get_password_hash(password)\n        extra_data[\"hashed_password\"] = hashed_password\n    db_user.sqlmodel_update(user_data, update=extra_data)\n    session.add(db_user)\n    session.commit()\n    session.refresh(db_user)\n    return db_user\n\n\ndef get_user_by_email(*, session: Session, email: str) -> User | None:\n    statement = select(User).where(User.email == email)\n    session_user = session.exec(statement).first()\n    return session_user\n\n\ndef authenticate(*, session: Session, email: str, password: str) -> User | None:\n    db_user = get_user_by_email(session=session, email=email)\n    if not db_user:\n        return None\n    if not verify_password(password, db_user.hashed_password):\n        return None\n    return db_user\n\n\ndef create_item(*, session: Session, item_in: ItemCreate, owner_id: int) -> Item:\n    db_item = Item.model_validate(item_in, update={\"owner_id\": owner_id})\n    session.add(db_item)\n    session.commit()\n    session.refresh(db_item)\n    return db_item\n</app/crud.py>\n\n<app/algorithms/face_video_image_match_verification/processor.py>\nfrom datetime import datetime\nimport face_recognition\nimport cv2\nimport aio_pika\n\nfrom app.schema.proof_of_id_verification import (\n    OneTimeVerifiableIdentity,\n    UserThatRequestsVerification,\n    Verification,\n)\n\n\nclass FaceRecognitionHandler:\n    def __init__(self, verification_request: Verification):\n        self.video_capture = None\n        self.face_locations = []\n        self.frame_count = 0  # Initialize frame count\n        self.verification_request = verification_request\n        # hook up the handler for new amqp messages\n        self.verification_request.listen_for_messages(self.consumer)\n\n    async def consumer(self, data: str):\n        print(data)\n\n    def process_frame(self, frame):\n        # Resize frame of video to 1/4 size for faster face recognition processing\n        small_frame = cv2.resize(frame, (0, 0), fx=0.25, fy=0.25)\n\n        # Convert the image from BGR color (which OpenCV uses) to RGB color (which face_recognition uses)\n        rgb_small_frame = small_frame[:, :, ::-1]\n\n        # Only process every other frame of video to save time\n        if self.frame_count % 2 == 0:  # Check if the frame count is even\n            # Find all the faces and face locations in the current frame of video\n            new_face_locations = face_recognition.face_locations(rgb_small_frame)\n            self.face_locations.extend(\n                new_face_locations\n            )  # Append new detections to existing locations\n\n        # Draw a box around the faces\n        for top, right, bottom, left in self.face_locations:\n            cv2.rectangle(frame, (left, top), (right, bottom), (0, 0, 255), 2)\n        self.verification_request.publish_message(\"we're processing the frame\")\n\n        # Let's suppose you detected a face\n        if True:  # say, you detected a face\n            # send a message to the queue\n            self.verification_request.publish_message(\"face detected\")\n\n        self.frame_count += 1  # Increment the frame count\n        return True\n\n\ndef test_local_face_detection():\n    handler = FaceRecognitionHandler(\n        verification_request=Verification(\n            id=1,\n            who_to_verify=OneTimeVerifiableIdentity(id=1, image=b\"\"),\n            on_completion_redirect_url=\"\",\n            on_completion_webhook_url=\"\",\n            verification_requested_by=UserThatRequestsVerification(\n                id=2,\n                name=\"Test Developer\",\n                image=b\"\",\n                email=\"test@example.com\",\n                is_verified=True,\n                is_active=True,\n                full_name=\"Test Developer\",\n                hashed_password=\"\",\n                is_superuser=True,\n                stripe_user_access_token=\"\",\n            ),\n            verification_requested_at=datetime.now(),\n            verification_requested_by_id=2,\n            check_anomaly_in_face_video=False,\n            ask_to_make_hand_signs=False,\n            hand_letters=None,\n            check_match_against_provided_face_images=False,\n            additional_provided_face_images=[],\n            check_fingerprint=False,\n        )\n    )\n\n    cap = cv2.VideoCapture(0)\n    if not cap.isOpened():\n        print(\"Cannot open video source\")\n        exit()\n\n    while True:\n        ret, frame = cap.read()\n        if not ret:\n            print(\"Can't receive frame (stream end?). Exiting...\")\n            break\n        face = handler.process_frame(frame)\n        if not face:\n            break\n    cap.release()\n\n\nif __name__ == \"__main__\":\n    test_local_face_detection()\n</app/algorithms/face_video_image_match_verification/processor.py>\n\n<app/algorithms/face_video_image_match_verification/schema.py>\nfrom __future__ import annotations\n\nfrom abc import abstractmethod\nfrom datetime import datetime\nfrom enum import Enum\nfrom functools import cached_property\nfrom typing import ClassVar, Optional\n\nfrom pydantic.config import ConfigDict\nfrom sqlalchemy import Column, String, func\nfrom sqlalchemy.ext.hybrid import hybrid_column\nfrom sqlmodel import Field, Relationship, Session, SQLModel, delete, select\nfrom typing_extensions import Unpack\n\nfrom app.core.redis import get_redis_connection\nfrom app.schema.verification.verification import (\n    Verification,\n    VerificationBase,\n    VerificationRead,\n)\n\n\nclass FaceImageMatchVerificationBase(VerificationBase):\n    algorithm_name: str = \"face_image_match_verification-001\"\n\n\nclass FaceImageMatchVerification(FaceImageMatchVerificationBase, Verification):\n    additional_provided_face_images: list[bytes] | None = None\n\n    @hybrid_property\n    def all_provided_face_images(self):\n        return self.additional_provided_face_images + [self.who_to_verify.image]\n\n    @all_provided_face_images.expression\n    def all_provided_face_images(cls):\n        return func.array_cat(\n            cls.additional_provided_face_images, func.array([cls.who_to_verify.image])\n        )\n\n\nclass FaceImageMatchVerificationRead(FaceImageMatchVerificationBase, VerificationRead):\n    pass\n</app/algorithms/face_video_image_match_verification/schema.py>\n\n<app/algorithms/face_video_image_match_verification/router.py>\nfrom typing import Annotated\nfrom app.api.deps import (\n    get_current_active_superuser,\n    get_current_user,\n    get_current_user_or_none,\n    get_current_verifiable_identity,\n    get_db,\n)\nfrom app.ml.face_detection import FaceRecognitionHandler\nfrom app.schema.proof_of_id_verification import (\n    User,\n    UserThatRequestsVerification,\n    VerifiableIdentity,\n    VerificationBase,\n    VerificationRequestCreate,\n    VerificationRequestUpdate,\n    VerificationPublic,\n    Verification,\n    VerificationStatus,\n)\nfrom fastapi import APIRouter, Depends, HTTPException, WebSocket, Request\nfrom sqlalchemy.orm import Session\nfrom sqlmodel import select\nimport aio_pika\nimport os\n\n# I think we need this import and need to add the frames function in the video route\nfrom app.ml.face_detection import process_frame\n\nrouter = APIRouter()\n\n\n@router.get(\"/\", response_model=list[VerificationPublic])\ndef get_my_verification_requests(\n    db: Session = Depends(get_db),\n    current_user: User = Depends(get_current_user),\n):\n    return db.query(Verification).filter(Verification.user_id == current_user.id).all()\n\n\ndef get_verification_request_assigned_to_meby_id(\n    verification_request_id: int,\n    db: Session = Depends(get_db),\n    current_user: User = Depends(get_current_user),\n) -> Verification | None:\n    try:\n        verf_request = db.exec(\n            select(Verification)\n            .filter(\n                Verification.id == verification_request_id,\n                Verification.who_to_verify_id == current_user.id,\n            )\n            .first()\n        )\n        return verf_request\n    except Exception as e:\n        raise HTTPException(status_code=404, detail=\"Verification request not found\")\n\n\nGetVerificationRequestDep = Annotated[\n    Verification, Depends(get_verification_request_assigned_to_meby_id)\n]\n\n\n@router.post(\"/\", response_model=VerificationPublic)\ndef create_verification_request(\n    verification_request_in: VerificationRequestCreate,\n    db: Session = Depends(get_db),\n    current_user: User = Depends(get_current_user),\n):\n    if not isinstance(current_user, UserThatRequestsVerification):\n        raise HTTPException(\n            status_code=403,\n            detail=\"User must face for an other user that requests verification\",\n        )\n    verification_request = Verification(**verification_request_in.dict())\n    db.add(verification_request)\n    db.commit()\n    return verification_request\n\n\n@router.put(\"/{verification_request_id}\", response_model=VerificationPublic)\ndef update_verification_request(\n    verification_request_in: VerificationRequestUpdate,\n    current_verification_request: GetVerificationRequestDep = Depends(\n        GetVerificationRequestDep\n    ),\n    db: Session = Depends(get_db),\n):\n    if not current_verification_request:\n        raise HTTPException(status_code=404, detail=\"Verification request not found\")\n    current_verification_request.update(\n        verification_request_in.dict(exclude_unset=True)\n    )\n    db.commit()\n    return current_verification_request\n\n\n@router.get(\"/{verification_request_id}\", response_model=VerificationStatus)\ndef check_verification_request_status(\n    verification_request_id: int,\n    db: Session = Depends(get_db),\n    current_user: User = Depends(get_current_user),\n):\n    verification_request = (\n        db.query(Verification)\n        .filter(Verification.id == verification_request_id)\n        .first()\n    )\n    if not verification_request:\n        raise HTTPException(status_code=404, detail=\"Verification request not found\")\n    return verification_request\n\n\n@router.websocket(\"/ws/{verification_request_id}\")\nasync def verify_me_websocket_endpoint(\n    websocket: WebSocket,\n    verification_request_id: int,\n    db: Session = Depends(get_db),\n    current_identity: VerifiableIdentity = Depends(get_current_verifiable_identity),\n):\n    await websocket.accept()\n\n    verification_request = (\n        db.query(Verification)\n        .filter(Verification.id == verification_request_id)\n        .first()\n    )\n    if not verification_request:\n        raise HTTPException(status_code=404, detail=\"Verification request not found\")\n\n    async def consumer(message: aio_pika.IncomingMessage):\n        async with message.process():\n            # Echo message back to WebSocket\n            await websocket.send_text(f\"Message received: {message.body.decode()}\")\n\n    # Start consuming messages\n    await verification_request.amqp_queue().consume(consumer)\n\n    try:\n        while True:\n            text_data = await websocket.receive_text()\n            # Publish messages to the queue\n            await verification_request.amqp_queue().default_exchange.publish(\n                aio_pika.Message(body=text_data.encode()),\n                routing_key=verification_request.queue_name,\n            )\n\n    except Exception as e:\n        await websocket.close()\n        print(f\"WebSocket connection closed with exception: {e}\")\n    finally:\n        pass\n\n\n@router.post(\"/video/{verification_request_id}\")\nasync def stream_video(\n    request: Request, verification_request: GetVerificationRequestDep\n):\n    face_recognition_handler = FaceRecognitionHandler(\n        verification_request=verification_request\n    )\n    async for chunk in request.stream():\n        # Process each chunk of video data\n        face_recognition_handler.process_frame(chunk)\n</app/algorithms/face_video_image_match_verification/router.py>\n\n<app/schema/user/user.py>\nfrom __future__ import annotations\n\nfrom abc import abstractmethod\nfrom datetime import datetime\nfrom enum import Enum\nfrom functools import cached_property\nfrom typing import ClassVar, Optional\n\nfrom pydantic.config import ConfigDict\nfrom sqlalchemy import Column, String, func\nfrom sqlalchemy.ext.hybrid import hybrid_column\nfrom sqlmodel import Field, Relationship, Session, SQLModel, delete, select\nfrom typing_extensions import Unpack\n\nfrom app.core.redis import get_redis_connection\nfrom app.schema.base import ModelBase\nfrom app.schema.user.identity import (\n    Identity,\n    IdentityBase,\n    IdentityCreate,\n    IdentityRead,\n    VerifiableIdentityPublicMe,\n    IdentityUpdate,\n    VerifiableIdentityUpdateMe,\n)\nfrom app.utils.crud import build_crud_endpoints\n\n\n# Shared properties\n# TODO replace email str with EmailStr when sqlmodel supports it\nclass UserBase(IdentityBase):\n    email: str = Field(unique=True, index=True)\n    is_active: bool = True\n    is_superuser: bool = False\n    full_name: str | None = None\n\n\n# Properties to receive via API on creation\nclass UserCreate(IdentityCreate, UserBase):\n    password: str\n\n\n# TODO replace email str with EmailStr when sqlmodel supports it\nclass UserRegister(ModelBase):\n    email: str\n    password: str\n    full_name: str | None = None\n\n\n# Properties to receive via API on update, all are optional\n# TODO replace email str with EmailStr when sqlmodel supports it\nclass UserUpdate(IdentityUpdate, UserBase):\n    email: str | None = None  # type: ignore\n    password: str | None = None\n    full_name: str | None = None\n\n\n# Properties to return via API, id is always required\nclass UserRead(IdentityRead, UserBase):\n    id: int\n\n\n# Database model, database table inferred from class name\nclass User(Identity, UserBase):\n    id: int | None = Field(default=None, primary_key=True)\n    hashed_password: str\n\n\n# other API models\nclass UpdatePassword(ModelBase):\n    current_password: str\n    new_password: str\n\n\ncrud_router = build_crud_endpoints(\n    t_model_base=UserBase,\n    t_model_create=UserCreate,\n    t_model_read=UserRead,\n    t_model_update=UserUpdate,\n    t_model_in_db=User,\n)\n</app/schema/user/user.py>\n\n<app/schema/user/developer.py>\nfrom __future__ import annotations\n\nfrom abc import abstractmethod\nfrom datetime import datetime\nfrom enum import Enum\nfrom functools import cached_property\nfrom typing import ClassVar, Optional\n\nfrom pydantic.config import ConfigDict\nfrom sqlalchemy import Column, String, func\nfrom sqlalchemy.ext.hybrid import hybrid_column\nfrom sqlmodel import Field, Relationship, Session, SQLModel, delete, select\nfrom typing_extensions import Unpack\n\nfrom app.core.redis import get_redis_connection\nfrom app.schema.system.api_key import APIKey, APIKeyRead\nfrom app.schema.user.user import (\n    User,\n    UserBase,\n    UserCreate,\n    UserRead,\n    UserPublicMe,\n    UserUpdate,\n    UserUpdateMe,\n)\nfrom app.schema.verification.verification import Verification\nfrom app.utils.crud import build_crud_endpoints\n\n\n# Verifier\nclass DeveloperBase(UserBase):\n    pass\n\n\nclass DeveloperCreate(DeveloperBase, UserCreate):\n    stripe_user_access_token: str | None = None\n\n\nclass DeveloperRead(DeveloperBase, UserRead):\n    verification_requests: list[Verification] = Field(\n        schema_extra={\"permission\": \"self\"}  # TODO: implement auth in a base class\n    )\n    api_keys: list[APIKeyRead] = Field(schema_extra={\"view_privileges\": \"self\"})\n\n\nclass DeveloperUpdate(DeveloperBase, UserUpdate):\n    stripe_user_access_token: str | None = None\n\n\nclass Developer(DeveloperBase, User, table=True):\n    verification_requests: list[Verification] = Relationship(\n        back_populates=\"verification_requested_by\"\n    )\n    stripe_user_access_token: str | None = None\n    api_keys: list[APIKey]\n\n\ncrud_router = build_crud_endpoints(\n    t_model_base=DeveloperBase,\n    t_model_create=DeveloperCreate,\n    t_model_read=DeveloperRead,\n    t_model_update=DeveloperUpdate,\n    t_model_in_db=Developer,\n)\n</app/schema/user/developer.py>\n\n<app/schema/user/identity.py>\nfrom __future__ import annotations\n\nfrom abc import abstractmethod\nfrom datetime import datetime\nfrom enum import Enum\nfrom functools import cached_property\nfrom typing import ClassVar, Optional\n\nfrom pydantic.config import ConfigDict\nfrom sqlalchemy import Column, String, func\nfrom sqlalchemy.ext.hybrid import hybrid_column\nfrom sqlmodel import Field, Relationship, Session, SQLModel, delete, select\nfrom typing_extensions import Unpack\n\nfrom app.core.redis import get_redis_connection\nfrom app.schema.base import (\n    ModelBase,\n    ModelCreate,\n    ModelInDB,\n    ModelRead,\n    ModelUpdate,\n)\nfrom app.utils.crud import build_crud_endpoints\n\n\nclass IdentityBase(ModelBase):\n    pass\n\n\nclass IdentityCreate(IdentityBase, ModelCreate):\n    image: Optional[bytes]\n\n\nclass IdentityRead(IdentityBase, ModelRead):\n    id: int\n    image: Optional[bytes]\n\n\nclass IdentityUpdate(IdentityBase, ModelUpdate):\n    pass\n\n\nclass Identity(IdentityBase, ModelInDB, table=True):\n    id: int | None = Field(default=None, primary_key=True, autoincrement=True)\n    image: Optional[bytes]\n\n\ncrud_router = build_crud_endpoints(\n    t_model_base=IdentityBase,\n    t_model_create=IdentityCreate,\n    t_model_read=IdentityRead,\n    t_model_update=IdentityUpdate,\n    t_model_in_db=Identity,\n)\n</app/schema/user/identity.py>\n\n<app/schema/user/ghost_identity.py>\nfrom __future__ import annotations\n\nfrom abc import abstractmethod\nfrom datetime import datetime\nfrom enum import Enum\nfrom functools import cached_property\nfrom typing import ClassVar, Optional\n\nfrom pydantic.config import ConfigDict\nfrom sqlalchemy import Column, String, func\nfrom sqlalchemy.ext.hybrid import hybrid_column\nfrom sqlmodel import Field, Relationship, Session, SQLModel, delete, select\nfrom typing_extensions import Unpack\n\nfrom app.core.redis import get_redis_connection\nfrom app.schema.user.identity import (\n    IdentityBase,\n    IdentityCreate,\n    IdentityRead,\n    IdentityUpdate,\n    Identity,\n)\nfrom app.utils.crud import build_crud_endpoints\n\n\nclass GhostIdentityBase(IdentityBase):\n    pass\n\n\nclass GhostIdentityCreate(GhostIdentityBase, IdentityCreate):\n    pass\n\n\nclass GhostIdentityRead(IdentityRead):\n    pass\n\n\nclass GhostIdentityUpdate(GhostIdentityBase, IdentityUpdate):\n    pass\n\n\nclass GhostIdentity(GhostIdentityBase, Identity):\n    pass\n\n\ncrud_router = build_crud_endpoints(\n    t_model_base=GhostIdentityBase,\n    t_model_create=GhostIdentityCreate,\n    t_model_read=GhostIdentityRead,\n    t_model_update=GhostIdentityUpdate,\n    t_model_in_db=GhostIdentity,\n)\n</app/schema/user/ghost_identity.py>\n\n<app/schema/base.py>\nfrom __future__ import annotations\n\nfrom abc import abstractmethod\nfrom datetime import datetime\nfrom enum import Enum\nfrom functools import cached_property\nfrom typing import ClassVar, Literal, Optional\n\nfrom pydantic.config import ConfigDict\nfrom sqlalchemy import Column, String, func\nfrom sqlalchemy.ext.hybrid import hybrid_column\nfrom sqlmodel import Field, Relationship, Session, SQLModel, delete, select\nfrom typing_extensions import Unpack\n\nfrom app.core.redis import get_redis_connection\nfrom app.utils.errors import UnauthorizedUpdateError\n\n\nclass ModelBase(SQLModel):\n\n    ModelCreate: ClassVar[type[ModelCreate]]\n    ModelUpdate: ClassVar[type[ModelUpdate]]\n    ModelRead: ClassVar[type[ModelRead]]\n    ModelInDB: ClassVar[type[ModelInDB]]\n\n\nclass ModelCreate(ModelBase):\n    pass\n\n\nclass ModelUpdate(ModelBase):\n    class UpdatePrivileges(Enum):\n        owner = \"owner\"\n        authenticated = \"authenticated\"\n        public = \"public\"\n\n        def apply_privileges(\n            self,\n            model: ModelUpdate,\n            model_owner_id: int,\n            user_id: int,\n            unauthorized_update_response: Literal[\"raise\", \"none\"] = \"raise\",\n        ):\n            is_owner = model_owner_id == user_id\n            is_authenticated = user_id is not None\n            is_public = True\n\n            for k in model.model_fields:\n                match getattr(k, \"update_privileges\", None):\n                    case ModelUpdate.UpdatePrivileges.owner:\n                        if not is_owner:\n                            match unauthorized_update_response:\n                                case \"raise\":\n                                    raise UnauthorizedUpdateError(\n                                        f\"User {user_id} is not authorized to update {k} for {model_owner_id}\"\n                                    )\n                                case \"none\":\n                                    setattr(model, k, None)\n                                case _:\n                                    raise ValueError(\n                                        f\"Unauthorized update response {unauthorized_update_response} not supported\"\n                                    )\n                    case ModelUpdate.UpdatePrivileges.authenticated:\n                        if not is_authenticated:\n                            match unauthorized_update_response:\n                                case \"raise\":\n                                    raise UnauthorizedUpdateError(\n                                        f\"User {user_id} is not authenticated\"\n                                    )\n                                case \"none\":\n                                    setattr(model, k, None)\n                                case _:\n                                    raise ValueError(\n                                        f\"Unauthorized update response {unauthorized_update_response} not supported\"\n                                    )\n                    case ModelUpdate.UpdatePrivileges.public:\n                        if not is_public:\n                            match unauthorized_update_response:\n                                case \"raise\":\n                                    raise UnauthorizedUpdateError(\n                                        f\"User {user_id} is not authorized to update {k} for {model_owner_id}\"\n                                    )\n                                case \"none\":\n                                    setattr(model, k, None)\n                                case _:\n                                    raise ValueError(\n                                        f\"Unauthorized update response {unauthorized_update_response} not supported\"\n                                    )\n                    case _:\n                        pass\n\n            return model\n\n    pass\n\n\nclass ModelRead(ModelBase):\n    class ViewPrivileges(Enum):\n        owner = \"owner\"\n        authenticated = \"authenticated\"\n        public = \"public\"\n\n        def apply_privileges(self, model: ModelRead, model_owner_id: int, user_id: int):\n            is_owner = model_owner_id == user_id\n            is_authenticated = user_id is not None\n            is_public = True\n\n            for k in model.model_fields:\n                match getattr(k, \"view_privileges\", None):\n                    case ModelRead.ViewPrivileges.owner:\n                        if not is_owner:\n                            setattr(model, k, None)\n                    case ModelRead.ViewPrivileges.authenticated:\n                        if not is_authenticated:\n                            setattr(model, k, None)\n                    case ModelRead.ViewPrivileges.public:\n                        if not is_public:\n                            setattr(model, k, None)\n                    case _:\n                        pass\n\n    pass\n\n\nclass ModelInDB(ModelBase, table=True):\n    __tablename__ = \"entity\"\n    __mapper_args__ = {\n        \"polymorphic_identity\": \"entity\",  # base class identity\n        \"polymorphic_on\": type,  # specifying which field is the discriminator\n    }\n    type: str = Field(sa_column=Column(String), index=True, nullable=False)\n\n    def __init_subclass__(cls, **kwargs):\n        tablename = cls.__tablename__ or cls.__name__.lower()\n        mapper_args = getattr(cls, \"__mapper_args__\", {})\n        mapper_args.update({\"polymorphic_identity\": tablename})\n        setattr(cls, \"__mapper_args__\", mapper_args)\n        return super().__init_subclass__(**kwargs)\n\n    @classmethod\n    @abstractmethod\n    def get_ddl(cls) -> str:\n        # TODO: add constraints and security if applicable to all classes\n        pass\n\n    @staticmethod\n    def manually_run_all_ddl(session: Session):\n        for subclass in ModelInDB.__subclasses__():\n            session.execute(subclass.get_ddl())\n\n    @classmethod\n    def from_create(\n        cls,\n        model_create: ModelCreate,\n        session: Session,\n        user: \"User\" | None = None,\n        extra_keys: Optional[dict] = None,\n    ) -> ModelInDB:\n        db_entity = cls(**model_create.model_dump(), **(extra_keys or {}))\n        # subclasses wrap this and pass in extra keys needed for the indb model that are absent in the create model\n        session.add(db_entity)\n        session.commit()\n        return db_entity\n\n    def update_from(\n        self,\n        model_update: ModelUpdate,\n        session: Session,\n        user: \"User\" | None = None,\n    ) -> None:\n        model_update = ModelUpdate.UpdatePrivileges.apply_privileges(\n            model_update, self.id, user.id if user else None\n        )\n        self.sqlmodel_update(model_update.model_dump(exclude_unset=True))\n        session.commit()\n\n    def to_read(self, user: User | None = None) -> ModelRead:\n        model_read = self.ModelRead.model_validate(self)\n        model_read = ModelRead.ViewPrivileges.apply_privileges(\n            model_read, self.id, user.id if user else None\n        )\n        return model_read\n\n    # active record methods\n    def save(self, session: Session):\n        session.add(self)\n        session.commit()\n\n    def delete(self, session: Session):\n        session.delete(self)\n        session.commit()\n\n    @classmethod\n    def find_by_id(cls, id: int, session: Session):\n        sql = select(cls).where(cls.id == id)\n        return session.exec(sql).first()\n\n    @classmethod\n    def find_all(cls, session: Session):\n        sql = select(cls)\n        return session.exec(sql).all()\n\n    @classmethod\n    def find_by_ids(cls, ids: list[int], session: Session):\n        sql = select(cls).where(cls.id.in_(ids))\n        return session.exec(sql).all()\n\n    @classmethod\n    def find_by_id_or_raise(cls, id: int, session: Session):\n        entity = cls.find_by_id(id, session)\n        if not entity:\n            raise ValueError(f\"Entity {id} not found\")\n        return entity\n\n    @classmethod\n    def update_by_id(\n        cls,\n        id: int,\n        update_model: ModelUpdate,\n        session: Session,\n        commit=True,\n    ):\n        entity = cls.find_by_id_or_raise(id, session)\n        entity.sqlmodel_update(update_model.model_dump(exclude_unset=True))\n        if commit:\n            session.commit()\n        return entity\n\n    @classmethod\n    def update_by_ids(\n        cls,\n        ids: list[int],\n        update_model: ModelUpdate,\n        session: Session,\n        commit=True,\n    ):\n        entities = cls.find_by_ids(ids, session)\n        for entity in entities:\n            updated_entity = entity.update(\n                update_model.model_dump(exclude_unset=True), commit=False\n            )\n            session.add(updated_entity)\n        if commit:\n            session.commit()\n\n    @classmethod\n    def delete_by_id(cls, id: int, session: Session, commit=True):\n        entity = cls.find_by_id_or_raise(id, session)\n        entity.delete(session)\n        if commit:\n            session.commit()\n\n    @classmethod\n    def delete_by_ids(cls, ids: list[int], session: Session, commit=True):\n        for id in ids:\n            cls.delete_by_id(id, session, commit=False)\n        if commit:\n            session.commit()\n\n    @classmethod\n    def delete_all(cls, session: Session, commit=True):\n        sql = delete(cls)\n        session.exec(sql)\n        if commit:\n            session.commit()\n\n    @classmethod\n    def count(cls, session: Session):\n        sql = select(func.count()).select_from(cls)\n        return session.exec(sql).scalar()\n\n    @classmethod\n    def exists(cls, id: int, session: Session):\n        return cls.find_by_id(id, session) is not None\n\n    @classmethod\n    def exists_by_ids(cls, ids: list[int], session: Session):\n        return len(cls.find_by_ids(ids, session)) == len(ids)\n\n    @classmethod\n    def exists_all(cls, ids: list[int], session: Session):\n        return cls.exists_by_ids(ids, session)\n\n    @classmethod\n    def exists_any(cls, ids: list[int], session: Session):\n        return cls.exists_by_ids(ids, session)\n\n    @classmethod\n    def exists_none(cls, ids: list[int], session: Session):\n        return not cls.exists_by_ids(ids, session)\n</app/schema/base.py>\n\n<app/schema/verification/human_speech_verification.py>\nfrom __future__ import annotations\n\nfrom abc import abstractmethod\nfrom datetime import datetime\nfrom enum import Enum\nfrom functools import cached_property\nfrom typing import ClassVar, Optional\n\nfrom pydantic.config import ConfigDict\nfrom sqlalchemy import Column, String, func\nfrom sqlalchemy.ext.hybrid import hybrid_column\nfrom sqlmodel import Field, Relationship, Session, SQLModel, delete, select\nfrom typing_extensions import Unpack\n\nfrom app.core.redis import get_redis_connection\nfrom app.schema.verification.verification import (\n    Verification,\n    VerificationBase,\n    VerificationRead,\n    VerificationRequestBase,\n    VerificationUpdate,\n)\nfrom app.utils.crud import build_crud_endpoints\n\n\nclass HumanSpeechVerificationBase(VerificationBase):\n    model_name: str = \"human_speech_verification-001\"\n\n\nclass HumanSpeechVerificationRequest(\n    HumanSpeechVerificationBase, VerificationRequestBase\n):\n    pass\n\n\nclass HumanSpeechVerificationRead(HumanSpeechVerificationBase, VerificationRead):\n    model_name = Field(\n        \"human_speech_verification-001\",\n        schema_extra={\"view_privileges\": ModelRead.ViewPrivileges.owner},\n    )\n\n\nclass HumanSpeechVerificationUpdate(HumanSpeechVerificationBase, VerificationUpdate):\n    pass\n\n\nclass HumanSpeechVerification(HumanSpeechVerificationBase, Verification):\n    pass\n\n\ncrud_router = build_crud_endpoints(\n    t_model_base=HumanSpeechVerificationBase,\n    t_model_create=HumanSpeechVerificationRequest,\n    t_model_read=HumanSpeechVerificationRead,\n    t_model_update=HumanSpeechVerificationUpdate,\n    t_model_in_db=HumanSpeechVerification,\n)\n</app/schema/verification/human_speech_verification.py>\n\n<app/schema/verification/verification.py>\nfrom __future__ import annotations\n\nfrom abc import abstractmethod\nfrom datetime import datetime\nfrom enum import Enum\nfrom functools import cached_property\nfrom typing import ClassVar, Optional\n\nfrom pydantic.config import ConfigDict\nfrom sqlalchemy import Column, String, func\nfrom sqlalchemy.ext.hybrid import hybrid_column\nfrom sqlmodel import Field, Relationship, Session, SQLModel, delete, select\nfrom typing_extensions import Unpack\n\nfrom app.core.redis import get_redis_connection\nfrom app.schema.base import (\n    ModelBase,\n    ModelCreate,\n    ModelInDB,\n    ModelRead,\n    ModelUpdate,\n)\nfrom app.schema.has_redis import HasReddisChannel\nfrom app.schema.user.user import User\nfrom app.schema.user.developer import Developer, DeveloperRead\nfrom app.utils.crud import build_crud_endpoints\n\n\nclass VerificationStatus(Enum):\n    REQUESTED = \"requested\"\n    IN_PROGRESS = \"in_progress\"\n    VERIFIED = \"verified\"\n    FAILED = \"failed\"\n\n\nclass VerificationBase(ModelBase):\n    pass\n\n\n# TODO: change on_completion_webhook_url and on_completion_redirect_url to URLStr when sqlmodel supports it\nclass VerificationRequestBase(VerificationBase, ModelCreate):\n    who_to_verify_id: int\n    on_completion_webhook_url: str\n    on_completion_redirect_url: str | None = None\n\n\nclass VerificationRead(VerificationBase, ModelRead):\n    verification_requested_by_id: int\n    verification_requested_by: DeveloperRead\n    who_to_verify_id: int\n    who_to_verify: User\n    verf_status: VerificationStatus\n    on_completion_webhook_url: str\n    on_completion_redirect_url: str | None = None\n\n\nclass VerificationUpdate(VerificationBase, ModelUpdate):\n    on_completion_webhook_url: str\n    on_completion_redirect_url: str | None = None\n\n\nclass Verification(HasReddisChannel, VerificationBase, ModelInDB, table=True):\n    verification_requested_by_id: int\n    verification_requested_by: Developer\n    who_to_verify_id: int\n    who_to_verify: User\n    verf_status: VerificationStatus\n    on_completion_webhook_url: str\n    on_completion_redirect_url: str | None = None\n\n\ncrud_router = build_crud_endpoints(\n    t_model_base=VerificationBase,\n    t_model_create=VerificationRequestBase,\n    t_model_read=VerificationRead,\n    t_model_in_db=Verification,\n)\n</app/schema/verification/verification.py>\n\n<app/schema/verification/hand_sign_verification.py>\nfrom __future__ import annotations\n\nfrom abc import abstractmethod\nfrom datetime import datetime\nfrom enum import Enum\nfrom functools import cached_property\nfrom typing import ClassVar, Optional\n\nfrom pydantic.config import ConfigDict\nfrom sqlalchemy import Column, String, func\nfrom sqlalchemy.ext.hybrid import hybrid_column\nfrom sqlmodel import Field, Relationship, Session, SQLModel, delete, select\nfrom typing_extensions import Unpack\n\nfrom app.core.redis import get_redis_connection\nfrom app.schema.verification.verification import (\n    Verification,\n    VerificationBase,\n    VerificationRead,\n    VerificationUpdate,\n)\nfrom app.utils.crud import build_crud_endpoints\nfrom backend.app.schema.base import ModelRead\n\n\nclass HandSignVerificationBase(VerificationBase):\n    model_name: str = \"hand_sign_verification-001\"\n\n\nclass HandSignVerificationRequest(HandSignVerificationBase, VerificationRequestBase):\n    pass\n\n\nclass HandSignVerificationRead(HandSignVerificationBase, VerificationRead):\n    model_name = Field(\n        \"hand_sign_verification-001\",\n        schema_extra={\"view_privileges\": ModelRead.ViewPrivileges.owner},\n    )\n\n\nclass HandSignVerificationUpdate(HandSignVerificationBase, VerificationUpdate):\n    pass\n\n\nclass HandSignVerification(HandSignVerificationBase, Verification):\n    hand_letters: list[str]\n\n\ncrud_router = build_crud_endpoints(\n    t_model_base=HandSignVerificationBase,\n    t_model_create=HandSignVerificationRequest,\n    t_model_read=HandSignVerificationRead,\n    t_model_in_db=HandSignVerification,\n)\n</app/schema/verification/hand_sign_verification.py>\n\n<app/schema/verification/proof_of_id_verification.py>\nfrom __future__ import annotations\n\nfrom abc import abstractmethod\nfrom datetime import datetime\nfrom enum import Enum\nfrom functools import cached_property\nfrom typing import ClassVar, Optional\n\nfrom pydantic.config import ConfigDict\nfrom sqlalchemy import Column, String, func\nfrom sqlalchemy.ext.hybrid import hybrid_column\nfrom sqlmodel import Field, Relationship, Session, SQLModel, delete, select\nfrom typing_extensions import Unpack\n\nfrom app.core.redis import get_redis_connection\nfrom app.schema.verification.verification import (\n    Verification,\n    VerificationBase,\n    VerificationRead,\n    VerificationRequestBase,\n    VerificationUpdate,\n)\nfrom app.utils.crud import build_crud_endpoints\n\n\nclass ProofOfIDVerificationBase(VerificationBase):\n    pass\n\n\nclass ProofOfIDVerificationRequest(ProofOfIDVerificationBase, VerificationRequestBase):\n    pass\n\n\nclass ProofOfIDVerificationRead(ProofOfIDVerificationBase, VerificationRead):\n    pass\n\n\nclass ProofOfIDVerificationUpdate(ProofOfIDVerificationBase, VerificationUpdate):\n    pass\n\n\nclass ProofOfIDVerification(ProofOfIDVerificationBase, Verification):\n    pass\n\n\ncrud_router = build_crud_endpoints(\n    t_model_base=ProofOfIDVerificationBase,\n    t_model_create=ProofOfIDVerificationRequest,\n    t_model_read=ProofOfIDVerificationRead,\n    t_model_update=ProofOfIDVerificationUpdate,\n    t_model_in_db=ProofOfIDVerification,\n)\n</app/schema/verification/proof_of_id_verification.py>\n\n<app/schema/verification/credit_bureau_verification.py>\nfrom __future__ import annotations\n\nfrom abc import abstractmethod\nfrom datetime import datetime\nfrom enum import Enum\nfrom functools import cached_property\nfrom typing import ClassVar, Optional\n\nfrom pydantic.config import ConfigDict\nfrom sqlalchemy import Column, String, func\nfrom sqlalchemy.ext.hybrid import hybrid_column\nfrom sqlmodel import Field, Relationship, Session, SQLModel, delete, select\nfrom typing_extensions import Unpack\n\nfrom app.core.redis import get_redis_connection\nfrom app.schema.verification.verification import (\n    Verification,\n    VerificationBase,\n    VerificationRead,\n    VerificationUpdate,\n)\nfrom app.utils.crud import build_crud_endpoints\n\n\nclass CreditBureauVerificationBase(VerificationBase):\n    pass\n\n\nclass CreditBureauVerificationRequest(\n    CreditBureauVerificationBase, VerificationRequestBase\n):\n    pass\n\n\nclass CreditBureauVerificationRead(CreditBureauVerificationBase, VerificationRead):\n    pass\n\n\nclass CreditBureauVerificationUpdate(CreditBureauVerificationBase, VerificationUpdate):\n    pass\n\n\nclass CreditBureauVerification(CreditBureauVerificationBase, Verification):\n    pass\n\n\ncrud_router = build_crud_endpoints(\n    t_model_base=CreditBureauVerificationBase,\n    t_model_create=CreditBureauVerificationRequest,\n    t_model_read=CreditBureauVerificationRead,\n    t_model_update=CreditBureauVerificationUpdate,\n    t_model_in_db=CreditBureauVerification,\n)\n</app/schema/verification/credit_bureau_verification.py>\n\n<app/schema/verification/living_pupil_verification.py>\nfrom __future__ import annotations\n\nfrom abc import abstractmethod\nfrom datetime import datetime\nfrom enum import Enum\nfrom functools import cached_property\nfrom typing import ClassVar, Optional\n\nfrom pydantic.config import ConfigDict\nfrom sqlalchemy import Column, String, func\nfrom sqlalchemy.ext.hybrid import hybrid_column\nfrom sqlmodel import Field, Relationship, Session, SQLModel, delete, select\nfrom typing_extensions import Unpack\n\nfrom app.core.redis import get_redis_connection\nfrom app.schema.verification.verification import (\n    Verification,\n    VerificationBase,\n    VerificationRead,\n    VerificationRequestBase,\n    VerificationUpdate,\n)\nfrom app.utils.crud import build_crud_endpoints\n\n\nclass LivingPupilVerificationBase(VerificationBase):\n    model_name: str = \"living_pupil_verification-001\"\n\n\nclass LivingPupilVerificationRequest(\n    LivingPupilVerificationBase, VerificationRequestBase\n):\n    pass\n\n\nclass LivingPupilVerificationRead(LivingPupilVerificationBase, VerificationRead):\n    model_name = Field(\n        \"living_pupil_verification-001\",\n        schema_extra={\"view_privileges\": ModelRead.ViewPrivileges.owner},\n    )\n\n\nclass LivingPupilVerificationUpdate(LivingPupilVerificationBase, VerificationUpdate):\n    pass\n\n\nclass LivingPupilVerification(LivingPupilVerificationBase, Verification):\n    pass\n\n\ncrud_router = build_crud_endpoints(\n    router=router,\n    t_model_base=LivingPupilVerificationBase,\n    t_model_create=LivingPupilVerificationRequest,\n    t_model_read=LivingPupilVerificationRead,\n    t_model_update=LivingPupilVerificationUpdate,\n    t_model_in_db=LivingPupilVerification,\n)\n</app/schema/verification/living_pupil_verification.py>\n\n<app/schema/verification/face_video_anomaly_verification.py>\nfrom __future__ import annotations\n\nfrom abc import abstractmethod\nfrom datetime import datetime\nfrom enum import Enum\nfrom functools import cached_property\nfrom typing import ClassVar, Optional\n\nfrom pydantic.config import ConfigDict\nfrom sqlalchemy import Column, String, func\nfrom sqlalchemy.ext.hybrid import hybrid_column\nfrom sqlmodel import Field, Relationship, Session, SQLModel, delete, select\nfrom typing_extensions import Unpack\n\nfrom app.core.redis import get_redis_connection\nfrom app.schema.verification.verification import (\n    Verification,\n    VerificationBase,\n    VerificationRead,\n    VerificationUpdate,\n)\nfrom app.utils.crud import build_crud_endpoints\nfrom backend.app.schema.base import ModelRead\n\n\nclass FaceVideoAnomalyVerificationBase(VerificationBase):\n    model_name: str = \"face_video_anomaly_verification-001\"\n\n\nclass FaceVideoAnomalyVerificationRequest(\n    FaceVideoAnomalyVerificationBase, VerificationRequestBase\n):\n    pass\n\n\nclass FaceVideoAnomalyVerificationRead(\n    FaceVideoAnomalyVerificationBase, VerificationRead\n):\n    model_name: str = Field(\n        \"face_video_anomaly_verification-001\",\n        schema_extra={\"view_privileges\": ModelRead.ViewPrivileges.owner},\n    )\n\n\nclass FaceVideoAnomalyVerificationUpdate(\n    FaceVideoAnomalyVerificationBase, VerificationUpdate\n):\n    pass\n\n\nclass FaceVideoAnomalyVerification(Verification):\n    pass\n\n\ncrud_router = build_crud_endpoints(\n    t_model_base=FaceVideoAnomalyVerificationBase,\n    t_model_create=FaceVideoAnomalyVerificationRequest,\n    t_model_read=FaceVideoAnomalyVerificationRead,\n    t_model_update=FaceVideoAnomalyVerificationUpdate,\n    t_model_in_db=FaceVideoAnomalyVerification,\n)\n</app/schema/verification/face_video_anomaly_verification.py>\n\n<app/schema/system/api_key.py>\nfrom __future__ import annotations\n\nfrom datetime import datetime\n\nfrom sqlmodel import Field\nfrom app.schema.base import (\n    ModelBase,\n    ModelCreate,\n    ModelRead,\n    ModelUpdate,\n    ModelInDB,\n)\nfrom app.schema.system.api_key_use import APIKeyUseRead, APIKeyUse\nfrom app.schema.system.billing import Money\nfrom app.schema.user.developer import Developer, DeveloperRead\nfrom app.utils.crud import build_crud_endpoints\n\n\nclass APIKeyBase(ModelBase):\n    pass\n\n\nclass APIKeyCreate(APIKeyBase, ModelCreate):\n    name: str\n    description: str\n    spend_limit: Money.T\n    scopes: list[str]\n    expires_at: datetime\n\n\nclass APIKeyRead(APIKeyBase, ModelRead):\n    name: str\n    description: str\n    owner_id: int\n    owner: DeveloperRead\n    spend_limit: Money.T\n    scopes: list[str]\n    expires_at: datetime\n    truncated_secret: str\n    uses: list[APIKeyUseRead]\n\n\nclass APIKeyUpdate(APIKeyBase, ModelUpdate):\n    description: str\n    spend_limit: Money.T\n\n\nclass APIKey(APIKeyBase, ModelInDB):\n    name: str\n    description: str\n    created_at: datetime\n    expires_at: datetime\n    owner_id: int\n    owner: Developer\n    scopes: list[str]\n    uses: list[\"APIKeyUse\"]\n    spend_limit: Money.T\n    secret: str = Field(private=True)\n\n\ncrud_router = build_crud_endpoints(\n    t_model_base=APIKeyBase,\n    t_model_create=APIKeyCreate,\n    t_model_read=APIKeyRead,\n    t_model_update=APIKeyUpdate,\n    t_model_in_db=APIKey,\n)\n</app/schema/system/api_key.py>\n\n<app/schema/system/api_key_use.py>\nfrom __future__ import annotations\n\nfrom datetime import datetime\n\nfrom sqlmodel import Field\nfrom app.schema.base import (\n    ModelBase,\n    ModelCreate,\n    ModelRead,\n    ModelUpdate,\n    ModelInDB,\n)\nfrom app.schema.system.billing import Money\nfrom app.schema.user.developer import Developer, DeveloperRead\nfrom app.schema.system.api_key import APIKey, APIKeyRead\nfrom app.utils.crud import build_crud_endpoints\n\n\nclass APIKeyUseBase(ModelBase):\n    pass\n\n\nclass APIKeyUseRead(APIKeyUseBase, ModelRead):\n    api_key_id: int\n    api_key: APIKeyRead\n    timestamp: datetime\n    ip_address: str\n    user_agent: str\n    headers: dict[str, str]\n    path: str\n    method: str\n\n\nclass APIKeyUse(APIKeyUseBase, ModelInDB):\n    api_key_id: int\n    api_key: APIKey\n    timestamp: datetime\n    ip_address: str\n    user_agent: str\n    headers: dict[str, str]\n    path: str\n    method: str\n\n\ncrud_router = build_crud_endpoints(\n    t_model_base=APIKeyUseBase,\n    t_model_read=APIKeyUseRead,\n    t_model_in_db=APIKeyUse,\n)\n</app/schema/system/api_key_use.py>\n\n<app/schema/system/billing.py>\nfrom typing import ClassVar, Generic, TypeVar\nfrom attrs import define\n\nT = TypeVar(\"T\")\n\n\n@define\nclass Money(Generic[T]):\n    T: ClassVar[type] = int\n    currency: str = \"USD cents\"\n    amount: T\n\n\n# class Invoice(BaseModel):\n#     pass\n</app/schema/system/billing.py>\n\n<app/schema/system/auth.py>\nfrom __future__ import annotations\n\nfrom abc import abstractmethod\nfrom datetime import datetime\nfrom enum import Enum\nfrom functools import cached_property\nfrom typing import ClassVar, Optional\n\nfrom pydantic.config import ConfigDict\nfrom sqlalchemy import Column, String, func\nfrom sqlmodel import Field, Relationship, Session, SQLModel, delete, select\nfrom typing_extensions import Unpack\n\nfrom app.core.redis import get_redis_connection\nfrom app.schema.base import ModelBase\n\n\n# JSON payload containing access token\nclass Token(ModelBase):\n    access_token: str\n    token_type: str = \"bearer\"\n\n\n# Contents of JWT token\nclass TokenPayload(ModelBase):\n    sub: int | None = None\n\n\nclass NewPassword(ModelBase):\n    token: str\n    new_password: str\n</app/schema/system/auth.py>\n\n<app/schema/has_redis.py>\nfrom __future__ import annotations\n\nfrom abc import abstractmethod\nfrom datetime import datetime\nfrom enum import Enum\nfrom functools import cached_property\nfrom typing import ClassVar, Optional\n\nfrom pydantic.config import ConfigDict\nfrom sqlalchemy import Column, String, func\nfrom sqlalchemy.ext.hybrid import hybrid_column\nfrom sqlmodel import Field, Relationship, Session, SQLModel, delete, select\nfrom typing_extensions import Unpack\n\nfrom app.core.redis import get_redis_connection\nfrom app.schema.base import ModelInDB\n\n\nclass HasReddisChannel(ModelInDB):\n\n    @hybrid_column\n    def redis_channel_name(self):\n        return f\"redis_{self.__class__.__name__.lower()}_{self.id}\"\n\n    @redis_channel_name.expression\n    def redis_channel_name(cls):\n        from sqlalchemy import func\n\n        return func.concat(\"redis_\", func.lower(cls.__name__), \"_\", cls.id)\n\n    async def publish_message(self, message: str):\n        connection = await get_redis_connection()\n        await connection.publish(self.redis_channel_name, message)\n\n    @cached_property\n    async def redis_channel_listener(self):\n        connection = await get_redis_connection()\n        pubsub = connection.pubsub()\n        await pubsub.subscribe(self.redis_channel_name)\n        return pubsub\n\n    async def listen_for_messages(self, message_handler):\n        async for message in self.redis_channel_listener.listen():\n            if message[\"type\"] == \"message\":\n                await message_handler(message[\"data\"])\n</app/schema/has_redis.py>\n\n<app/schema/TODO>\nfor each file\n\n- put the other schema deps in a type checking enclosure so everyone felt comfortable\n- set view_privileges and update_privileges on all relevant fields\n- make sure we are only returning the minimum connected nested field values on read, otherwise we could end up with cyclic deps during quiery JSONification</app/schema/TODO>\n\n<app/__init__.py>\n</app/__init__.py>\n\n<app/tests/scripts/test_backend_pre_start.py>\nfrom unittest.mock import MagicMock, patch\n\nfrom sqlmodel import select\n\nfrom app.backend_pre_start import init, logger\n\n\ndef test_init_successful_connection() -> None:\n    engine_mock = MagicMock()\n\n    session_mock = MagicMock()\n    exec_mock = MagicMock(return_value=True)\n    session_mock.configure_mock(**{\"exec.return_value\": exec_mock})\n\n    with (\n        patch(\"sqlmodel.Session\", return_value=session_mock),\n        patch.object(logger, \"info\"),\n        patch.object(logger, \"error\"),\n        patch.object(logger, \"warn\"),\n    ):\n        try:\n            init(engine_mock)\n            connection_successful = True\n        except Exception:\n            connection_successful = False\n\n        assert (\n            connection_successful\n        ), \"The database connection should be successful and not raise an exception.\"\n\n        assert session_mock.exec.called_once_with(\n            select(1)\n        ), \"The session should execute a select statement once.\"\n</app/tests/scripts/test_backend_pre_start.py>\n\n<app/tests/scripts/test_test_pre_start.py>\nfrom unittest.mock import MagicMock, patch\n\nfrom sqlmodel import select\n\nfrom app.tests_pre_start import init, logger\n\n\ndef test_init_successful_connection() -> None:\n    engine_mock = MagicMock()\n\n    session_mock = MagicMock()\n    exec_mock = MagicMock(return_value=True)\n    session_mock.configure_mock(**{\"exec.return_value\": exec_mock})\n\n    with (\n        patch(\"sqlmodel.Session\", return_value=session_mock),\n        patch.object(logger, \"info\"),\n        patch.object(logger, \"error\"),\n        patch.object(logger, \"warn\"),\n    ):\n        try:\n            init(engine_mock)\n            connection_successful = True\n        except Exception:\n            connection_successful = False\n\n        assert (\n            connection_successful\n        ), \"The database connection should be successful and not raise an exception.\"\n\n        assert session_mock.exec.called_once_with(\n            select(1)\n        ), \"The session should execute a select statement once.\"\n</app/tests/scripts/test_test_pre_start.py>\n\n<app/tests/scripts/__init__.py>\n</app/tests/scripts/__init__.py>\n\n<app/tests/conftest.py>\nfrom collections.abc import Generator\n\nimport pytest\nfrom fastapi.testclient import TestClient\nfrom sqlmodel import Session, delete\n\nfrom app.core.config import settings\nfrom app.core.db import engine, init_db\nfrom app.main import fastapi_app\nfrom app.schema.proof_of_id_verification import Item, User\nfrom app.tests.utils.user import authentication_token_from_email\nfrom app.tests.utils.utils import get_superuser_token_headers\n\n\n@pytest.fixture(scope=\"session\", autouse=True)\ndef db() -> Generator[Session, None, None]:\n    with Session(engine) as session:\n        init_db(session)\n        yield session\n        statement = delete(Item)\n        session.execute(statement)\n        statement = delete(User)\n        session.execute(statement)\n        session.commit()\n\n\n@pytest.fixture(scope=\"module\")\ndef client() -> Generator[TestClient, None, None]:\n    with TestClient(fastapi_app) as c:\n        yield c\n\n\n@pytest.fixture(scope=\"module\")\ndef superuser_token_headers(client: TestClient) -> dict[str, str]:\n    return get_superuser_token_headers(client)\n\n\n@pytest.fixture(scope=\"module\")\ndef normal_user_token_headers(client: TestClient, db: Session) -> dict[str, str]:\n    return authentication_token_from_email(\n        client=client, email=settings.EMAIL_TEST_USER, db=db\n    )\n</app/tests/conftest.py>\n\n<app/tests/utils/item.py>\nfrom sqlmodel import Session\n\nfrom app import crud\nfrom app.schema.proof_of_id_verification import Item, ItemCreate\nfrom app.tests.utils.user import create_random_user\nfrom app.tests.utils.utils import random_lower_string\n\n\ndef create_random_item(db: Session) -> Item:\n    user = create_random_user(db)\n    owner_id = user.id\n    assert owner_id is not None\n    title = random_lower_string()\n    description = random_lower_string()\n    item_in = ItemCreate(title=title, description=description)\n    return crud.create_item(session=db, item_in=item_in, owner_id=owner_id)\n</app/tests/utils/item.py>\n\n<app/tests/utils/user.py>\nfrom fastapi.testclient import TestClient\nfrom sqlmodel import Session\n\nfrom app import crud\nfrom app.core.config import settings\nfrom app.schema.proof_of_id_verification import User, UserCreate, UserUpdate\nfrom app.tests.utils.utils import random_email, random_lower_string\n\n\ndef user_authentication_headers(\n    *, client: TestClient, email: str, password: str\n) -> dict[str, str]:\n    data = {\"username\": email, \"password\": password}\n\n    r = client.post(f\"{settings.API_V1_STR}/login/access-token\", data=data)\n    response = r.json()\n    auth_token = response[\"access_token\"]\n    headers = {\"Authorization\": f\"Bearer {auth_token}\"}\n    return headers\n\n\ndef create_random_user(db: Session) -> User:\n    email = random_email()\n    password = random_lower_string()\n    user_in = UserCreate(email=email, password=password)\n    user = crud.create_user(session=db, user_create=user_in)\n    return user\n\n\ndef authentication_token_from_email(\n    *, client: TestClient, email: str, db: Session\n) -> dict[str, str]:\n    \"\"\"\n    Return a valid token for the user with given email.\n\n    If the user doesn't exist it is created first.\n    \"\"\"\n    password = random_lower_string()\n    user = crud.get_user_by_email(session=db, email=email)\n    if not user:\n        user_in_create = UserCreate(email=email, password=password)\n        user = crud.create_user(session=db, user_create=user_in_create)\n    else:\n        user_in_update = UserUpdate(password=password)\n        if not user.id:\n            raise Exception(\"User id not set\")\n        user = crud.update_user(session=db, db_user=user, user_in=user_in_update)\n\n    return user_authentication_headers(client=client, email=email, password=password)\n</app/tests/utils/user.py>\n\n<app/tests/utils/utils.py>\nimport random\nimport string\n\nfrom fastapi.testclient import TestClient\n\nfrom app.core.config import settings\n\n\ndef random_lower_string() -> str:\n    return \"\".join(random.choices(string.ascii_lowercase, k=32))\n\n\ndef random_email() -> str:\n    return f\"{random_lower_string()}@{random_lower_string()}.com\"\n\n\ndef get_superuser_token_headers(client: TestClient) -> dict[str, str]:\n    login_data = {\n        \"username\": settings.FIRST_SUPERUSER,\n        \"password\": settings.FIRST_SUPERUSER_PASSWORD,\n    }\n    r = client.post(f\"{settings.API_V1_STR}/login/access-token\", data=login_data)\n    tokens = r.json()\n    a_token = tokens[\"access_token\"]\n    headers = {\"Authorization\": f\"Bearer {a_token}\"}\n    return headers\n</app/tests/utils/utils.py>\n\n<app/tests/utils/__init__.py>\n</app/tests/utils/__init__.py>\n\n<app/tests/api/routes/test_users.py>\nfrom unittest.mock import patch\n\nfrom fastapi.testclient import TestClient\nfrom sqlmodel import Session, select\n\nfrom app import crud\nfrom app.core.config import settings\nfrom app.core.security import verify_password\nfrom app.schema.proof_of_id_verification import User, UserCreate\nfrom app.tests.utils.utils import random_email, random_lower_string\n\n\ndef test_get_users_superuser_me(\n    client: TestClient, superuser_token_headers: dict[str, str]\n) -> None:\n    r = client.get(f\"{settings.API_V1_STR}/users/me\", headers=superuser_token_headers)\n    current_user = r.json()\n    assert current_user\n    assert current_user[\"is_active\"] is True\n    assert current_user[\"is_superuser\"]\n    assert current_user[\"email\"] == settings.FIRST_SUPERUSER\n\n\ndef test_get_users_normal_user_me(\n    client: TestClient, normal_user_token_headers: dict[str, str]\n) -> None:\n    r = client.get(f\"{settings.API_V1_STR}/users/me\", headers=normal_user_token_headers)\n    current_user = r.json()\n    assert current_user\n    assert current_user[\"is_active\"] is True\n    assert current_user[\"is_superuser\"] is False\n    assert current_user[\"email\"] == settings.EMAIL_TEST_USER\n\n\ndef test_create_user_new_email(\n    client: TestClient, superuser_token_headers: dict[str, str], db: Session\n) -> None:\n    with (\n        patch(\"app.utils.send_email\", return_value=None),\n        patch(\"app.core.config.settings.SMTP_HOST\", \"smtp.example.com\"),\n        patch(\"app.core.config.settings.SMTP_USER\", \"admin@example.com\"),\n    ):\n        username = random_email()\n        password = random_lower_string()\n        data = {\"email\": username, \"password\": password}\n        r = client.post(\n            f\"{settings.API_V1_STR}/users/\",\n            headers=superuser_token_headers,\n            json=data,\n        )\n        assert 200 <= r.status_code < 300\n        created_user = r.json()\n        user = crud.get_user_by_email(session=db, email=username)\n        assert user\n        assert user.email == created_user[\"email\"]\n\n\ndef test_get_existing_user(\n    client: TestClient, superuser_token_headers: dict[str, str], db: Session\n) -> None:\n    username = random_email()\n    password = random_lower_string()\n    user_in = UserCreate(email=username, password=password)\n    user = crud.create_user(session=db, user_create=user_in)\n    user_id = user.id\n    r = client.get(\n        f\"{settings.API_V1_STR}/users/{user_id}\",\n        headers=superuser_token_headers,\n    )\n    assert 200 <= r.status_code < 300\n    api_user = r.json()\n    existing_user = crud.get_user_by_email(session=db, email=username)\n    assert existing_user\n    assert existing_user.email == api_user[\"email\"]\n\n\ndef test_get_existing_user_current_user(client: TestClient, db: Session) -> None:\n    username = random_email()\n    password = random_lower_string()\n    user_in = UserCreate(email=username, password=password)\n    user = crud.create_user(session=db, user_create=user_in)\n    user_id = user.id\n\n    login_data = {\n        \"username\": username,\n        \"password\": password,\n    }\n    r = client.post(f\"{settings.API_V1_STR}/login/access-token\", data=login_data)\n    tokens = r.json()\n    a_token = tokens[\"access_token\"]\n    headers = {\"Authorization\": f\"Bearer {a_token}\"}\n\n    r = client.get(\n        f\"{settings.API_V1_STR}/users/{user_id}\",\n        headers=headers,\n    )\n    assert 200 <= r.status_code < 300\n    api_user = r.json()\n    existing_user = crud.get_user_by_email(session=db, email=username)\n    assert existing_user\n    assert existing_user.email == api_user[\"email\"]\n\n\ndef test_get_existing_user_permissions_error(\n    client: TestClient, normal_user_token_headers: dict[str, str]\n) -> None:\n    r = client.get(\n        f\"{settings.API_V1_STR}/users/999999\",\n        headers=normal_user_token_headers,\n    )\n    assert r.status_code == 403\n    assert r.json() == {\"detail\": \"The user doesn't have enough privileges\"}\n\n\ndef test_create_user_existing_username(\n    client: TestClient, superuser_token_headers: dict[str, str], db: Session\n) -> None:\n    username = random_email()\n    # username = email\n    password = random_lower_string()\n    user_in = UserCreate(email=username, password=password)\n    crud.create_user(session=db, user_create=user_in)\n    data = {\"email\": username, \"password\": password}\n    r = client.post(\n        f\"{settings.API_V1_STR}/users/\",\n        headers=superuser_token_headers,\n        json=data,\n    )\n    created_user = r.json()\n    assert r.status_code == 400\n    assert \"_id\" not in created_user\n\n\ndef test_create_user_by_normal_user(\n    client: TestClient, normal_user_token_headers: dict[str, str]\n) -> None:\n    username = random_email()\n    password = random_lower_string()\n    data = {\"email\": username, \"password\": password}\n    r = client.post(\n        f\"{settings.API_V1_STR}/users/\",\n        headers=normal_user_token_headers,\n        json=data,\n    )\n    assert r.status_code == 403\n\n\ndef test_retrieve_users(\n    client: TestClient, superuser_token_headers: dict[str, str], db: Session\n) -> None:\n    username = random_email()\n    password = random_lower_string()\n    user_in = UserCreate(email=username, password=password)\n    crud.create_user(session=db, user_create=user_in)\n\n    username2 = random_email()\n    password2 = random_lower_string()\n    user_in2 = UserCreate(email=username2, password=password2)\n    crud.create_user(session=db, user_create=user_in2)\n\n    r = client.get(f\"{settings.API_V1_STR}/users/\", headers=superuser_token_headers)\n    all_users = r.json()\n\n    assert len(all_users[\"data\"]) > 1\n    assert \"count\" in all_users\n    for item in all_users[\"data\"]:\n        assert \"email\" in item\n\n\ndef test_update_user_me(\n    client: TestClient, normal_user_token_headers: dict[str, str], db: Session\n) -> None:\n    full_name = \"Updated Name\"\n    email = random_email()\n    data = {\"full_name\": full_name, \"email\": email}\n    r = client.patch(\n        f\"{settings.API_V1_STR}/users/me\",\n        headers=normal_user_token_headers,\n        json=data,\n    )\n    assert r.status_code == 200\n    updated_user = r.json()\n    assert updated_user[\"email\"] == email\n    assert updated_user[\"full_name\"] == full_name\n\n    user_query = select(User).where(User.email == email)\n    user_db = db.exec(user_query).first()\n    assert user_db\n    assert user_db.email == email\n    assert user_db.full_name == full_name\n\n\ndef test_update_password_me(\n    client: TestClient, superuser_token_headers: dict[str, str], db: Session\n) -> None:\n    new_password = random_lower_string()\n    data = {\n        \"current_password\": settings.FIRST_SUPERUSER_PASSWORD,\n        \"new_password\": new_password,\n    }\n    r = client.patch(\n        f\"{settings.API_V1_STR}/users/me/password\",\n        headers=superuser_token_headers,\n        json=data,\n    )\n    assert r.status_code == 200\n    updated_user = r.json()\n    assert updated_user[\"message\"] == \"Password updated successfully\"\n\n    user_query = select(User).where(User.email == settings.FIRST_SUPERUSER)\n    user_db = db.exec(user_query).first()\n    assert user_db\n    assert user_db.email == settings.FIRST_SUPERUSER\n    assert verify_password(new_password, user_db.hashed_password)\n\n    # Revert to the old password to keep consistency in test\n    old_data = {\n        \"current_password\": new_password,\n        \"new_password\": settings.FIRST_SUPERUSER_PASSWORD,\n    }\n    r = client.patch(\n        f\"{settings.API_V1_STR}/users/me/password\",\n        headers=superuser_token_headers,\n        json=old_data,\n    )\n    db.refresh(user_db)\n\n    assert r.status_code == 200\n    assert verify_password(settings.FIRST_SUPERUSER_PASSWORD, user_db.hashed_password)\n\n\ndef test_update_password_me_incorrect_password(\n    client: TestClient, superuser_token_headers: dict[str, str]\n) -> None:\n    new_password = random_lower_string()\n    data = {\"current_password\": new_password, \"new_password\": new_password}\n    r = client.patch(\n        f\"{settings.API_V1_STR}/users/me/password\",\n        headers=superuser_token_headers,\n        json=data,\n    )\n    assert r.status_code == 400\n    updated_user = r.json()\n    assert updated_user[\"detail\"] == \"Incorrect password\"\n\n\ndef test_update_user_me_email_exists(\n    client: TestClient, normal_user_token_headers: dict[str, str], db: Session\n) -> None:\n    username = random_email()\n    password = random_lower_string()\n    user_in = UserCreate(email=username, password=password)\n    user = crud.create_user(session=db, user_create=user_in)\n\n    data = {\"email\": user.email}\n    r = client.patch(\n        f\"{settings.API_V1_STR}/users/me\",\n        headers=normal_user_token_headers,\n        json=data,\n    )\n    assert r.status_code == 409\n    assert r.json()[\"detail\"] == \"User with this email already exists\"\n\n\ndef test_update_password_me_same_password_error(\n    client: TestClient, superuser_token_headers: dict[str, str]\n) -> None:\n    data = {\n        \"current_password\": settings.FIRST_SUPERUSER_PASSWORD,\n        \"new_password\": settings.FIRST_SUPERUSER_PASSWORD,\n    }\n    r = client.patch(\n        f\"{settings.API_V1_STR}/users/me/password\",\n        headers=superuser_token_headers,\n        json=data,\n    )\n    assert r.status_code == 400\n    updated_user = r.json()\n    assert (\n        updated_user[\"detail\"] == \"New password cannot be the same as the current one\"\n    )\n\n\ndef test_register_user(client: TestClient, db: Session) -> None:\n    with patch(\"app.core.config.settings.USERS_OPEN_REGISTRATION\", True):\n        username = random_email()\n        password = random_lower_string()\n        full_name = random_lower_string()\n        data = {\"email\": username, \"password\": password, \"full_name\": full_name}\n        r = client.post(\n            f\"{settings.API_V1_STR}/users/signup\",\n            json=data,\n        )\n        assert r.status_code == 200\n        created_user = r.json()\n        assert created_user[\"email\"] == username\n        assert created_user[\"full_name\"] == full_name\n\n        user_query = select(User).where(User.email == username)\n        user_db = db.exec(user_query).first()\n        assert user_db\n        assert user_db.email == username\n        assert user_db.full_name == full_name\n        assert verify_password(password, user_db.hashed_password)\n\n\ndef test_register_user_forbidden_error(client: TestClient) -> None:\n    with patch(\"app.core.config.settings.USERS_OPEN_REGISTRATION\", False):\n        username = random_email()\n        password = random_lower_string()\n        full_name = random_lower_string()\n        data = {\"email\": username, \"password\": password, \"full_name\": full_name}\n        r = client.post(\n            f\"{settings.API_V1_STR}/users/signup\",\n            json=data,\n        )\n        assert r.status_code == 403\n        assert (\n            r.json()[\"detail\"] == \"Open user registration is forbidden on this server\"\n        )\n\n\ndef test_register_user_already_exists_error(client: TestClient) -> None:\n    with patch(\"app.core.config.settings.USERS_OPEN_REGISTRATION\", True):\n        password = random_lower_string()\n        full_name = random_lower_string()\n        data = {\n            \"email\": settings.FIRST_SUPERUSER,\n            \"password\": password,\n            \"full_name\": full_name,\n        }\n        r = client.post(\n            f\"{settings.API_V1_STR}/users/signup\",\n            json=data,\n        )\n        assert r.status_code == 400\n        assert (\n            r.json()[\"detail\"]\n            == \"The user with this email already exists in the system\"\n        )\n\n\ndef test_update_user(\n    client: TestClient, superuser_token_headers: dict[str, str], db: Session\n) -> None:\n    username = random_email()\n    password = random_lower_string()\n    user_in = UserCreate(email=username, password=password)\n    user = crud.create_user(session=db, user_create=user_in)\n\n    data = {\"full_name\": \"Updated_full_name\"}\n    r = client.patch(\n        f\"{settings.API_V1_STR}/users/{user.id}\",\n        headers=superuser_token_headers,\n        json=data,\n    )\n    assert r.status_code == 200\n    updated_user = r.json()\n\n    assert updated_user[\"full_name\"] == \"Updated_full_name\"\n\n    user_query = select(User).where(User.email == username)\n    user_db = db.exec(user_query).first()\n    db.refresh(user_db)\n    assert user_db\n    assert user_db.full_name == \"Updated_full_name\"\n\n\ndef test_update_user_not_exists(\n    client: TestClient, superuser_token_headers: dict[str, str]\n) -> None:\n    data = {\"full_name\": \"Updated_full_name\"}\n    r = client.patch(\n        f\"{settings.API_V1_STR}/users/99999999\",\n        headers=superuser_token_headers,\n        json=data,\n    )\n    assert r.status_code == 404\n    assert r.json()[\"detail\"] == \"The user with this id does not exist in the system\"\n\n\ndef test_update_user_email_exists(\n    client: TestClient, superuser_token_headers: dict[str, str], db: Session\n) -> None:\n    username = random_email()\n    password = random_lower_string()\n    user_in = UserCreate(email=username, password=password)\n    user = crud.create_user(session=db, user_create=user_in)\n\n    username2 = random_email()\n    password2 = random_lower_string()\n    user_in2 = UserCreate(email=username2, password=password2)\n    user2 = crud.create_user(session=db, user_create=user_in2)\n\n    data = {\"email\": user2.email}\n    r = client.patch(\n        f\"{settings.API_V1_STR}/users/{user.id}\",\n        headers=superuser_token_headers,\n        json=data,\n    )\n    assert r.status_code == 409\n    assert r.json()[\"detail\"] == \"User with this email already exists\"\n\n\ndef test_delete_user_me(client: TestClient, db: Session) -> None:\n    username = random_email()\n    password = random_lower_string()\n    user_in = UserCreate(email=username, password=password)\n    user = crud.create_user(session=db, user_create=user_in)\n    user_id = user.id\n\n    login_data = {\n        \"username\": username,\n        \"password\": password,\n    }\n    r = client.post(f\"{settings.API_V1_STR}/login/access-token\", data=login_data)\n    tokens = r.json()\n    a_token = tokens[\"access_token\"]\n    headers = {\"Authorization\": f\"Bearer {a_token}\"}\n\n    r = client.delete(\n        f\"{settings.API_V1_STR}/users/me\",\n        headers=headers,\n    )\n    assert r.status_code == 200\n    deleted_user = r.json()\n    assert deleted_user[\"message\"] == \"User deleted successfully\"\n    result = db.exec(select(User).where(User.id == user_id)).first()\n    assert result is None\n\n    user_query = select(User).where(User.id == user_id)\n    user_db = db.execute(user_query).first()\n    assert user_db is None\n\n\ndef test_delete_user_me_as_superuser(\n    client: TestClient, superuser_token_headers: dict[str, str]\n) -> None:\n    r = client.delete(\n        f\"{settings.API_V1_STR}/users/me\",\n        headers=superuser_token_headers,\n    )\n    assert r.status_code == 403\n    response = r.json()\n    assert response[\"detail\"] == \"Super users are not allowed to delete themselves\"\n\n\ndef test_delete_user_super_user(\n    client: TestClient, superuser_token_headers: dict[str, str], db: Session\n) -> None:\n    username = random_email()\n    password = random_lower_string()\n    user_in = UserCreate(email=username, password=password)\n    user = crud.create_user(session=db, user_create=user_in)\n    user_id = user.id\n    r = client.delete(\n        f\"{settings.API_V1_STR}/users/{user_id}\",\n        headers=superuser_token_headers,\n    )\n    assert r.status_code == 200\n    deleted_user = r.json()\n    assert deleted_user[\"message\"] == \"User deleted successfully\"\n    result = db.exec(select(User).where(User.id == user_id)).first()\n    assert result is None\n\n\ndef test_delete_user_not_found(\n    client: TestClient, superuser_token_headers: dict[str, str]\n) -> None:\n    r = client.delete(\n        f\"{settings.API_V1_STR}/users/99999999\",\n        headers=superuser_token_headers,\n    )\n    assert r.status_code == 404\n    assert r.json()[\"detail\"] == \"User not found\"\n\n\ndef test_delete_user_current_super_user_error(\n    client: TestClient, superuser_token_headers: dict[str, str], db: Session\n) -> None:\n    super_user = crud.get_user_by_email(session=db, email=settings.FIRST_SUPERUSER)\n    assert super_user\n    user_id = super_user.id\n\n    r = client.delete(\n        f\"{settings.API_V1_STR}/users/{user_id}\",\n        headers=superuser_token_headers,\n    )\n    assert r.status_code == 403\n    assert r.json()[\"detail\"] == \"Super users are not allowed to delete themselves\"\n\n\ndef test_delete_user_without_privileges(\n    client: TestClient, normal_user_token_headers: dict[str, str], db: Session\n) -> None:\n    username = random_email()\n    password = random_lower_string()\n    user_in = UserCreate(email=username, password=password)\n    user = crud.create_user(session=db, user_create=user_in)\n\n    r = client.delete(\n        f\"{settings.API_V1_STR}/users/{user.id}\",\n        headers=normal_user_token_headers,\n    )\n    assert r.status_code == 403\n    assert r.json()[\"detail\"] == \"The user doesn't have enough privileges\"\n</app/tests/api/routes/test_users.py>\n\n<app/tests/api/routes/test_items.py>\nfrom fastapi.testclient import TestClient\nfrom sqlmodel import Session\n\nfrom app.core.config import settings\nfrom app.tests.utils.item import create_random_item\n\n\ndef test_create_item(\n    client: TestClient, superuser_token_headers: dict[str, str]\n) -> None:\n    data = {\"title\": \"Foo\", \"description\": \"Fighters\"}\n    response = client.post(\n        f\"{settings.API_V1_STR}/items/\",\n        headers=superuser_token_headers,\n        json=data,\n    )\n    assert response.status_code == 200\n    content = response.json()\n    assert content[\"title\"] == data[\"title\"]\n    assert content[\"description\"] == data[\"description\"]\n    assert \"id\" in content\n    assert \"owner_id\" in content\n\n\ndef test_read_item(\n    client: TestClient, superuser_token_headers: dict[str, str], db: Session\n) -> None:\n    item = create_random_item(db)\n    response = client.get(\n        f\"{settings.API_V1_STR}/items/{item.id}\",\n        headers=superuser_token_headers,\n    )\n    assert response.status_code == 200\n    content = response.json()\n    assert content[\"title\"] == item.title\n    assert content[\"description\"] == item.description\n    assert content[\"id\"] == item.id\n    assert content[\"owner_id\"] == item.owner_id\n\n\ndef test_read_item_not_found(\n    client: TestClient, superuser_token_headers: dict[str, str]\n) -> None:\n    response = client.get(\n        f\"{settings.API_V1_STR}/items/999\",\n        headers=superuser_token_headers,\n    )\n    assert response.status_code == 404\n    content = response.json()\n    assert content[\"detail\"] == \"Item not found\"\n\n\ndef test_read_item_not_enough_permissions(\n    client: TestClient, normal_user_token_headers: dict[str, str], db: Session\n) -> None:\n    item = create_random_item(db)\n    response = client.get(\n        f\"{settings.API_V1_STR}/items/{item.id}\",\n        headers=normal_user_token_headers,\n    )\n    assert response.status_code == 400\n    content = response.json()\n    assert content[\"detail\"] == \"Not enough permissions\"\n\n\ndef test_read_items(\n    client: TestClient, superuser_token_headers: dict[str, str], db: Session\n) -> None:\n    create_random_item(db)\n    create_random_item(db)\n    response = client.get(\n        f\"{settings.API_V1_STR}/items/\",\n        headers=superuser_token_headers,\n    )\n    assert response.status_code == 200\n    content = response.json()\n    assert len(content[\"data\"]) >= 2\n\n\ndef test_update_item(\n    client: TestClient, superuser_token_headers: dict[str, str], db: Session\n) -> None:\n    item = create_random_item(db)\n    data = {\"title\": \"Updated title\", \"description\": \"Updated description\"}\n    response = client.put(\n        f\"{settings.API_V1_STR}/items/{item.id}\",\n        headers=superuser_token_headers,\n        json=data,\n    )\n    assert response.status_code == 200\n    content = response.json()\n    assert content[\"title\"] == data[\"title\"]\n    assert content[\"description\"] == data[\"description\"]\n    assert content[\"id\"] == item.id\n    assert content[\"owner_id\"] == item.owner_id\n\n\ndef test_update_item_not_found(\n    client: TestClient, superuser_token_headers: dict[str, str]\n) -> None:\n    data = {\"title\": \"Updated title\", \"description\": \"Updated description\"}\n    response = client.put(\n        f\"{settings.API_V1_STR}/items/999\",\n        headers=superuser_token_headers,\n        json=data,\n    )\n    assert response.status_code == 404\n    content = response.json()\n    assert content[\"detail\"] == \"Item not found\"\n\n\ndef test_update_item_not_enough_permissions(\n    client: TestClient, normal_user_token_headers: dict[str, str], db: Session\n) -> None:\n    item = create_random_item(db)\n    data = {\"title\": \"Updated title\", \"description\": \"Updated description\"}\n    response = client.put(\n        f\"{settings.API_V1_STR}/items/{item.id}\",\n        headers=normal_user_token_headers,\n        json=data,\n    )\n    assert response.status_code == 400\n    content = response.json()\n    assert content[\"detail\"] == \"Not enough permissions\"\n\n\ndef test_delete_item(\n    client: TestClient, superuser_token_headers: dict[str, str], db: Session\n) -> None:\n    item = create_random_item(db)\n    response = client.delete(\n        f\"{settings.API_V1_STR}/items/{item.id}\",\n        headers=superuser_token_headers,\n    )\n    assert response.status_code == 200\n    content = response.json()\n    assert content[\"message\"] == \"Item deleted successfully\"\n\n\ndef test_delete_item_not_found(\n    client: TestClient, superuser_token_headers: dict[str, str]\n) -> None:\n    response = client.delete(\n        f\"{settings.API_V1_STR}/items/999\",\n        headers=superuser_token_headers,\n    )\n    assert response.status_code == 404\n    content = response.json()\n    assert content[\"detail\"] == \"Item not found\"\n\n\ndef test_delete_item_not_enough_permissions(\n    client: TestClient, normal_user_token_headers: dict[str, str], db: Session\n) -> None:\n    item = create_random_item(db)\n    response = client.delete(\n        f\"{settings.API_V1_STR}/items/{item.id}\",\n        headers=normal_user_token_headers,\n    )\n    assert response.status_code == 400\n    content = response.json()\n    assert content[\"detail\"] == \"Not enough permissions\"\n</app/tests/api/routes/test_items.py>\n\n<app/tests/api/routes/__init__.py>\n</app/tests/api/routes/__init__.py>\n\n<app/tests/api/routes/test_login.py>\nfrom unittest.mock import patch\n\nfrom fastapi.testclient import TestClient\nfrom sqlmodel import Session, select\n\nfrom app.core.config import settings\nfrom app.core.security import verify_password\nfrom app.schema.proof_of_id_verification import User\nfrom app.utils import generate_password_reset_token\n\n\ndef test_get_access_token(client: TestClient) -> None:\n    login_data = {\n        \"username\": settings.FIRST_SUPERUSER,\n        \"password\": settings.FIRST_SUPERUSER_PASSWORD,\n    }\n    r = client.post(f\"{settings.API_V1_STR}/login/access-token\", data=login_data)\n    tokens = r.json()\n    assert r.status_code == 200\n    assert \"access_token\" in tokens\n    assert tokens[\"access_token\"]\n\n\ndef test_get_access_token_incorrect_password(client: TestClient) -> None:\n    login_data = {\n        \"username\": settings.FIRST_SUPERUSER,\n        \"password\": \"incorrect\",\n    }\n    r = client.post(f\"{settings.API_V1_STR}/login/access-token\", data=login_data)\n    assert r.status_code == 400\n\n\ndef test_use_access_token(\n    client: TestClient, superuser_token_headers: dict[str, str]\n) -> None:\n    r = client.post(\n        f\"{settings.API_V1_STR}/login/test-token\",\n        headers=superuser_token_headers,\n    )\n    result = r.json()\n    assert r.status_code == 200\n    assert \"email\" in result\n\n\ndef test_recovery_password(\n    client: TestClient, normal_user_token_headers: dict[str, str]\n) -> None:\n    with (\n        patch(\"app.core.config.settings.SMTP_HOST\", \"smtp.example.com\"),\n        patch(\"app.core.config.settings.SMTP_USER\", \"admin@example.com\"),\n    ):\n        email = \"test@example.com\"\n        r = client.post(\n            f\"{settings.API_V1_STR}/password-recovery/{email}\",\n            headers=normal_user_token_headers,\n        )\n        assert r.status_code == 200\n        assert r.json() == {\"message\": \"Password recovery email sent\"}\n\n\ndef test_recovery_password_user_not_exits(\n    client: TestClient, normal_user_token_headers: dict[str, str]\n) -> None:\n    email = \"jVgQr@example.com\"\n    r = client.post(\n        f\"{settings.API_V1_STR}/password-recovery/{email}\",\n        headers=normal_user_token_headers,\n    )\n    assert r.status_code == 404\n\n\ndef test_reset_password(\n    client: TestClient, superuser_token_headers: dict[str, str], db: Session\n) -> None:\n    token = generate_password_reset_token(email=settings.FIRST_SUPERUSER)\n    data = {\"new_password\": \"changethis\", \"token\": token}\n    r = client.post(\n        f\"{settings.API_V1_STR}/reset-password/\",\n        headers=superuser_token_headers,\n        json=data,\n    )\n    assert r.status_code == 200\n    assert r.json() == {\"message\": \"Password updated successfully\"}\n\n    user_query = select(User).where(User.email == settings.FIRST_SUPERUSER)\n    user = db.exec(user_query).first()\n    assert user\n    assert verify_password(data[\"new_password\"], user.hashed_password)\n\n\ndef test_reset_password_invalid_token(\n    client: TestClient, superuser_token_headers: dict[str, str]\n) -> None:\n    data = {\"new_password\": \"changethis\", \"token\": \"invalid\"}\n    r = client.post(\n        f\"{settings.API_V1_STR}/reset-password/\",\n        headers=superuser_token_headers,\n        json=data,\n    )\n    response = r.json()\n\n    assert \"detail\" in response\n    assert r.status_code == 400\n    assert response[\"detail\"] == \"Invalid token\"\n</app/tests/api/routes/test_login.py>\n\n<app/tests/api/__init__.py>\n</app/tests/api/__init__.py>\n\n<app/tests/__init__.py>\n</app/tests/__init__.py>\n\n<app/tests/crud/test_user.py>\nfrom fastapi.encoders import jsonable_encoder\nfrom sqlmodel import Session\n\nfrom app import crud\nfrom app.core.security import verify_password\nfrom app.schema.proof_of_id_verification import User, UserCreate, UserUpdate\nfrom app.tests.utils.utils import random_email, random_lower_string\n\n\ndef test_create_user(db: Session) -> None:\n    email = random_email()\n    password = random_lower_string()\n    user_in = UserCreate(email=email, password=password)\n    user = crud.create_user(session=db, user_create=user_in)\n    assert user.email == email\n    assert hasattr(user, \"hashed_password\")\n\n\ndef test_authenticate_user(db: Session) -> None:\n    email = random_email()\n    password = random_lower_string()\n    user_in = UserCreate(email=email, password=password)\n    user = crud.create_user(session=db, user_create=user_in)\n    authenticated_user = crud.authenticate(session=db, email=email, password=password)\n    assert authenticated_user\n    assert user.email == authenticated_user.email\n\n\ndef test_not_authenticate_user(db: Session) -> None:\n    email = random_email()\n    password = random_lower_string()\n    user = crud.authenticate(session=db, email=email, password=password)\n    assert user is None\n\n\ndef test_check_if_user_is_active(db: Session) -> None:\n    email = random_email()\n    password = random_lower_string()\n    user_in = UserCreate(email=email, password=password)\n    user = crud.create_user(session=db, user_create=user_in)\n    assert user.is_active is True\n\n\ndef test_check_if_user_is_active_inactive(db: Session) -> None:\n    email = random_email()\n    password = random_lower_string()\n    user_in = UserCreate(email=email, password=password, disabled=True)\n    user = crud.create_user(session=db, user_create=user_in)\n    assert user.is_active\n\n\ndef test_check_if_user_is_superuser(db: Session) -> None:\n    email = random_email()\n    password = random_lower_string()\n    user_in = UserCreate(email=email, password=password, is_superuser=True)\n    user = crud.create_user(session=db, user_create=user_in)\n    assert user.is_superuser is True\n\n\ndef test_check_if_user_is_superuser_normal_user(db: Session) -> None:\n    username = random_email()\n    password = random_lower_string()\n    user_in = UserCreate(email=username, password=password)\n    user = crud.create_user(session=db, user_create=user_in)\n    assert user.is_superuser is False\n\n\ndef test_get_user(db: Session) -> None:\n    password = random_lower_string()\n    username = random_email()\n    user_in = UserCreate(email=username, password=password, is_superuser=True)\n    user = crud.create_user(session=db, user_create=user_in)\n    user_2 = db.get(User, user.id)\n    assert user_2\n    assert user.email == user_2.email\n    assert jsonable_encoder(user) == jsonable_encoder(user_2)\n\n\ndef test_update_user(db: Session) -> None:\n    password = random_lower_string()\n    email = random_email()\n    user_in = UserCreate(email=email, password=password, is_superuser=True)\n    user = crud.create_user(session=db, user_create=user_in)\n    new_password = random_lower_string()\n    user_in_update = UserUpdate(password=new_password, is_superuser=True)\n    if user.id is not None:\n        crud.update_user(session=db, db_user=user, user_in=user_in_update)\n    user_2 = db.get(User, user.id)\n    assert user_2\n    assert user.email == user_2.email\n    assert verify_password(new_password, user_2.hashed_password)\n</app/tests/crud/test_user.py>\n\n<app/tests/crud/__init__.py>\n</app/tests/crud/__init__.py>\n\n<app/alembic/versions/.keep>\n</app/alembic/versions/.keep>\n\n<app/alembic/versions/e2412789c190_initialize_models.py>\n\"\"\"Initialize models\n\nRevision ID: e2412789c190\nRevises:\nCreate Date: 2023-11-24 22:55:43.195942\n\n\"\"\"\n\nimport sqlalchemy as sa\nimport sqlmodel.sql.sqltypes\nfrom alembic import op\n\n# revision identifiers, used by Alembic.\nrevision = \"e2412789c190\"\ndown_revision = None\nbranch_labels = None\ndepends_on = None\n\n\ndef upgrade():\n    # ### commands auto generated by Alembic - please adjust! ###\n    op.create_table(\n        \"user\",\n        sa.Column(\"email\", sqlmodel.sql.sqltypes.AutoString(), nullable=False),\n        sa.Column(\"is_active\", sa.Boolean(), nullable=False),\n        sa.Column(\"is_superuser\", sa.Boolean(), nullable=False),\n        sa.Column(\"full_name\", sqlmodel.sql.sqltypes.AutoString(), nullable=True),\n        sa.Column(\"id\", sa.Integer(), nullable=False),\n        sa.Column(\n            \"hashed_password\", sqlmodel.sql.sqltypes.AutoString(), nullable=False\n        ),\n        sa.PrimaryKeyConstraint(\"id\"),\n    )\n    op.create_index(op.f(\"ix_user_email\"), \"user\", [\"email\"], unique=True)\n    op.create_table(\n        \"item\",\n        sa.Column(\"description\", sqlmodel.sql.sqltypes.AutoString(), nullable=True),\n        sa.Column(\"id\", sa.Integer(), nullable=False),\n        sa.Column(\"title\", sqlmodel.sql.sqltypes.AutoString(), nullable=False),\n        sa.Column(\"owner_id\", sa.Integer(), nullable=False),\n        sa.ForeignKeyConstraint(\n            [\"owner_id\"],\n            [\"user.id\"],\n        ),\n        sa.PrimaryKeyConstraint(\"id\"),\n    )\n    # ### end Alembic commands ###\n\n\ndef downgrade():\n    # ### commands auto generated by Alembic - please adjust! ###\n    op.drop_table(\"item\")\n    op.drop_index(op.f(\"ix_user_email\"), table_name=\"user\")\n    op.drop_table(\"user\")\n    # ### end Alembic commands ###\n</app/alembic/versions/e2412789c190_initialize_models.py>\n\n<app/alembic/env.py>\nimport os\nfrom logging.config import fileConfig\n\nfrom alembic import context\nfrom sqlalchemy import engine_from_config, pool\n\n# this is the Alembic Config object, which provides\n# access to the values within the .ini file in use.\nconfig = context.config\n\n# Interpret the config file for Python logging.\n# This line sets up loggers basically.\nfileConfig(config.config_file_name)\n\n# add your model's MetaData object here\n# for 'autogenerate' support\n# from myapp import mymodel\n# target_metadata = mymodel.Base.metadata\n# target_metadata = None\n\nfrom app.schema.proof_of_id_verification import SQLModel  # noqa\n\ntarget_metadata = SQLModel.metadata\n\n# other values from the config, defined by the needs of env.py,\n# can be acquired:\n# my_important_option = config.get_main_option(\"my_important_option\")\n# ... etc.\n\n\ndef get_url():\n    user = os.getenv(\"POSTGRES_USER\", \"postgres\")\n    password = os.getenv(\"POSTGRES_PASSWORD\", \"\")\n    server = os.getenv(\"POSTGRES_SERVER\", \"db\")\n    port = os.getenv(\"POSTGRES_PORT\", \"5432\")\n    db = os.getenv(\"POSTGRES_DB\", \"app\")\n    return f\"postgresql+psycopg://{user}:{password}@{server}:{port}/{db}\"\n\n\ndef run_migrations_offline():\n    \"\"\"Run migrations in 'offline' mode.\n\n    This configures the context with just a URL\n    and not an Engine, though an Engine is acceptable\n    here as well.  By skipping the Engine creation\n    we don't even need a DBAPI to be available.\n\n    Calls to context.execute() here emit the given string to the\n    script output.\n\n    \"\"\"\n    url = get_url()\n    context.configure(\n        url=url, target_metadata=target_metadata, literal_binds=True, compare_type=True\n    )\n\n    with context.begin_transaction():\n        context.run_migrations()\n\n\ndef run_migrations_online():\n    \"\"\"Run migrations in 'online' mode.\n\n    In this scenario we need to create an Engine\n    and associate a connection with the context.\n\n    \"\"\"\n    configuration = config.get_section(config.config_ini_section)\n    configuration[\"sqlalchemy.url\"] = get_url()\n    connectable = engine_from_config(\n        configuration,\n        prefix=\"sqlalchemy.\",\n        poolclass=pool.NullPool,\n    )\n\n    with connectable.connect() as connection:\n        context.configure(\n            connection=connection, target_metadata=target_metadata, compare_type=True\n        )\n\n        with context.begin_transaction():\n            context.run_migrations()\n\n\nif context.is_offline_mode():\n    run_migrations_offline()\nelse:\n    run_migrations_online()\n</app/alembic/env.py>\n\n<app/alembic/script.py.mako>\n\"\"\"${message}\n\nRevision ID: ${up_revision}\nRevises: ${down_revision | comma,n}\nCreate Date: ${create_date}\n\n\"\"\"\nfrom alembic import op\nimport sqlalchemy as sa\nimport sqlmodel.sql.sqltypes\n${imports if imports else \"\"}\n\n# revision identifiers, used by Alembic.\nrevision = ${repr(up_revision)}\ndown_revision = ${repr(down_revision)}\nbranch_labels = ${repr(branch_labels)}\ndepends_on = ${repr(depends_on)}\n\n\ndef upgrade():\n    ${upgrades if upgrades else \"pass\"}\n\n\ndef downgrade():\n    ${downgrades if downgrades else \"pass\"}\n</app/alembic/script.py.mako>\n\n<app/alembic/README>\nGeneric single-database configuration.\n</app/alembic/README>\n\n<app/targets.py>\nimport os\nimport subprocess\nimport webbrowser\nfrom datetime import datetime\n\nimport typer\nimport uvicorn\n\nfrom app.core import logger\nfrom app.core.config import settings\nfrom app.core.db import create_db_and_tables, get_db, init_db, seed_db\nfrom app.main import fastapi_app\n\ncli = typer.Typer(\n    \"\"\"\\\n    # CLI Commands Documentation\n\n    ## Main Commands\n    - `serve`: Start the server on a specified host and port.\n\n    ## Info Commands\n    - `docs`: Show documentation.\n    - `code`: Show codebase.\n    - `status`: Check the status of the backend systems.\n    - `logs`: Fetch logs for the specified number of days.\n\n    ## Database Commands\n    - `init`: Initialize the database.\n    - `seed`: Seed the database with initial data.\n    - `backup`: Backup the database.\n    - `restore`: Restore the database from a backup.\n    - `migrate`: Migrate the database schema.\n\n    ## Development Commands\n    - `test`: Run tests.\n    - `deploy`: Deploy the application to a specified environment.\n    - `build`: Build the project.\n    \"\"\"\n)\n\n# Sub-command groups\ninfo_cli = typer.Typer()\ndb_cli = typer.Typer()\ndev_cli = typer.Typer()\n\n# Adding sub-command groups to the main CLI\ncli.add_typer(info_cli, name=\"info\")\ncli.add_typer(db_cli, name=\"db\")\ncli.add_typer(dev_cli, name=\"dev\")\n\n\n# Main command: serve\n@cli.command()\ndef serve(host: str = settings.HOST, port: int = settings.PORT):\n    uvicorn.run(fastapi_app, host=host, port=port)\n\n\n# Info group commands\n@info_cli.command()\ndef docs():\n    typer.echo(\"Showing documentation...\")\n    webbrowser.open(\"https://github.com/verifyhumans/gotcha-v2/tree/main/docs\")\n\n\n@info_cli.command()\ndef code():\n    typer.echo(\"Showing code...\")\n    webbrowser.open(\"https://github.com/verifyhumans/gotcha-v2\")\n\n\n@info_cli.command()\ndef status():\n    if settings.ENVIRONMENT == \"production\":\n        typer.echo(\"Running on production. Checking container health...\")\n        # Implement your container health check logic here\n        # This could be a script that checks Docker container statuses, for example:\n        os.system(\"docker ps --filter 'health=healthy'\")\n    else:\n        typer.echo(\"Not running in production environment.\")\n\n\n@info_cli.command()\ndef logs(days: int = 1):\n    typer.echo(f\"Fetching logs for the last {days} days.\")\n    typer.echo(\"Streaming logs (press Ctrl+C to stop)...\")\n    try:\n        subprocess.run([\"tail\", \"-f\", settings.LOG_FILE])\n    except KeyboardInterrupt:\n        typer.echo(\"Stopped streaming logs.\")\n\n\n# DB group commands\n@db_cli.command()\ndef drop(\n    confirm: bool = typer.Option(\n        False, \"--confirm\", prompt=\"Are you sure you want to drop the database?\"\n    )\n):\n    if confirm:\n        typer.echo(\"Dropping database...\")\n        with get_db() as db:\n            db.execute(f\"DROP DATABASE IF EXISTS {settings.POSTGRES_DB}\")\n        typer.echo(\"Database dropped.\")\n    else:\n        typer.echo(\"Database drop cancelled.\")\n\n\n@db_cli.command()\ndef init(session=typer.Depends(get_db)):\n    typer.echo(\"Initializing database...\")\n    init_db(session)\n    typer.echo(\"Database initialized.\")\n\n\n@db_cli.command()\ndef seed(session=typer.Depends(get_db)):\n    typer.echo(\"Seeding database...\")\n    seed_db(session)\n\n\n@db_cli.command()\ndef backup():\n    typer.echo(\"Backing up database...\")\n    raise NotImplementedError(\"Not implemented yet\")\n\n    db = get_db()\n    import os\n    import shutil\n    from datetime import datetime\n\n    backup_dir = settings.BACKUP_DIR\n    os.makedirs(backup_dir, exist_ok=True)\n    timestamp = datetime.now().strftime(\"%Y%m%d%H%M%S\")\n    backup_file = os.path.join(backup_dir, f\"db_backup_{timestamp}.sql\")\n\n    command = f\"pg_dump -h {settings.POSTGRES_SERVER} -p {settings.POSTGRES_PORT} -U {settings.POSTGRES_USER} -d {settings.POSTGRES_DB} -f {backup_file}\"\n    os.system(command)\n\n    # Optionally, compress the backup file\n    shutil.make_archive(backup_file, \"zip\", backup_dir, backup_file)\n    typer.echo(\"Database backed up.\")\n\n\n@db_cli.command()\ndef restore():\n    typer.echo(\"Restoring database from backup...\")\n    raise NotImplementedError(\"Not implemented yet\")\n\n    import os\n    from datetime import datetime\n    import shutil\n    from sqlmodel import Session\n\n    backup_dir = settings.BACKUP_DIR\n    latest_backup = max(\n        [\n            os.path.join(backup_dir, f)\n            for f in os.listdir(backup_dir)\n            if f.endswith(\".sql.zip\")\n        ],\n        default=None,\n        key=os.path.getctime,\n    )\n\n    if latest_backup:\n        typer.echo(f\"Restoring from {latest_backup}...\")\n        # Unzip the backup file\n        with zipfile.ZipFile(latest_backup, \"r\") as zip_ref:\n            zip_ref.extractall(backup_dir)\n\n        # Get the SQL file name from the zip file\n        sql_file = latest_backup.replace(\".zip\", \"\")\n\n        # Restore the database from the SQL file\n        command = f\"psql -h {settings.POSTGRES_SERVER} -p {settings.POSTGRES_PORT} -U {settings.POSTGRES_USER} -d {settings.POSTGRES_DB} -f {sql_file}\"\n        os.system(command)\n\n        # Clean up extracted files\n        os.remove(sql_file)\n        typer.echo(\"Database restored from backup.\")\n    else:\n        typer.echo(\"No backup file found.\")\n\n\n@db_cli.command()\ndef migrate():\n    typer.echo(\"Migrating database...\")\n\n    # TODO: use the alembic scripts\n    raise NotImplementedError(\"Not implemented yet\")\n\n\n# Dev group commands\n@dev_cli.command()\ndef test():\n    typer.echo(\"Running tests...\")\n    raise NotImplementedError(\"Not implemented yet\")\n\n\n@dev_cli.command()\ndef generate_docs():\n    typer.echo(\"Generating docs...\")\n    raise NotImplementedError(\"Not implemented yet\")\n\n\n@dev_cli.command()\ndef deploy(environment: str):\n    typer.echo(f\"Deploying to {environment}...\")\n    raise NotImplementedError(\"Not implemented yet\")\n\n\n@dev_cli.command()\ndef build():\n    typer.echo(\"Building project...\")\n    raise NotImplementedError(\"Not implemented yet\")\n\n\nif __name__ == \"__main__\":\n    cli()\n</app/targets.py>\n\nNow, write the etech spec on our backend, keeping in mind how important your spec will be for implementing the actual frontend"
                }
            ]
        },
        {
            "role": "assistant",
            "content": [
                {
                    "type": "text",
                    "text": "Tech Spec: Backend for FastAPI-based Identity Verification System\n\nObjective:\nThe goal is to create a robust and scalable backend system using FastAPI to support an identity verification application. The backend will provide API endpoints for user management, identity verification, and system administration. It will integrate with various identity verification algorithms and handle data storage and retrieval efficiently.\n\nTechnologies:\n- FastAPI: High-performance web framework for building APIs with Python\n- SQLModel: Library for interacting with databases using SQLAlchemy and Pydantic\n- Alembic: Database migration tool\n- Redis: In-memory data store for caching and real-time communication\n- JWT (JSON Web Tokens): Authentication and authorization mechanism\n- Pydantic: Data validation and serialization library\n- Docker: Containerization platform for easy deployment and scalability\n- PostgreSQL: Relational database for persistent data storage\n- RabbitMQ: Message broker for asynchronous communication and task queues\n\nBackend Structure:\nThe backend follows a modular structure with the following main components:\n- `app/api`: Contains the API routes and endpoints for user management, identity verification, and system administration.\n- `app/core`: Contains the core functionality, including database configuration, security utilities, and Redis integration.\n- `app/crud`: Contains the CRUD (Create, Read, Update, Delete) operations for interacting with the database.\n- `app/schemas`: Contains the Pydantic models and schemas for data validation and serialization.\n- `app/utils`: Contains utility functions for email handling, error handling, and other common tasks.\n- `app/algorithms`: Contains the implementation of various identity verification algorithms.\n- `app/tests`: Contains the unit tests for the backend components.\n\nAPI Endpoints:\nThe backend will expose the following main API endpoints:\n- User Management:\n  - User registration and authentication\n  - User profile management (update, delete)\n  - User roles and permissions\n- Identity Verification:\n  - Initiate identity verification request\n  - Upload identity documents (e.g., ID card, passport)\n  - Perform liveness detection and face matching\n  - Verify additional information (e.g., address, credit history)\n  - Retrieve verification status and results\n- System Administration:\n  - Manage API keys and access tokens\n  - Monitor system health and logs\n  - Configure verification settings and thresholds\n\nDatabase Design:\nThe database will be designed using SQLModel and will include the following main tables:\n- `User`: Stores user information, including email, password hash, and roles.\n- `IdentityVerification`: Stores identity verification requests and their status.\n- `Document`: Stores uploaded identity documents associated with verification requests.\n- `APIKey`: Stores API keys and their associated permissions.\n- `AuditLog`: Stores audit logs for user actions and system events.\n\nAuthentication and Authorization:\n- JWT will be used for authentication and authorization.\n- Users will obtain access tokens by providing their credentials (email and password).\n- Access tokens will be validated and used to authenticate and authorize API requests.\n- Role-based access control (RBAC) will be implemented to restrict access to certain endpoints based on user roles.\n\nCaching and Real-time Communication:\n- Redis will be used for caching frequently accessed data, such as user sessions and verification results.\n- Redis pub/sub mechanism will be utilized for real-time updates and notifications.\n\nIdentity Verification Algorithms:\n- The backend will integrate with various identity verification algorithms, such as:\n  - Face detection and recognition\n  - Liveness detection\n  - Optical Character Recognition (OCR) for document parsing\n  - Biometric matching (e.g., fingerprint, facial features)\n- The algorithms will be implemented in separate modules within the `app/algorithms` directory.\n\nTesting and Quality Assurance:\n- Unit tests will be written using pytest to ensure the correctness of individual components.\n- Integration tests will be performed to verify the interaction between different modules.\n- Continuous Integration and Continuous Deployment (CI/CD) pipelines will be set up to automate testing and deployment processes.\n\nDeployment and Scalability:\n- The backend will be containerized using Docker for easy deployment and scalability.\n- Docker Compose will be used for local development and testing.\n- The application will be deployed to a cloud platform (e.g., AWS, Google Cloud) for production.\n- Horizontal scaling will be achieved by running multiple instances of the backend services behind a load balancer.\n- Vertical scaling will be considered for resource-intensive tasks, such as image processing and machine learning algorithms.\n\nMonitoring and Logging:\n- Logging will be implemented throughout the backend to capture important events and errors.\n- Centralized logging solutions (e.g., ELK stack, Sentry) will be used to aggregate and analyze logs.\n- Monitoring tools (e.g., Prometheus, Grafana) will be set up to track system metrics and performance.\n\nSecurity Considerations:\n- Secure coding practices will be followed to prevent common vulnerabilities (e.g., SQL injection, XSS).\n- User passwords will be hashed and salted before storing in the database.\n- Sensitive data (e.g., API keys, access tokens) will be encrypted at rest and in transit.\n- Rate limiting and throttling mechanisms will be implemented to prevent abuse and protect against DDoS attacks.\n- Regular security audits and penetration testing will be conducted to identify and address potential vulnerabilities.\n\nIntegration with Frontend:\n- The backend will provide a well-documented API for the frontend to consume.\n- API documentation will be generated using tools like Swagger or ReDoc.\n- CORS (Cross-Origin Resource Sharing) will be properly configured to allow requests from authorized frontend domains.\n- WebSocket or server-sent events can be used for real-time updates and notifications to the frontend.\n\nMaintenance and Support:\n- A comprehensive documentation will be maintained, including API references, deployment instructions, and troubleshooting guides.\n- A ticketing system (e.g., Jira, GitHub Issues) will be used to track and manage bug reports, feature requests, and support inquiries.\n- Regular backups of the database and critical data will be scheduled and stored securely.\n- A disaster recovery plan will be put in place to ensure business continuity in case of any unforeseen events.\n\nBy following this tech spec, the backend system will provide a solid foundation for the identity verification application. It will handle user management, identity verification workflows, and system administration efficiently and securely. The modular architecture and scalable deployment options will allow for future growth and extensibility.\n\nRemember to continuously iterate and refine the backend based on feedback, performance metrics, and evolving business requirements. Regular code reviews, security audits, and performance optimizations should be conducted to maintain a high-quality and reliable backend system."
                }
            ]
        },
        {
            "role": "user",
            "content": [
                {
                    "type": "text",
                    "text": "Write the COMPLETE API spec. NO TRUNC! Make sure to include the crud endpinoints also. Concise --even terse-- dense technical spec. Enough to konw exactly how to interface from the frontend:\n\n"
                }
            ]
        },
        {
            "role": "assistant",
            "content": [
                {
                    "type": "text",
                    "text": "API Specification: Identity Verification System Backend\n\nBase URL: `https://api.example.com/v1`\n\nAuthentication:\n- All endpoints require authentication using JWT (JSON Web Tokens).\n- Obtain an access token by sending a POST request to `/auth/login` with user credentials.\n- Include the access token in the `Authorization` header of subsequent requests: `Bearer <access_token>`.\n\nEndpoints:\n\n1. User Management:\n   - `POST /users`: Register a new user.\n     - Request body: `{ \"email\": \"user@example.com\", \"password\": \"password123\", \"full_name\": \"John Doe\" }`\n     - Response: `{ \"id\": 1, \"email\": \"user@example.com\", \"full_name\": \"John Doe\", \"created_at\": \"2023-06-10T12:00:00Z\" }`\n\n   - `GET /users/{user_id}`: Get user details by ID.\n     - Response: `{ \"id\": 1, \"email\": \"user@example.com\", \"full_name\": \"John Doe\", \"created_at\": \"2023-06-10T12:00:00Z\" }`\n\n   - `PUT /users/{user_id}`: Update user details.\n     - Request body: `{ \"full_name\": \"Updated Name\" }`\n     - Response: `{ \"id\": 1, \"email\": \"user@example.com\", \"full_name\": \"Updated Name\", \"created_at\": \"2023-06-10T12:00:00Z\" }`\n\n   - `DELETE /users/{user_id}`: Delete a user.\n     - Response: `{ \"message\": \"User deleted successfully\" }`\n\n2. Identity Verification:\n   - `POST /verifications`: Initiate an identity verification request.\n     - Request body: `{ \"user_id\": 1, \"document_type\": \"passport\", \"document_front_image\": \"<base64_encoded_image>\", \"document_back_image\": \"<base64_encoded_image>\", \"selfie_image\": \"<base64_encoded_image>\" }`\n     - Response: `{ \"id\": 1, \"user_id\": 1, \"status\": \"pending\", \"created_at\": \"2023-06-10T12:00:00Z\" }`\n\n   - `GET /verifications/{verification_id}`: Get verification request details.\n     - Response: `{ \"id\": 1, \"user_id\": 1, \"status\": \"approved\", \"created_at\": \"2023-06-10T12:00:00Z\", \"updated_at\": \"2023-06-11T09:30:00Z\", \"result\": { \"face_match_score\": 0.95, \"liveness_score\": 0.98, \"document_validity\": true } }`\n\n   - `GET /users/{user_id}/verifications`: Get all verification requests for a user.\n     - Response: `[ { \"id\": 1, \"user_id\": 1, \"status\": \"approved\", \"created_at\": \"2023-06-10T12:00:00Z\", \"updated_at\": \"2023-06-11T09:30:00Z\" }, { \"id\": 2, \"user_id\": 1, \"status\": \"rejected\", \"created_at\": \"2023-06-12T15:45:00Z\", \"updated_at\": \"2023-06-13T10:15:00Z\" } ]`\n\n3. System Administration:\n   - `POST /api-keys`: Generate a new API key.\n     - Request body: `{ \"name\": \"Mobile App\", \"permissions\": [\"read\", \"write\"] }`\n     - Response: `{ \"id\": 1, \"name\": \"Mobile App\", \"key\": \"abc123xyz\", \"permissions\": [\"read\", \"write\"], \"created_at\": \"2023-06-10T12:00:00Z\" }`\n\n   - `GET /api-keys`: Get all API keys.\n     - Response: `[ { \"id\": 1, \"name\": \"Mobile App\", \"permissions\": [\"read\", \"write\"], \"created_at\": \"2023-06-10T12:00:00Z\" }, { \"id\": 2, \"name\": \"Web App\", \"permissions\": [\"read\"], \"created_at\": \"2023-06-11T09:30:00Z\" } ]`\n\n   - `DELETE /api-keys/{api_key_id}`: Revoke an API key.\n     - Response: `{ \"message\": \"API key revoked successfully\" }`\n\n   - `GET /logs`: Get system logs.\n     - Query parameters:\n       - `from`: Start date (e.g., `2023-06-01`)\n       - `to`: End date (e.g., `2023-06-30`)\n       - `level`: Log level (e.g., `info`, `error`)\n     - Response: `[ { \"timestamp\": \"2023-06-10T12:00:00Z\", \"level\": \"info\", \"message\": \"User registered: user@example.com\" }, { \"timestamp\": \"2023-06-11T09:30:00Z\", \"level\": \"error\", \"message\": \"Verification failed for user ID: 1\" } ]`\n\n4. CRUD Operations:\n   - Users:\n     - `GET /users`: Get all users.\n       - Query parameters:\n         - `page`: Page number (default: 1)\n         - `per_page`: Number of users per page (default: 10)\n       - Response: `{ \"data\": [ { \"id\": 1, \"email\": \"user1@example.com\", \"full_name\": \"John Doe\", \"created_at\": \"2023-06-10T12:00:00Z\" }, { \"id\": 2, \"email\": \"user2@example.com\", \"full_name\": \"Jane Smith\", \"created_at\": \"2023-06-11T09:30:00Z\" } ], \"meta\": { \"current_page\": 1, \"per_page\": 10, \"total_pages\": 2, \"total_count\": 15 } }`\n\n   - Verifications:\n     - `GET /verifications`: Get all verification requests.\n       - Query parameters:\n         - `page`: Page number (default: 1)\n         - `per_page`: Number of verifications per page (default: 10)\n         - `status`: Filter by verification status (e.g., `pending`, `approved`, `rejected`)\n       - Response: `{ \"data\": [ { \"id\": 1, \"user_id\": 1, \"status\": \"approved\", \"created_at\": \"2023-06-10T12:00:00Z\", \"updated_at\": \"2023-06-11T09:30:00Z\" }, { \"id\": 2, \"user_id\": 2, \"status\": \"pending\", \"created_at\": \"2023-06-12T15:45:00Z\" } ], \"meta\": { \"current_page\": 1, \"per_page\": 10, \"total_pages\": 1, \"total_count\": 8 } }`\n\n     - `PUT /verifications/{verification_id}`: Update a verification request.\n       - Request body: `{ \"status\": \"approved\", \"result\": { \"face_match_score\": 0.95, \"liveness_score\": 0.98, \"document_validity\": true } }`\n       - Response: `{ \"id\": 1, \"user_id\": 1, \"status\": \"approved\", \"created_at\": \"2023-06-10T12:00:00Z\", \"updated_at\": \"2023-06-11T09:30:00Z\", \"result\": { \"face_match_score\": 0.95, \"liveness_score\": 0.98, \"document_validity\": true } }`\n\n     - `DELETE /verifications/{verification_id}`: Delete a verification request.\n       - Response: `{ \"message\": \"Verification request deleted successfully\" }`\n\n   - API Keys:\n     - `GET /api-keys/{api_key_id}`: Get API key details.\n       - Response: `{ \"id\": 1, \"name\": \"Mobile App\", \"permissions\": [\"read\", \"write\"], \"created_at\": \"2023-06-10T12:00:00Z\" }`\n\n     - `PUT /api-keys/{api_key_id}`: Update an API key.\n       - Request body: `{ \"name\": \"Updated Name\", \"permissions\": [\"read\"] }`\n       - Response: `{ \"id\": 1, \"name\": \"Updated Name\", \"permissions\": [\"read\"], \"created_at\": \"2023-06-10T12:00:00Z\" }`\n\nError Responses:\n- `400 Bad Request`: Invalid request data or missing required fields.\n- `401 Unauthorized`: Missing or invalid access token.\n- `403 Forbidden`: Insufficient permissions to access the resource.\n- `404 Not Found`: Requested resource not found.\n- `500 Internal Server Error`: Unexpected server error.\n\nWebhooks:\n- The backend can send webhook notifications to a configured URL for important events, such as:\n  - Verification request status changes (e.g., pending, approved, rejected)\n  - Suspicious activity detected (e.g., multiple failed verification attempts)\n- Webhook payload example:\n  ```json\n  {\n    \"event\": \"verification_status_changed\",\n    \"data\": {\n      \"id\": 1,\n      \"user_id\": 1,\n      \"status\": \"approved\",\n      \"created_at\": \"2023-06-10T12:00:00Z\",\n      \"updated_at\": \"2023-06-11T09:30:00Z\"\n    }\n  }\n  ```\n\nReal-time Updates:\n- The backend can provide real-time updates using WebSocket or server-sent events (SSE) for:\n  - Verification request progress (e.g., document processing, face matching)\n  - Live notifications (e.g., new verification request, system alerts)\n\nThis API specification provides a comprehensive overview of the endpoints, request/response formats, and additional features of the identity verification system backend. It covers user management, identity verification, system administration, CRUD operations, error handling, webhooks, and real-time updates.\n\nDevelopers can use this specification as a reference to integrate with the backend and build frontend applications or other services that interact with the identity verification system."
                }
            ]
        },
        {
            "role": "user",
            "content": [
                {
                    "type": "text",
                    "text": "Here's the frontend tech requirements:\n\n# GOTCHA - Graphical Online Turing test to Confirm Human Activity\n\n## Tech Stack\n\n- Frontend: Vite web app, React with TypeScript for development, TanStack state management and routing, styled with Chakra.\n\n- Backend: FastAPI + Uvicorn server. CRUD, video streaming, authentication and authorization, SQLModel ORM, retry and validation, and more.\n\n## Pages\n\nAuth:\n\n- Login\n- Register\n- Forgot Password\n- Reset Password\n\nAccount:\n\n- Verify Email\n- Playground\n  - interactive test environment with embeddable form\n  - copy the playground form code here\n  - get api keys\n  - sidebar shows of activity\n- Activity\n  - all verification\n- Billing\n  - history\n  - projections\n- API Keys\n  - list of keys\n  - expands to show all api key uses for each key\n- Settings\n  - change name\n  - change email\n  - change password\n  - export data\n  - delete account\n\nVerification:\n\n- Verification Request\n  - this is the page the use lands on when the system requests verification\n  - the user can choose to verify or decline\n  - if the user chooses to verify, the system will send the user to the verification page\n\nPublic:\n\n- Landing (index)\n  - try out our embedded verf gotcha system on the top of the homepage\n  - 3 features tailored to our audience\n  - pricing\n  - contact us (lead funnel)\n  - footer (copyright, company name, socials, privacy policy, ToS, etc)\n- Privacy Policy\n- Terms of Service\n\nDocumentation:\n\n- Concepts\n- API Reference\n- Tutorial\n- Contribute\n\n\nNow, write a full stack summary of what the frontend architecture tech spec should be to conform to the backend:"
                }
            ]
        },
        {
            "role": "assistant",
            "content": [
                {
                    "type": "text",
                    "text": "Frontend Architecture Tech Spec\n\n1. Overview\n   - The frontend will be built using Vite, a fast build tool and development server, with React and TypeScript for creating a highly interactive and responsive user interface.\n   - TanStack will be used for efficient state management and routing within the application.\n   - Chakra UI will be utilized for styling and creating a visually appealing and consistent design system.\n\n2. Project Structure\n   - The project will follow a modular and component-based structure to ensure code reusability and maintainability.\n   - The main components of the project will include:\n     - `src/`: Contains the main source code of the application.\n       - `components/`: Reusable UI components used throughout the application.\n       - `pages/`: Top-level components representing different pages or routes.\n       - `services/`: Services for making API requests to the backend.\n       - `utils/`: Utility functions and helpers.\n       - `styles/`: Global styles and Chakra UI theme configuration.\n       - `types/`: TypeScript type definitions.\n     - `public/`: Contains public assets such as images, fonts, and favicon.\n     - `tests/`: Contains unit tests and integration tests for the frontend components.\n\n3. State Management\n   - TanStack Query will be used for efficient data fetching, caching, and synchronization with the backend API.\n   - TanStack Query will handle the management of asynchronous data, including loading states, error handling, and pagination.\n   - For global state management, if required, TanStack Query can be used in conjunction with libraries like Zustand or Recoil.\n\n4. Routing\n   - TanStack Router will be used for declarative and type-safe routing within the application.\n   - The router will handle navigation between different pages and components based on the defined routes.\n   - Protected routes will be implemented to ensure authenticated access to certain pages, such as the account and verification pages.\n\n5. API Integration\n   - The frontend will communicate with the backend API using HTTP requests.\n   - Axios or the built-in `fetch` API can be used to make API requests to the backend endpoints.\n   - The frontend will handle authentication by storing and sending JWT tokens in the request headers.\n   - API requests will be made to the appropriate backend endpoints for user management, identity verification, and other functionalities.\n\n6. Form Handling\n   - Formik or React Hook Form can be used for efficient form handling and validation.\n   - Form submissions will be handled asynchronously, with proper error handling and user feedback.\n   - Form data will be sent to the backend API for processing and storage.\n\n7. WebSocket Integration\n   - For real-time updates and notifications, the frontend will establish a WebSocket connection with the backend.\n   - Libraries like Socket.IO or native WebSocket API can be used for seamless communication between the frontend and backend.\n   - Real-time updates can be displayed to the user for verification progress, live notifications, and other relevant information.\n\n8. Testing\n   - The frontend will be thoroughly tested using a combination of unit tests and integration tests.\n   - Testing frameworks like Jest and React Testing Library can be used for writing and running tests.\n   - Tests will cover critical components, user interactions, and edge cases to ensure the stability and reliability of the application.\n\n9. Deployment\n   - The frontend will be deployed as a static web application to a hosting platform like Netlify, Vercel, or AWS S3.\n   - Continuous Integration and Continuous Deployment (CI/CD) pipelines will be set up to automatically build, test, and deploy the frontend application whenever changes are pushed to the repository.\n\n10. Performance Optimization\n    - Code splitting and lazy loading techniques will be employed to optimize the loading performance of the application.\n    - Caching mechanisms, such as service workers or local storage, can be utilized to improve the performance of repeated API requests.\n    - Performance monitoring tools like Lighthouse or WebPageTest can be used to identify and address performance bottlenecks.\n\n11. Accessibility\n    - The frontend will follow accessibility best practices to ensure that the application is usable by a wide range of users, including those with disabilities.\n    - ARIA attributes, keyboard navigation, and proper semantic HTML will be used to enhance accessibility.\n    - Accessibility testing tools like axe or Lighthouse can be used to identify and fix accessibility issues.\n\n12. Security\n    - The frontend will implement security best practices to protect user data and prevent unauthorized access.\n    - User input will be properly validated and sanitized to prevent cross-site scripting (XSS) attacks.\n    - Secure communication protocols (HTTPS) will be used for all API requests to encrypt data in transit.\n    - Authentication and authorization mechanisms will be implemented to ensure that only authorized users can access protected resources.\n\n13. Error Handling and Logging\n    - Proper error handling and user-friendly error messages will be implemented to provide a smooth user experience.\n    - Error boundaries will be used to catch and handle errors gracefully, preventing the entire application from crashing.\n    - Logging mechanisms, such as console logs or third-party logging services, can be used to track and diagnose issues in production.\n\n14. Internationalization (i18n)\n    - If required, the frontend will support internationalization to cater to users from different regions and languages.\n    - Libraries like react-intl or i18next can be used to manage translations and localize the application.\n\n15. Documentation\n    - Comprehensive documentation will be maintained for the frontend codebase, including component usage, API integration, and deployment instructions.\n    - Code comments and inline documentation will be used to provide clarity and context for developers working on the project.\n    - User documentation, such as guides and tutorials, will be created to help users navigate and use the application effectively.\n\nBy following this frontend architecture tech spec, the application will be built using modern web technologies and best practices. The combination of Vite, React, TypeScript, TanStack, and Chakra UI will enable the creation of a highly interactive, performant, and visually appealing user interface.\n\nThe modular structure, efficient state management, and seamless integration with the backend API will ensure a smooth development process and a robust application. Testing, performance optimization, accessibility, and security considerations will be given high priority to deliver a reliable and user-friendly experience.\n\nRegular code reviews, performance monitoring, and iterative improvements based on user feedback will be conducted to maintain and enhance the quality of the frontend application over time."
                }
            ]
        },
        {
            "role": "user",
            "content": [
                {
                    "type": "text",
                    "text": "Write a more detailed frontend spec. so detailed that we can hand this to an LLM and it could writ the frontend for us. one file at a time. define each file and what need s to be written in deta5il and any relvent details:\n"
                }
            ]
        },
        {
            "role": "assistant",
            "content": [
                {
                    "type": "text",
                    "text": "Frontend Detailed Specification\n\n1. `src/main.tsx`\n   - This is the entry point of the application.\n   - It sets up the React application, including the root component, router, and any necessary providers.\n   - It initializes the Chakra UI theme and any global styles.\n   - It configures the TanStack Query client and any other necessary libraries.\n   - It renders the root component and mounts it to the DOM.\n\n2. `src/App.tsx`\n   - This is the root component of the application.\n   - It sets up the main layout and structure of the application.\n   - It includes the main navigation component and any global components, such as headers or footers.\n   - It defines the routes and their corresponding components using TanStack Router.\n   - It handles any global state management, if required.\n\n3. `src/components/Navigation.tsx`\n   - This component represents the main navigation menu of the application.\n   - It includes links to different pages or sections of the application, such as Home, Account, Verification, and Documentation.\n   - It handles the active state of the navigation items based on the current route.\n   - It uses Chakra UI components for styling and layout.\n\n4. `src/components/Footer.tsx`\n   - This component represents the footer section of the application.\n   - It includes copyright information, company name, social media links, and links to important pages like Privacy Policy and Terms of Service.\n   - It uses Chakra UI components for styling and layout.\n\n5. `src/pages/Home.tsx`\n   - This component represents the home page of the application.\n   - It includes a hero section with a call-to-action button and a brief description of the application.\n   - It showcases the key features and benefits of the application, tailored to the target audience.\n   - It includes pricing information and a contact form for lead generation.\n   - It uses Chakra UI components for styling and layout.\n\n6. `src/pages/Login.tsx`\n   - This component represents the login page of the application.\n   - It includes a form with input fields for email and password.\n   - It handles form submission and sends a request to the backend API for authentication.\n   - It displays error messages for invalid credentials or authentication failures.\n   - It redirects the user to the appropriate page upon successful login.\n   - It uses Chakra UI components for styling and layout.\n\n7. `src/pages/Register.tsx`\n   - This component represents the registration page of the application.\n   - It includes a form with input fields for name, email, password, and any other required information.\n   - It handles form submission and sends a request to the backend API for user registration.\n   - It displays error messages for invalid input or registration failures.\n   - It redirects the user to the login page or a confirmation page upon successful registration.\n   - It uses Chakra UI components for styling and layout.\n\n8. `src/pages/ForgotPassword.tsx`\n   - This component represents the forgot password page of the application.\n   - It includes a form with an input field for the user's email address.\n   - It handles form submission and sends a request to the backend API to initiate the password reset process.\n   - It displays a success message or error message based on the response from the backend.\n   - It uses Chakra UI components for styling and layout.\n\n9. `src/pages/ResetPassword.tsx`\n   - This component represents the reset password page of the application.\n   - It is accessed via a unique token sent to the user's email after initiating the password reset process.\n   - It includes a form with input fields for the new password and password confirmation.\n   - It handles form submission and sends a request to the backend API to update the user's password.\n   - It displays a success message or error message based on the response from the backend.\n   - It uses Chakra UI components for styling and layout.\n\n10. `src/pages/Account.tsx`\n    - This component represents the user's account page.\n    - It includes sections for verifying the user's email, accessing the playground, viewing activity history, managing billing, and configuring API keys.\n    - It fetches the user's account data from the backend API using TanStack Query.\n    - It uses Chakra UI components for styling and layout.\n\n11. `src/pages/Playground.tsx`\n    - This component represents the playground page for interactive testing.\n    - It includes an embedded form or code editor where users can test the verification system.\n    - It provides options to copy the playground form code and retrieve API keys.\n    - It displays a sidebar with the user's activity history.\n    - It uses Chakra UI components for styling and layout.\n\n12. `src/pages/Activity.tsx`\n    - This component represents the activity page, displaying all verification requests.\n    - It fetches the user's verification history from the backend API using TanStack Query.\n    - It displays a list or table of verification requests, including details like date, status, and actions.\n    - It allows the user to filter or search the verification requests based on specific criteria.\n    - It uses Chakra UI components for styling and layout.\n\n13. `src/pages/Billing.tsx`\n    - This component represents the billing page, displaying the user's billing history and projections.\n    - It fetches the user's billing data from the backend API using TanStack Query.\n    - It displays a summary of the user's current billing plan and usage.\n    - It shows a list or table of past billing transactions and invoices.\n    - It provides options for updating the billing plan or payment methods.\n    - It uses Chakra UI components for styling and layout.\n\n14. `src/pages/APIKeys.tsx`\n    - This component represents the API keys page, displaying the user's API keys and their usage.\n    - It fetches the user's API keys from the backend API using TanStack Query.\n    - It displays a list of API keys, including their names, creation dates, and permissions.\n    - It allows the user to create new API keys, update existing keys, or revoke keys.\n    - It expands each API key to show detailed usage information, such as request counts and last used timestamps.\n    - It uses Chakra UI components for styling and layout.\n\n15. `src/pages/Settings.tsx`\n    - This component represents the user's settings page.\n    - It includes sections for changing the user's name, email, password, exporting data, and deleting the account.\n    - It fetches the user's current settings from the backend API using TanStack Query.\n    - It provides forms or input fields for updating the user's information.\n    - It handles form submission and sends requests to the backend API to update the user's settings.\n    - It displays success or error messages based on the response from the backend.\n    - It uses Chakra UI components for styling and layout.\n\n16. `src/pages/VerificationRequest.tsx`\n    - This component represents the verification request page, where the user lands when the system requests verification.\n    - It displays information about the verification request, including the purpose and required steps.\n    - It provides options for the user to choose to verify or decline the request.\n    - If the user chooses to verify, it redirects them to the verification page.\n    - It uses Chakra UI components for styling and layout.\n\n17. `src/pages/Verification.tsx`\n    - This component represents the verification page, where the user completes the verification process.\n    - It guides the user through the necessary steps, such as capturing photos, providing personal information, or completing challenges.\n    - It communicates with the backend API to initiate and complete the verification process.\n    - It displays progress indicators and instructions to assist the user.\n    - It handles errors or exceptions that may occur during the verification process.\n    - It uses Chakra UI components for styling and layout.\n\n18. `src/pages/PrivacyPolicy.tsx`\n    - This component represents the privacy policy page.\n    - It displays the company's privacy policy, explaining how user data is collected, used, and protected.\n    - It uses Chakra UI components for styling and layout.\n\n19. `src/pages/TermsOfService.tsx`\n    - This component represents the terms of service page.\n    - It displays the company's terms of service, outlining the rules and conditions for using the application.\n    - It uses Chakra UI components for styling and layout.\n\n20. `src/services/api.ts`\n    - This file contains the configuration and setup for making API requests to the backend.\n    - It uses libraries like Axios or the built-in `fetch` API to send HTTP requests.\n    - It defines the base URL for the backend API and any default headers or authentication tokens.\n    - It provides functions or classes for making specific API requests, such as user registration, login, or verification.\n    - It handles the response from the backend and returns the relevant data or error messages.\n\n21. `src/utils/auth.ts`\n    - This file contains utility functions related to authentication and authorization.\n    - It provides functions for storing and retrieving authentication tokens from local storage or cookies.\n    - It includes functions for checking the user's authentication status and role-based permissions.\n    - It handles the logic for logging in, logging out, and managing user sessions.\n\n22. `src/utils/validation.ts`\n    - This file contains utility functions for form validation.\n    - It defines validation schemas or rules for different form fields, such as email, password, or phone number.\n    - It provides functions for validating form inputs and returning error messages if the validation fails.\n    - It can use libraries like Yup or Joi for schema-based validation.\n\n23. `src/utils/helpers.ts`\n    - This file contains various helper functions used throughout the application.\n    - It includes functions for formatting dates, currencies, or other data.\n    - It provides utility functions for manipulating arrays, objects, or strings.\n    - It defines any custom hooks or reusable logic that can be shared across components.\n\n24. `src/styles/theme.ts`\n    - This file defines the custom theme configuration for Chakra UI.\n    - It specifies the color palette, typography, spacing, and other design tokens used in the application.\n    - It can override or extend the default Chakra UI theme to match the desired visual style.\n\n25. `src/styles/global.css`\n    - This file contains global styles that are applied throughout the application.\n    - It includes CSS resets, font imports, and any other global CSS rules.\n    - It can be used to define custom utility classes or common styles shared across components.\n\n26. `src/types/index.ts`\n    - This file contains TypeScript type definitions used in the application.\n    - It defines interfaces, enums, or custom types for data structures, API responses, or form inputs.\n    - It helps ensure type safety and provides autocompletion and type checking during development.\n\n27. `src/tests/`\n    - This directory contains the test files for the frontend components and utilities.\n    - It includes unit tests for individual components, hooks, or helper functions.\n    - It may also include integration tests to verify the interaction between components and the backend API.\n    - It uses testing frameworks like Jest and React Testing Library for writing and running tests.\n    - It follows a naming convention, such as `ComponentName.test.tsx`, for organizing test files.\n\n28. `src/config/`\n    - This directory contains configuration files for the frontend application.\n    - It includes files for environment-specific variables, such as API endpoints, authentication keys, or feature flags.\n    - It helps manage different configurations for development, staging, and production environments.\n\n29. `public/`\n    - This directory contains the public assets of the application.\n    - It includes the `index.html` file, which is the entry point of the application.\n    - It also includes static assets like images, fonts, or favicon.\n    - The files in this directory are served as-is by the web server.\n\n30. `package.json` and `package-lock.json`\n    - These files contain the project's dependencies and scripts.\n    - `package.json` lists the project's metadata, dependencies, and scripts for building, testing, and running the application.\n    - `package-lock.json` is automatically generated and contains the exact versions of the installed dependencies.\n\n31. `tsconfig.json`\n    - This file contains the TypeScript configuration for the project.\n    - It specifies the compiler options, such as target ECMAScript version, module system, and strict type checking.\n    - It also defines the include and exclude patterns for TypeScript files.\n\n32. `.env`\n    - This file contains environment variables used by the application.\n    - It stores sensitive information, such as API keys, database credentials, or other configuration values.\n    - It should not be committed to version control and should be kept secure.\n\n33. `.gitignore`\n    - This file specifies the files and directories that should be ignored by Git version control.\n    - It typically includes build artifacts, dependencies, and generated files that should not be committed to the repository.\n\n34. `README.md`\n    - This file provides an overview and documentation for the frontend application.\n    - It includes instructions for setting up the development environment, running the application, and deploying it.\n    - It also provides information about the project's structure, dependencies, and any other relevant details.\n\nThis detailed specification outlines the key components, pages, and files required for the frontend application. It covers the main functionality, user interface, state management, API integration, testing, and configuration aspects of the application.\n\nBy following this specification, an LLM or a development team can create the frontend application step by step, implementing each component and file with the necessary logic and user interface elements.\n\nRemember to break down the development process into smaller tasks, prioritize the essential features, and iterate based on user feedback and testing results. Regularly review and update the specification as the project evolves and new requirements emerge."
                }
            ]
        },
        {
            "role": "user",
            "content": [
                {
                    "type": "text",
                    "text": "You didn't complete the config and tests and public dirs please go over all their files. then tell me when you are actually ready to begin implementing the code. No trunc:\n"
                }
            ]
        },
        {
            "role": "assistant",
            "content": [
                {
                    "type": "text",
                    "text": "Apologies for the oversight. Let me provide more details on the `config`, `tests`, and `public` directories, and then we can proceed with the implementation.\n\n`src/config/`\n35. `src/config/api.ts`\n   - This file contains the configuration for the backend API.\n   - It defines the base URL for the API endpoints.\n   - It also includes any API-specific settings or constants.\n\n36. `src/config/auth.ts`\n   - This file contains the configuration for authentication.\n   - It defines the authentication endpoints, such as login and register.\n   - It also includes any authentication-related constants or settings.\n\n37. `src/config/theme.ts`\n   - This file contains the configuration for the Chakra UI theme.\n   - It defines the custom theme settings, such as colors, fonts, and spacing.\n   - It also includes any theme-related constants or settings.\n\n38. `src/config/constants.ts`\n   - This file contains various constants used throughout the application.\n   - It defines constants for routes, local storage keys, or any other application-specific constants.\n\n`src/tests/`\n39. `src/tests/components/`\n   - This directory contains the test files for individual components.\n   - Each component should have a corresponding test file, e.g., `Navigation.test.tsx`, `Footer.test.tsx`, etc.\n   - The test files should cover the rendering, behavior, and edge cases of the components.\n\n40. `src/tests/pages/`\n   - This directory contains the test files for page components.\n   - Each page component should have a corresponding test file, e.g., `Home.test.tsx`, `Login.test.tsx`, etc.\n   - The test files should cover the rendering, user interactions, and integration with other components or services.\n\n41. `src/tests/services/`\n   - This directory contains the test files for service modules.\n   - Each service module should have a corresponding test file, e.g., `api.test.ts`, `auth.test.ts`, etc.\n   - The test files should cover the functionality, error handling, and edge cases of the service modules.\n\n42. `src/tests/utils/`\n   - This directory contains the test files for utility functions.\n   - Each utility function or module should have a corresponding test file, e.g., `validation.test.ts`, `helpers.test.ts`, etc.\n   - The test files should cover the input/output behavior and edge cases of the utility functions.\n\n43. `src/tests/setup.ts`\n   - This file contains the setup configuration for the testing environment.\n   - It includes any necessary setup steps, such as initializing libraries or mocking dependencies.\n   - It is executed before running the test suite.\n\n`public/`\n44. `public/index.html`\n   - This file is the main HTML template for the application.\n   - It includes the root element where the React application will be rendered.\n   - It also includes any necessary meta tags, links to stylesheets, or scripts.\n\n45. `public/favicon.ico`\n   - This file is the favicon image for the application.\n   - It is displayed in the browser's address bar and bookmarks.\n\n46. `public/logo.png`\n   - This file is the logo image for the application.\n   - It can be used in various places throughout the application, such as the header or footer.\n\n47. `public/manifest.json`\n   - This file is the web app manifest for the application.\n   - It provides metadata about the application, such as the name, icons, and theme colors.\n   - It is used by browsers and devices to provide a more native-like experience.\n\n48. `public/robots.txt`\n   - This file is used to control the behavior of web crawlers and search engine bots.\n   - It specifies which pages or sections of the application should be crawled or indexed.\n\nNow that we have covered all the necessary files and directories in detail, we are ready to begin implementing the code for the frontend application. Let me know if you have any further questions or if you would like me to proceed with the implementation of specific files or components."
                }
            ]
        },
        {
            "role": "user",
            "content": [
                {
                    "type": "text",
                    "text": "Now begin writing each file in order. Do not truncate. If you don't have nough tokens to complete all 48 files exhaustively, i will prompt you to pick up where you left off. Make sure you dont leave out the logic. Please start from the beginning again,and this time, make sure to write the ENTIRE file. NO TRUNCATION. NO TRUNC. FULL CODE. WORKING IMPLEMENTATION:"
                }
            ]
        },
        {
            "role": "assistant",
            "content": [
                {
                    "type": "text",
                    "text": "Let's start from the beginning and write the entire code for each file without truncation. Here's the complete working implementation:\n\n1. `src/main.tsx`\n\n```tsx\nimport React from 'react';\nimport ReactDOM from 'react-dom';\nimport { ChakraProvider } from '@chakra-ui/react';\nimport { QueryClient, QueryClientProvider } from '@tanstack/react-query';\nimport { ReactRouter } from '@tanstack/react-router';\nimport theme from './styles/theme';\nimport App from './App';\n\nconst queryClient = new QueryClient();\n\nReactDOM.render(\n  <React.StrictMode>\n    <ChakraProvider theme={theme}>\n      <QueryClientProvider client={queryClient}>\n        <ReactRouter>\n          <App />\n        </ReactRouter>\n      </QueryClientProvider>\n    </ChakraProvider>\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n```\n\n2. `src/App.tsx`\n\n```tsx\nimport React from 'react';\nimport { Box } from '@chakra-ui/react';\nimport { Route, Routes } from '@tanstack/react-router';\nimport Navigation from './components/Navigation';\nimport Footer from './components/Footer';\nimport Home from './pages/Home';\nimport Login from './pages/Login';\nimport Register from './pages/Register';\nimport ForgotPassword from './pages/ForgotPassword';\nimport ResetPassword from './pages/ResetPassword';\nimport Account from './pages/Account';\nimport Playground from './pages/Playground';\nimport Activity from './pages/Activity';\nimport Billing from './pages/Billing';\nimport APIKeys from './pages/APIKeys';\nimport Settings from './pages/Settings';\nimport VerificationRequest from './pages/VerificationRequest';\nimport Verification from './pages/Verification';\nimport PrivacyPolicy from './pages/PrivacyPolicy';\nimport TermsOfService from './pages/TermsOfService';\n\nconst App: React.FC = () => {\n  return (\n    <Box>\n      <Navigation />\n      <Routes>\n        <Route path=\"/\" element={<Home />} />\n        <Route path=\"/login\" element={<Login />} />\n        <Route path=\"/register\" element={<Register />} />\n        <Route path=\"/forgot-password\" element={<ForgotPassword />} />\n        <Route path=\"/reset-password\" element={<ResetPassword />} />\n        <Route path=\"/account\" element={<Account />} />\n        <Route path=\"/playground\" element={<Playground />} />\n        <Route path=\"/activity\" element={<Activity />} />\n        <Route path=\"/billing\" element={<Billing />} />\n        <Route path=\"/api-keys\" element={<APIKeys />} />\n        <Route path=\"/settings\" element={<Settings />} />\n        <Route path=\"/verification-request\" element={<VerificationRequest />} />\n        <Route path=\"/verification\" element={<Verification />} />\n        <Route path=\"/privacy-policy\" element={<PrivacyPolicy />} />\n        <Route path=\"/terms-of-service\" element={<TermsOfService />} />\n      </Routes>\n      <Footer />\n    </Box>\n  );\n};\n\nexport default App;\n```\n\n3. `src/components/Navigation.tsx`\n\n```tsx\nimport React from 'react';\nimport { Box, Flex, Link } from '@chakra-ui/react';\nimport { Link as RouterLink, useLocation } from '@tanstack/react-router';\n\nconst Navigation: React.FC = () => {\n  const location = useLocation();\n\n  return (\n    <Box as=\"nav\" bg=\"gray.100\" py={4}>\n      <Flex justify=\"space-between\" align=\"center\" maxW=\"container.lg\" mx=\"auto\">\n        <Link as={RouterLink} to=\"/\" fontWeight=\"bold\">\n          GOTCHA\n        </Link>\n        <Flex>\n          <Link\n            as={RouterLink}\n            to=\"/account\"\n            ml={4}\n            fontWeight={location.pathname === '/account' ? 'bold' : 'normal'}\n          >\n            Account\n          </Link>\n          <Link\n            as={RouterLink}\n            to=\"/playground\"\n            ml={4}\n            fontWeight={location.pathname === '/playground' ? 'bold' : 'normal'}\n          >\n            Playground\n          </Link>\n          <Link\n            as={RouterLink}\n            to=\"/docs\"\n            ml={4}\n            fontWeight={location.pathname === '/docs' ? 'bold' : 'normal'}\n          >\n            Documentation\n          </Link>\n        </Flex>\n      </Flex>\n    </Box>\n  );\n};\n\nexport default Navigation;\n```\n\n4. `src/components/Footer.tsx`\n\n```tsx\nimport React from 'react';\nimport { Box, Flex, Link, Text } from '@chakra-ui/react';\nimport { Link as RouterLink } from '@tanstack/react-router';\n\nconst Footer: React.FC = () => {\n  return (\n    <Box as=\"footer\" bg=\"gray.100\" py={8}>\n      <Flex justify=\"space-between\" align=\"center\" maxW=\"container.lg\" mx=\"auto\">\n        <Text>&copy; {new Date().getFullYear()} GOTCHA. All rights reserved.</Text>\n        <Flex>\n          <Link as={RouterLink} to=\"/privacy-policy\" ml={4}>\n            Privacy Policy\n          </Link>\n          <Link as={RouterLink} to=\"/terms-of-service\" ml={4}>\n            Terms of Service\n          </Link>\n        </Flex>\n      </Flex>\n    </Box>\n  );\n};\n\nexport default Footer;\n```\n\n5. `src/pages/Home.tsx`\n\n```tsx\nimport React from 'react';\nimport { Box, Button, Heading, Text } from '@chakra-ui/react';\nimport { Link as RouterLink } from '@tanstack/react-router';\n\nconst Home: React.FC = () => {\n  return (\n    <Box maxW=\"container.lg\" mx=\"auto\" py={8}>\n      <Heading as=\"h1\" size=\"xl\" mb={4}>\n        Welcome to GOTCHA\n      </Heading>\n      <Text fontSize=\"xl\" mb={8}>\n        The ultimate Graphical Online Turing test to Confirm Human Activity.\n      </Text>\n      <Button as={RouterLink} to=\"/playground\" colorScheme=\"blue\" size=\"lg\">\n        Try it out\n      </Button>\n    </Box>\n  );\n};\n\nexport default Home;\n```\n\n6. `src/pages/Login.tsx`\n\n```tsx\nimport React, { useState } from 'react';\nimport { Box, Button, FormControl, FormLabel, Heading, Input, Text } from '@chakra-ui/react';\nimport { Link as RouterLink, useNavigate } from '@tanstack/react-router';\nimport { useMutation } from '@tanstack/react-query';\nimport { login } from '../services/api';\n\nconst Login: React.FC = () => {\n  const [email, setEmail] = useState('');\n  const [password, setPassword] = useState('');\n  const navigate = useNavigate();\n\n  const { mutate: loginMutation, isLoading, error } = useMutation(login, {\n    onSuccess: () => {\n      navigate('/account');\n    },\n  });\n\n  const handleSubmit = (e: React.FormEvent) => {\n    e.preventDefault();\n    loginMutation({ email, password });\n  };\n\n  return (\n    <Box maxW=\"container.sm\" mx=\"auto\" py={8}>\n      <Heading as=\"h1\" size=\"xl\" mb={8}>\n        Login\n      </Heading>\n      <form onSubmit={handleSubmit}>\n        <FormControl id=\"email\" mb={4}>\n          <FormLabel>Email address</FormLabel>\n          <Input\n            type=\"email\"\n            value={email}\n            onChange={(e) => setEmail(e.target.value)}\n            required\n          />\n        </FormControl>\n        <FormControl id=\"password\" mb={8}>\n          <FormLabel>Password</FormLabel>\n          <Input\n            type=\"password\"\n            value={password}\n            onChange={(e) => setPassword(e.target.value)}\n            required\n          />\n        </FormControl>\n        {error && (\n          <Text color=\"red.500\" mb={4}>\n            {error.message}\n          </Text>\n        )}\n        <Button type=\"submit\" colorScheme=\"blue\" size=\"lg\" width=\"full\" isLoading={isLoading}>\n          Login\n        </Button>\n      </form>\n      <Box mt={8}>\n        <RouterLink to=\"/forgot-password\">Forgot password?</RouterLink>\n      </Box>\n      <Box mt={4}>\n        Don't have an account? <RouterLink to=\"/register\">Register</RouterLink>\n      </Box>\n    </Box>\n  );\n};\n\nexport default Login;\n```\n\n7. `src/pages/Register.tsx`\n\n```tsx\nimport React, { useState } from 'react';\nimport { Box, Button, FormControl, FormLabel, Heading, Input, Text } from '@chakra-ui/react';\nimport { Link as RouterLink, useNavigate } from '@tanstack/react-router';\nimport { useMutation } from '@tanstack/react-query';\nimport { register } from '../services/api';\n\nconst Register: React.FC = () => {\n  const [name, setName] = useState('');\n  const [email, setEmail] = useState('');\n  const [password, setPassword] = useState('');\n  const navigate = useNavigate();\n\n  const { mutate: registerMutation, isLoading, error } = useMutation(register, {\n    onSuccess: () => {\n      navigate('/login');\n    },\n  });\n\n  const handleSubmit = (e: React.FormEvent) => {\n    e.preventDefault();\n    registerMutation({ name, email, password });\n  };\n\n  return (\n    <Box maxW=\"container.sm\" mx=\"auto\" py={8}>\n      <Heading as=\"h1\" size=\"xl\" mb={8}>\n        Register\n      </Heading>\n      <form onSubmit={handleSubmit}>\n        <FormControl id=\"name\" mb={4}>\n          <FormLabel>Name</FormLabel>\n          <Input\n            type=\"text\"\n            value={name}\n            onChange={(e) => setName(e.target.value)}\n            required\n          />\n        </FormControl>\n        <FormControl id=\"email\" mb={4}>\n          <FormLabel>Email address</FormLabel>\n          <Input\n            type=\"email\"\n            value={email}\n            onChange={(e) => setEmail(e.target.value)}\n            required\n          />\n        </FormControl>\n        <FormControl id=\"password\" mb={8}>\n          <FormLabel>Password</FormLabel>\n          <Input\n            type=\"password\"\n            value={password}\n            onChange={(e) => setPassword(e.target.value)}\n            required\n          />\n        </FormControl>\n        {error && (\n          <Text color=\"red.500\" mb={4}>\n            {error.message}\n          </Text>\n        )}\n        <Button type=\"submit\" colorScheme=\"blue\" size=\"lg\" width=\"full\" isLoading={isLoading}>\n          Register\n        </Button>\n      </form>\n      <Box mt={8}>\n        Already have an account? <RouterLink to=\"/login\">Login</RouterLink>\n      </Box>\n    </Box>\n  );\n};\n\nexport default Register;\n```\n\n8. `src/pages/ForgotPassword.tsx`\n\n```tsx\nimport React, { useState } from 'react';\nimport { Box, Button, FormControl, FormLabel, Heading, Input, Text } from '@chakra-ui/react';\nimport { Link as RouterLink } from '@tanstack/react-router';\nimport { useMutation } from '@tanstack/react-query';\nimport { forgotPassword } from '../services/api';\n\nconst ForgotPassword: React.FC = () => {\n  const [email, setEmail] = useState('');\n  const [successMessage, setSuccessMessage] = useState('');\n\n  const { mutate: forgotPasswordMutation, isLoading, error } = useMutation(forgotPassword, {\n    onSuccess: () => {\n      setSuccessMessage('Password reset email sent. Please check your inbox.');\n    },\n  });\n\n  const handleSubmit = (e: React.FormEvent) => {\n    e.preventDefault();\n    forgotPasswordMutation({ email });\n  };\n\n  return (\n    <Box maxW=\"container.sm\" mx=\"auto\" py={8}>\n      <Heading as=\"h1\" size=\"xl\" mb={8}>\n        Forgot Password\n      </Heading>\n      <form onSubmit={handleSubmit}>\n        <FormControl id=\"email\" mb={8}>\n          <FormLabel>Email address</FormLabel>\n          <Input\n            type=\"email\"\n            value={email}\n            onChange={(e) => setEmail(e.target.value)}\n            required\n          />\n        </FormControl>\n        {error && (\n          <Text color=\"red.500\" mb={4}>\n            {error.message}\n          </Text>\n        )}\n        {successMessage && (\n          <Text color=\"green.500\" mb={4}>\n            {successMessage}\n          </Text>\n        )}\n        <Button type=\"submit\" colorScheme=\"blue\" size=\"lg\" width=\"full\" isLoading={isLoading}>\n          Reset Password\n        </Button>\n      </form>\n      <Box mt={8}>\n        Remember your password? <RouterLink to=\"/login\">Login</RouterLink>\n      </Box>\n    </Box>\n  );\n};\n\nexport default ForgotPassword;\n```\n\n9. `src/pages/ResetPassword.tsx`\n\n```tsx\nimport React, { useState } from 'react';\nimport { Box, Button, FormControl, FormLabel, Heading, Input, Text } from '@chakra-ui/react';\nimport { Link as RouterLink, useNavigate, useSearch } from '@tanstack/react-router';\nimport { useMutation } from '@tanstack/react-query';\nimport { resetPassword } from '../services/api';\n\nconst ResetPassword: React.FC = () => {\n  const [password, setPassword] = useState('');\n  const [confirmPassword, setConfirmPassword] = useState('');\n  const navigate = useNavigate();\n  const search = useSearch();\n  const token = search.token as string;\n\n  const { mutate: resetPasswordMutation, isLoading, error } = useMutation(resetPassword, {\n    onSuccess: () => {\n      navigate('/login');\n    },\n  });\n\n  const handleSubmit = (e: React.FormEvent) => {\n    e.preventDefault();\n    if (password !== confirmPassword) {\n      alert('Passwords do not match');\n      return;\n    }\n    resetPasswordMutation({ token, password });\n  };\n\n  return (\n    <Box maxW=\"container.sm\" mx=\"auto\" py={8}>\n      <Heading as=\"h1\" size=\"xl\" mb={8}>\n        Reset Password\n      </Heading>\n      <form onSubmit={handleSubmit}>\n        <FormControl id=\"password\" mb={4}>\n          <FormLabel>New Password</FormLabel>\n          <Input\n            type=\"password\"\n            value={password}\n            onChange={(e) => setPassword(e.target.value)}\n            required\n          />\n        </FormControl>\n        <FormControl id=\"confirmPassword\" mb={8}>\n          <FormLabel>Confirm Password</FormLabel>\n          <Input\n            type=\"password\"\n            value={confirmPassword}\n            onChange={(e) => setConfirmPassword(e.target.value)}\n            required\n          />\n        </FormControl>\n        {error && (\n          <Text color=\"red.500\" mb={4}>\n            {error.message}\n          </Text>\n        )}\n        <Button type=\"submit\" colorScheme=\"blue\" size=\"lg\" width=\"full\" isLoading={isLoading}>\n          Reset Password\n        </Button>\n      </form>\n      <Box mt={8}>\n        <RouterLink to=\"/login\">Back to Login</RouterLink>\n      </Box>\n    </Box>\n  );\n};\n\nexport default ResetPassword;\n```"
                }
            ]
        }
    ]
)
print(message.content)